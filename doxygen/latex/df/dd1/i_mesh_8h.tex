\hypertarget{i_mesh_8h}{}\section{D\+N\+S/src/intfc/i\+Mesh.h File Reference}
\label{i_mesh_8h}\index{D\+N\+S/src/intfc/i\+Mesh.\+h@{D\+N\+S/src/intfc/i\+Mesh.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{i_mesh_8h_afaaf6107dc6ee571fe4159eb6e8f1639}{I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}~0
\item 
\#define \hyperlink{i_mesh_8h_a9f7f1610272df0c2400a258ad91cc6fc}{I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}~8
\item 
\#define \hyperlink{i_mesh_8h_a52588733df76d324cb16d2cc8204c914}{I\+T\+A\+PS}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct i\+Mesh\+\_\+\+Instance\+\_\+\+Private $\ast$ \hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance}
\begin{DoxyCompactList}\small\item\em Type used to store i\+Mesh interface handle. \end{DoxyCompactList}\item 
typedef struct i\+Mesh\+\_\+\+Entity\+Iterator\+\_\+\+Private $\ast$ \hyperlink{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{i\+Mesh\+\_\+\+Entity\+Iterator}
\begin{DoxyCompactList}\small\item\em Type used to store an iterator returned by i\+Mesh. \end{DoxyCompactList}\item 
typedef struct i\+Mesh\+\_\+\+Entity\+Arr\+Iterator\+\_\+\+Private $\ast$ \hyperlink{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}
\begin{DoxyCompactList}\small\item\em Type used to store an array iterator returned by i\+Mesh. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693}{i\+Mesh\+\_\+\+Entity\+Topology} \{ \\*
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693af7ac92ddaf5a14fa09aaba5f94777102}{i\+Mesh\+\_\+\+P\+O\+I\+NT} = 0, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693afcd1b4f641f4b56b4ccd7b21c1f9d0ff}{i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4b86cb245e026e043c2476c93cdde6b4}{i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a556317b351bacb64961561292a1383f8}{i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE}, 
\\*
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693acf502601729e3e90bf3bc3daee049d0b}{i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693ad1d916005ac88bdeec3bd17ffa379711}{i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a118bbf2d507021ee7a3f9b437fed2679}{i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a8c0820cf31a15bb8c50310099820d0f1}{i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON}, 
\\*
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a1a8d75aedb371df3819f81423067be43}{i\+Mesh\+\_\+\+P\+R\+I\+SM}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4ae782c6755761695b56a89312386216}{i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a24c904fb9e4a685372c6649d0567a0db}{i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON}, 
\hyperlink{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693aa0c93b5d9f70d468e50e28b09652b6df}{i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES}
 \}\begin{DoxyCompactList}\small\item\em Enumerator specifying entity topology. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{i_mesh_8h_a6171289cdd1d235080d110b5648bd874}{i\+Mesh\+\_\+get\+Error\+Type} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int $\ast$error\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the error type returned from the last i\+Mesh function. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a2032ff525b201ab75a17741e5aeede0b}{i\+Mesh\+\_\+get\+Description} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, char $\ast$descr, int $\ast$err, int descr\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get a description of the error returned from the last i\+Mesh function. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a4cad54751326a7f612d10edef91268d6}{i\+Mesh\+\_\+new\+Mesh} (const char $\ast$options, \hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} $\ast$instance, int $\ast$err, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Construct a new i\+Mesh instance. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7427c404c05781f8d033ed917d075a5c}{i\+Mesh\+\_\+dtor} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy an i\+Mesh instance. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ac1afb5d0b8f5a8fbe6747b04c1c58ab6}{i\+Mesh\+\_\+load} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const char $\ast$name, const char $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Load a mesh from a file. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aa52f6758cfb4f0bfe002adeb056aef9d}{i\+Mesh\+\_\+save} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const char $\ast$name, const char $\ast$options, int $\ast$err, const int name\+\_\+len, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Save a mesh to a file. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_adf856b94c7d790d283256cb98a0dc820}{i\+Mesh\+\_\+get\+Root\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$root\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get handle of the root set for this instance. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ab7a715d93b00e313cee42b5cc2261c4e}{i\+Mesh\+\_\+get\+Geometric\+Dimension} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int $\ast$geom\+\_\+dim, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the geometric dimension of mesh represented in this instance. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_acd82803db0b898c6432521d081c1d15b}{i\+Mesh\+\_\+set\+Geometric\+Dimension} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int geom\+\_\+dim, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set geometric dimension of vertex coordinates. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_acb9413fa63c18b0ff1dfce4b21956e58}{i\+Mesh\+\_\+get\+Dflt\+Storage} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int $\ast$\hyperlink{triangle_8c_a80adbd8c4abbb5a23a121d7c19e82c92}{order}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the default storage order used by this implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7ae5c3416715a80e3d7c3ad4a57bf0fc}{i\+Mesh\+\_\+get\+Adj\+Table} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int $\ast$$\ast$adjacency\+\_\+table, int $\ast$adjacency\+\_\+table\+\_\+allocated, int $\ast$adjacency\+\_\+table\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the adjacency table for this implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad50cf7c272d0266227916e7cbc3a9b98}{i\+Mesh\+\_\+get\+Num\+Of\+Type} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int entity\+\_\+type, int $\ast$num\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of entities with the specified type in the instance or set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a83ad629a57d165cdd4391ce96c0d3667}{i\+Mesh\+\_\+get\+Num\+Of\+Topo} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int entity\+\_\+topology, int $\ast$num\+\_\+topo, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of entities with the specified topology in the instance or set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a37e57041ef15b9ac25b6b2bad3e9f9a0}{i\+Mesh\+\_\+are\+E\+H\+Valid} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, int do\+Reset, int $\ast$are\+Handles\+Invariant, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether entity handles have changed since last reset or since instance construction. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a64c090fe396ca5a720344ed7cd57717f}{i\+Mesh\+\_\+get\+Entities} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int entity\+\_\+type, const int entity\+\_\+topology, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specific type and/or topology in set or instance. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_abd07e5b0e3f08eef8b87a2ca78998b71}{i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$vertex\+\_\+handles, const int vertex\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$coords, int $\ast$coords\+\_\+allocated, int $\ast$coords\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get coordinates of specified vertices. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ada98301d3d9aa31d407f6f340987b72b}{i\+Mesh\+\_\+init\+Ent\+Arr\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int requested\+\_\+entity\+\_\+type, const int requested\+\_\+entity\+\_\+topology, const int requested\+\_\+array\+\_\+size, \hyperlink{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator} $\ast$ent\+Arr\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Initialize an array iterator over specified entity type, topology, and size. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a55cf01def1dcc7e89e0aed1236fc4ca0}{i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator} ent\+Arr\+\_\+iterator, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$has\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities contained in array iterator and increment iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a35ee44a4e22992190f2727fbe412adc5}{i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator} ent\+Arr\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Reset the array iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a13f8cdb1b07e6c43fa92c4a71024d855}{i\+Mesh\+\_\+end\+Ent\+Arr\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator} ent\+Arr\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy the specified array iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a696531f49b668acc59304158fafebe71}{i\+Mesh\+\_\+get\+Ent\+Arr\+Topo} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$topology, int $\ast$topology\+\_\+allocated, int $\ast$topology\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity topology for the specified entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a85d470f5e5d4fef4a39ed17cd5af7f84}{i\+Mesh\+\_\+get\+Ent\+Arr\+Type} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$type, int $\ast$type\+\_\+allocated, int $\ast$type\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity type for the specified entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a80563216001caf07de7c64481282fed9}{i\+Mesh\+\_\+get\+Ent\+Arr\+Adj} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const int entity\+\_\+type\+\_\+requested, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adjacent\+Entity\+Handles, int $\ast$adjacent\+Entity\+Handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specified type adjacent to entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a4001293d00b3d08228cf40328bfbbb2a}{i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int bridge\+\_\+entity\+\_\+type, int requested\+\_\+entity\+\_\+type, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities, that is, from each entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a79a6fe207698e2b29bbffac7f4a09e49}{i\+Mesh\+\_\+get\+Adj\+Ent\+Indices} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int entity\+\_\+type\+\_\+requestor, int entity\+\_\+topology\+\_\+requestor, int entity\+\_\+type\+\_\+requested, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$adj\+\_\+entity\+\_\+indices, int $\ast$adj\+\_\+entity\+\_\+indices\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+indices\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get indexed representation of mesh or subset of mesh. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a5c011a4d7805b8c61aafaa5a121ff7a0}{i\+Mesh\+\_\+create\+Ent\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const int is\+List, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$entity\+\_\+set\+\_\+created, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a096ca8e137fa3149d303935839e09c94}{i\+Mesh\+\_\+destroy\+Ent\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aa8dff2f4ba439506c5834010e652f1f4}{i\+Mesh\+\_\+is\+List} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$is\+\_\+list, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether a specified set is ordered or unordered. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a839d3d49cf96ac8f8a2e39334334f868}{i\+Mesh\+\_\+get\+Num\+Ent\+Sets} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int num\+\_\+hops, int $\ast$num\+\_\+sets, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of entity sets contained in a set or interface. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a29ef0f937b69721dd7974b01e785ba76}{i\+Mesh\+\_\+get\+Ent\+Sets} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$contained\+\_\+set\+\_\+handles, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity sets contained in a set or interface. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a3dfae4b555d968744428e9b21d087440}{i\+Mesh\+\_\+add\+Ent\+To\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an entity to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ac00e7cf0fb85976301ae8635e1ef844b}{i\+Mesh\+\_\+rmv\+Ent\+From\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an entity from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a9b706668d662ed50aeb4e1483709c873}{i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an array of entities to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a14ceb1d85e28e22a52f3df0b6e8d938a}{i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an array of entities from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aca90b20d6db5d383b737eb4c3750ba5a}{i\+Mesh\+\_\+add\+Ent\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+to\+\_\+add, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an entity set to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad6c792d5c60aee48658a7c9299b68b35}{i\+Mesh\+\_\+rmv\+Ent\+Set} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+to\+\_\+remove, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an entity set from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a3e2b00fa7b0441314c36e59e30d5c039}{i\+Mesh\+\_\+is\+Ent\+Contained} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} contained\+\_\+entity, int $\ast$is\+\_\+contained, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether an entity is contained in another set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_af0dec15d1335706e08cd210416ca6b64}{i\+Mesh\+\_\+is\+Ent\+Arr\+Contained} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+set, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int num\+\_\+entity\+\_\+handles, int $\ast$$\ast$is\+\_\+contained, int $\ast$is\+\_\+contained\+\_\+allocated, int $\ast$is\+\_\+contained\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether entities are contained in a set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a4c2d90242ba253c81a41415315c8c282}{i\+Mesh\+\_\+is\+Ent\+Set\+Contained} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+entity\+\_\+set, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} contained\+\_\+entity\+\_\+set, int $\ast$is\+\_\+contained, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether an entity set is contained in another set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7f0fae1a8ebe26e71e3887f5e2aafe32}{i\+Mesh\+\_\+add\+Prnt\+Chld} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add parent/child links between two sets. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a974552a248c18b04da2f5d8d27574039}{i\+Mesh\+\_\+rmv\+Prnt\+Chld} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove parent/child links between two sets. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a225d1b47fc61a35a2b8c85082883731b}{i\+Mesh\+\_\+is\+Child\+Of} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$is\+\_\+child, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether two sets are related by parent/child links. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ae026ab7bd6910e0061deddbad5824af2}{i\+Mesh\+\_\+get\+Num\+Chld} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const int num\+\_\+hops, int $\ast$num\+\_\+child, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of child sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad95b3ebf036990421d3bccf4705cdd6d}{i\+Mesh\+\_\+get\+Num\+Prnt} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const int num\+\_\+hops, int $\ast$num\+\_\+parent, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of parent sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a2bddf55659efb86437d17f9f04e845fe}{i\+Mesh\+\_\+get\+Chldn} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} from\+\_\+entity\+\_\+set, const int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the child sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aae703e9789343cb39f04b373b046a31b}{i\+Mesh\+\_\+get\+Prnts} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} from\+\_\+entity\+\_\+set, const int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the parent sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a07da5a094467daf359fa9dfae961865a}{i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$vertex\+\_\+handles, const int vertex\+\_\+handles\+\_\+size, const int storage\+\_\+order, const double $\ast$new\+\_\+coords, const int new\+\_\+coords\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set coordinates for an array of vertices. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a8596670832ac7365496ac586e85a2a11}{i\+Mesh\+\_\+create\+Vtx\+Arr} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const int num\+\_\+verts, const int storage\+\_\+order, const double $\ast$new\+\_\+coords, const int new\+\_\+coords\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$new\+\_\+vertex\+\_\+handles, int $\ast$new\+\_\+vertex\+\_\+handles\+\_\+allocated, int $\ast$new\+\_\+vertex\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create an array of new vertices at specified coordinates. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a817380ba91d5fff1fe0e656982f0375e}{i\+Mesh\+\_\+create\+Ent\+Arr} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const int new\+\_\+entity\+\_\+topology, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$lower\+\_\+order\+\_\+entity\+\_\+handles, const int lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$new\+\_\+entity\+\_\+handles, int $\ast$new\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$new\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$status, int $\ast$status\+\_\+allocated, int $\ast$status\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create an array of new entities with specified lower-\/order topology. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a9b34843000571f5094298d483a45ed21}{i\+Mesh\+\_\+delete\+Ent\+Arr} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Delete specified entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad9968a85ef3ce2ace3e44328595fa288}{i\+Mesh\+\_\+create\+Tag} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const char $\ast$tag\+\_\+name, const int tag\+\_\+size, const int tag\+\_\+type, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$tag\+\_\+handle, int $\ast$err, const int tag\+\_\+name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Create a tag with specified name, size, and type. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a4153a6605adcdc67ef57c7d514388c23}{i\+Mesh\+\_\+destroy\+Tag} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const int forced, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy a tag. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a2d38d21836b5b34afedf8618fa3ab0b1}{i\+Mesh\+\_\+get\+Tag\+Name} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$name, int $\ast$err, int name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get the name for a given tag handle. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad27ce96f257e893acf217a4cd4c0ff1a}{i\+Mesh\+\_\+get\+Tag\+Size\+Values} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get size of a tag in units of numbers of tag data type. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ac29b077838ecd9cdd108a495b0b3781b}{i\+Mesh\+\_\+get\+Tag\+Size\+Bytes} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get size of a tag in units of bytes. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a18189d281e139de4dd4f1c5f8ca160dc}{i\+Mesh\+\_\+get\+Tag\+Handle} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const char $\ast$tag\+\_\+name, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get a the handle of an existing tag with the specified name. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ab27f8cd8b38e386ccb14475384db9daf}{i\+Mesh\+\_\+get\+Tag\+Type} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the data type of the specified tag handle. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aa16cbc90f20df85e6f3baf91b40afd3b}{i\+Mesh\+\_\+set\+Ent\+Set\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+value, const int tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of arbitrary type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a5ef07cc5e411248bb76fde6a205fca6e}{i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const int tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of integer type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a68084d46c2d4feb2a4a20682bb2d30ea}{i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const double tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of double type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ac1138feca0800d71fe8b812bf4060004}{i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of entity handle type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a246fc9ee2305c0b1e2113c4ee7bc1a4c}{i\+Mesh\+\_\+get\+Ent\+Set\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of arbitrary type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a582c3f1fd86ee82d2937cef00facc646}{i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of integer type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a8d064cd20d3620758ca5f64ae3511fc5}{i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of double type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a4ee01020e3e23e35fcbb99740a331764}{i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of entity handle type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a11afc42d0a3c066bcace23bf2fb0c3a2}{i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get all the tags associated with a specified entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a68ca4321313f179470cfc1bcf032a256}{i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a0c96dfb94434cad6c7db29f220144fa9}{i\+Mesh\+\_\+set\+Vtx\+Coord} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex\+\_\+handle, const double x, const double y, const double z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set coordinates for a vertex. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a28f79a4c8c445804215a751563c26688}{i\+Mesh\+\_\+create\+Vtx} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const double x, const double y, const double z, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$new\+\_\+vertex\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create a new vertex at specified coordinates. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a27772c2a82d0cb1244e3107238f28d7e}{i\+Mesh\+\_\+create\+Ent} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const int new\+\_\+entity\+\_\+topology, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$lower\+\_\+order\+\_\+entity\+\_\+handles, const int lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$new\+\_\+entity\+\_\+handle, int $\ast$status, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create a new entity with specified lower-\/order topology. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a98f1c9d37ee6f7bf0795dda50d3b28f1}{i\+Mesh\+\_\+delete\+Ent} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Delete specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7d0f309db733869e7257cb8fc1401dc5}{i\+Mesh\+\_\+get\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of arbitrary type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ae11f965b537d25c0ada25e8ddb90e014}{i\+Mesh\+\_\+get\+Int\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of integer type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ade3868d5cbf2cafd64ed8aa77db278c6}{i\+Mesh\+\_\+get\+Dbl\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of double type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a61c5040e5c4ed2ebcd87928d830c06f2}{i\+Mesh\+\_\+get\+E\+H\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of entity handle type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a467fa9fb220e96030947628d379436e9}{i\+Mesh\+\_\+set\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of arbitrary type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a50b7f1a1d4f16f5705cf73f16cb57d3f}{i\+Mesh\+\_\+set\+Int\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const int $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of integer type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ab1bc50f12d99f4ccd99e59fa30cc8c88}{i\+Mesh\+\_\+set\+Dbl\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const double $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of double type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad77f0833c9420d9e00b0cff274308931}{i\+Mesh\+\_\+set\+E\+H\+Arr\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of entity handle type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a37d6d1101cbb4093bc06f3e22fda64ee}{i\+Mesh\+\_\+rmv\+Arr\+Tag} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aafe428b3299c2f8f949b6b4b8135f7d3}{i\+Mesh\+\_\+get\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of arbitrary type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad54d7dd86ac0fddb2559f70998aa44f2}{i\+Mesh\+\_\+get\+Int\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of integer type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_acae9d3cd0a9d17904cd72385d9e51e7d}{i\+Mesh\+\_\+get\+Dbl\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of double type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad49ce47881dbefc28fb21998e1ac17b7}{i\+Mesh\+\_\+get\+E\+H\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of entity handle type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a3784b0d130a09e20e1abc23865045f29}{i\+Mesh\+\_\+set\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+value, const int tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of arbitrary type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a49eab82549b65ca328bde367bcc14b0f}{i\+Mesh\+\_\+set\+Int\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const int tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of integer type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad59a555037d0d9abdd2cfaf2a6d90ddd}{i\+Mesh\+\_\+set\+Dbl\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const double tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of double type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ada920950e552c1965f16142ecac1dcad}{i\+Mesh\+\_\+set\+E\+H\+Data} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of entity handle type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aa86c4931bb6e006310087074653f7f4d}{i\+Mesh\+\_\+get\+All\+Tags} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get all the tags associated with a specified entity handle. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a88c6103c0714a55a7662d81957217293}{i\+Mesh\+\_\+rmv\+Tag} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_abb811fce5ee4806ecc41e2f90d6daa1c}{i\+Mesh\+\_\+init\+Ent\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, const int requested\+\_\+entity\+\_\+type, const int requested\+\_\+entity\+\_\+topology, \hyperlink{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{i\+Mesh\+\_\+\+Entity\+Iterator} $\ast$entity\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Initialize an iterator over specified entity type, topology, and size. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad0f4390e7048494bb102c08ecf101182}{i\+Mesh\+\_\+get\+Next\+Ent\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{i\+Mesh\+\_\+\+Entity\+Iterator} entity\+\_\+iterator, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handle, int $\ast$has\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entity corresponding to an iterator and increment iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a5ccc67144aae1a0361e5bde1262a1b3f}{i\+Mesh\+\_\+reset\+Ent\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{i\+Mesh\+\_\+\+Entity\+Iterator} entity\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Reset the iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a8aca84dd5a7882e98870dcf87f922448}{i\+Mesh\+\_\+end\+Ent\+Iter} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{i\+Mesh\+\_\+\+Entity\+Iterator} entity\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy the specified iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ae613bc4feff6b416aaf4de5363e4d00b}{i\+Mesh\+\_\+get\+Ent\+Topo} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$out\+\_\+topo, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity topology for the specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_aef13a6ad1cde578ececa899a44c205c5}{i\+Mesh\+\_\+get\+Ent\+Type} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$out\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity type for the specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ae432d0985a52f15272058821c33e970e}{i\+Mesh\+\_\+get\+Vtx\+Coord} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex\+\_\+handle, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get coordinates of specified vertex. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7c9b464b4ea3aa5f73d7662231a6d780}{i\+Mesh\+\_\+get\+Ent\+Adj} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const int entity\+\_\+type\+\_\+requested, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specified type adjacent to an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ad390b53cb4e74dec0fcefdf6fb3be548}{i\+Mesh\+\_\+get\+Ent2nd\+Adj} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int bridge\+\_\+entity\+\_\+type, int requested\+\_\+entity\+\_\+type, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adjacent\+\_\+entities, int $\ast$adjacent\+\_\+entities\+\_\+allocated, int $\ast$adjacent\+\_\+entities\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get \char`\"{}2nd order\char`\"{} adjacencies to an entity Get \char`\"{}2nd order\char`\"{} adjacencies to an entity, that is, from an entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_a7cc3c2fcb7b439ebb5a88469fa17fa8f}{i\+Mesh\+\_\+subtract} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Subtract contents of one entity set from another. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_af723c3970c6a6c3fbc6e3e682b605959}{i\+Mesh\+\_\+intersect} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Intersect contents of one entity set with another. \end{DoxyCompactList}\item 
void \hyperlink{i_mesh_8h_ae3ab1deec82f6b9c4fb9104b91866a00}{i\+Mesh\+\_\+unite} (\hyperlink{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{i\+Mesh\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, const \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Unite contents of one entity set with another. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON@{I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}}
\index{I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON@{I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}{IMESH_MAJOR_VERSION}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+M\+E\+S\+H\+\_\+\+M\+A\+J\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON~0}\hypertarget{i_mesh_8h_afaaf6107dc6ee571fe4159eb6e8f1639}{}\label{i_mesh_8h_afaaf6107dc6ee571fe4159eb6e8f1639}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON@{I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}}
\index{I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON@{I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON}{IMESH_MINOR_VERSION}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+M\+E\+S\+H\+\_\+\+M\+I\+N\+O\+R\+\_\+\+V\+E\+R\+S\+I\+ON~8}\hypertarget{i_mesh_8h_a9f7f1610272df0c2400a258ad91cc6fc}{}\label{i_mesh_8h_a9f7f1610272df0c2400a258ad91cc6fc}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!I\+T\+A\+PS@{I\+T\+A\+PS}}
\index{I\+T\+A\+PS@{I\+T\+A\+PS}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{I\+T\+A\+PS}{ITAPS}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+T\+A\+PS}\hypertarget{i_mesh_8h_a52588733df76d324cb16d2cc8204c914}{}\label{i_mesh_8h_a52588733df76d324cb16d2cc8204c914}


\subsection{Typedef Documentation}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+Entity\+Arr\+Iterator@{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}}
\index{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator@{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}{iMesh_EntityArrIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Mesh\+\_\+\+Entity\+Arr\+Iterator\+\_\+\+Private$\ast$ {\bf i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}}\hypertarget{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}{}\label{i_mesh_8h_a7a9c509fd164eefb1d9f99866573d423}


Type used to store an array iterator returned by i\+Mesh. 

Type used to store an array iterator returned by i\+Mesh \index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+Entity\+Iterator@{i\+Mesh\+\_\+\+Entity\+Iterator}}
\index{i\+Mesh\+\_\+\+Entity\+Iterator@{i\+Mesh\+\_\+\+Entity\+Iterator}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+\+Entity\+Iterator}{iMesh_EntityIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Mesh\+\_\+\+Entity\+Iterator\+\_\+\+Private$\ast$ {\bf i\+Mesh\+\_\+\+Entity\+Iterator}}\hypertarget{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}{}\label{i_mesh_8h_aab84a42b6e8f87956f877dbacc3df438}


Type used to store an iterator returned by i\+Mesh. 

Type used to store an iterator returned by i\+Mesh \index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+Instance@{i\+Mesh\+\_\+\+Instance}}
\index{i\+Mesh\+\_\+\+Instance@{i\+Mesh\+\_\+\+Instance}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+\+Instance}{iMesh_Instance}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Mesh\+\_\+\+Instance\+\_\+\+Private$\ast$ {\bf i\+Mesh\+\_\+\+Instance}}\hypertarget{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}{}\label{i_mesh_8h_acb65e940120fe27aa9c62210e5a8fad4}


Type used to store i\+Mesh interface handle. 

Type used to store i\+Mesh interface handle 

\subsection{Enumeration Type Documentation}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+Entity\+Topology@{i\+Mesh\+\_\+\+Entity\+Topology}}
\index{i\+Mesh\+\_\+\+Entity\+Topology@{i\+Mesh\+\_\+\+Entity\+Topology}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+\+Entity\+Topology}{iMesh_EntityTopology}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf i\+Mesh\+\_\+\+Entity\+Topology}}\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693}


Enumerator specifying entity topology. 

Enumerator specifying entity topology. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{i\+Mesh\+\_\+\+P\+O\+I\+NT@{i\+Mesh\+\_\+\+P\+O\+I\+NT}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+P\+O\+I\+NT@{i\+Mesh\+\_\+\+P\+O\+I\+NT}}\item[{\em 
i\+Mesh\+\_\+\+P\+O\+I\+NT\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693af7ac92ddaf5a14fa09aaba5f94777102}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693af7ac92ddaf5a14fa09aaba5f94777102}
}]a general zero-\/dimensional entity \index{i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT@{i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT@{i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT}}\item[{\em 
i\+Mesh\+\_\+\+L\+I\+N\+E\+\_\+\+S\+E\+G\+M\+E\+NT\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693afcd1b4f641f4b56b4ccd7b21c1f9d0ff}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693afcd1b4f641f4b56b4ccd7b21c1f9d0ff}
}]a general one-\/dimensional entity \index{i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON@{i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON@{i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON}}\item[{\em 
i\+Mesh\+\_\+\+P\+O\+L\+Y\+G\+ON\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4b86cb245e026e043c2476c93cdde6b4}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4b86cb245e026e043c2476c93cdde6b4}
}]a general two-\/dimensional element \index{i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE@{i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE@{i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE}}\item[{\em 
i\+Mesh\+\_\+\+T\+R\+I\+A\+N\+G\+LE\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a556317b351bacb64961561292a1383f8}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a556317b351bacb64961561292a1383f8}
}]a three-\/sided, two-\/dimensional element \index{i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL@{i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL@{i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL}}\item[{\em 
i\+Mesh\+\_\+\+Q\+U\+A\+D\+R\+I\+L\+A\+T\+E\+R\+AL\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693acf502601729e3e90bf3bc3daee049d0b}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693acf502601729e3e90bf3bc3daee049d0b}
}]a four-\/sided, two-\/dimensional element \index{i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON}}\item[{\em 
i\+Mesh\+\_\+\+P\+O\+L\+Y\+H\+E\+D\+R\+ON\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693ad1d916005ac88bdeec3bd17ffa379711}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693ad1d916005ac88bdeec3bd17ffa379711}
}]a general three-\/dimensional element \index{i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON}}\item[{\em 
i\+Mesh\+\_\+\+T\+E\+T\+R\+A\+H\+E\+D\+R\+ON\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a118bbf2d507021ee7a3f9b437fed2679}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a118bbf2d507021ee7a3f9b437fed2679}
}]a four-\/sided, three-\/dimensional element whose faces are triangles \index{i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON}}\item[{\em 
i\+Mesh\+\_\+\+H\+E\+X\+A\+H\+E\+D\+R\+ON\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a8c0820cf31a15bb8c50310099820d0f1}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a8c0820cf31a15bb8c50310099820d0f1}
}]a six-\/sided, three-\/dimensional element whose faces are quadrilaterals \index{i\+Mesh\+\_\+\+P\+R\+I\+SM@{i\+Mesh\+\_\+\+P\+R\+I\+SM}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+P\+R\+I\+SM@{i\+Mesh\+\_\+\+P\+R\+I\+SM}}\item[{\em 
i\+Mesh\+\_\+\+P\+R\+I\+SM\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a1a8d75aedb371df3819f81423067be43}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a1a8d75aedb371df3819f81423067be43}
}]a five-\/sided, three-\/dimensional element which has three quadrilateral faces and two triangular faces \index{i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID@{i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID@{i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID}}\item[{\em 
i\+Mesh\+\_\+\+P\+Y\+R\+A\+M\+ID\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4ae782c6755761695b56a89312386216}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a4ae782c6755761695b56a89312386216}
}]a five-\/sided, three-\/dimensional element which has one quadrilateral face and four triangular faces \index{i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON@{i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON}}\item[{\em 
i\+Mesh\+\_\+\+S\+E\+P\+T\+A\+H\+E\+D\+R\+ON\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a24c904fb9e4a685372c6649d0567a0db}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693a24c904fb9e4a685372c6649d0567a0db}
}]a hexahedral entity with one collapsed edge \index{i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES@{i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES}!i\+Mesh.\+h@{i\+Mesh.\+h}}\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES@{i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES}}\item[{\em 
i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES\hypertarget{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693aa0c93b5d9f70d468e50e28b09652b6df}{}\label{i_mesh_8h_a5c19aaea9dba32b56786a332ee8b8693aa0c93b5d9f70d468e50e28b09652b6df}
}]allows the user to request information about all the topology types \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set@{i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set}}
\index{i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set@{i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iMesh_addEntArrToSet(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+add\+Ent\+Arr\+To\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a9b706668d662ed50aeb4e1483709c873}{}\label{i_mesh_8h_a9b706668d662ed50aeb4e1483709c873}


Add an array of entities to a set. 

Add an array of entities to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entities being added \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+set} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+add\+Ent\+Set@{i\+Mesh\+\_\+add\+Ent\+Set}}
\index{i\+Mesh\+\_\+add\+Ent\+Set@{i\+Mesh\+\_\+add\+Ent\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+add\+Ent\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+to\+\_\+add, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int $\ast$err)}{iMesh_addEntSet(iMesh_Instance instance, iBase_EntitySetHandle entity_set_to_add, iBase_EntitySetHandle entity_set_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+add\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+to\+\_\+add, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aca90b20d6db5d383b737eb4c3750ba5a}{}\label{i_mesh_8h_aca90b20d6db5d383b737eb4c3750ba5a}


Add an entity set to a set. 

Add an entity set to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+to\+\_\+add} & The entity set being added \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+add\+Ent\+To\+Set@{i\+Mesh\+\_\+add\+Ent\+To\+Set}}
\index{i\+Mesh\+\_\+add\+Ent\+To\+Set@{i\+Mesh\+\_\+add\+Ent\+To\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+add\+Ent\+To\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iMesh_addEntToSet(iMesh_Instance instance, iBase_EntityHandle entity_handle, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+add\+Ent\+To\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a3dfae4b555d968744428e9b21d087440}{}\label{i_mesh_8h_a3dfae4b555d968744428e9b21d087440}


Add an entity to a set. 

Add an entity to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & The entity being added \\
\hline
{\em entity\+\_\+set} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+add\+Prnt\+Chld@{i\+Mesh\+\_\+add\+Prnt\+Chld}}
\index{i\+Mesh\+\_\+add\+Prnt\+Chld@{i\+Mesh\+\_\+add\+Prnt\+Chld}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+add\+Prnt\+Chld(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$err)}{iMesh_addPrntChld(iMesh_Instance instance, iBase_EntitySetHandle parent_entity_set, iBase_EntitySetHandle child_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+add\+Prnt\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7f0fae1a8ebe26e71e3887f5e2aafe32}{}\label{i_mesh_8h_a7f0fae1a8ebe26e71e3887f5e2aafe32}


Add parent/child links between two sets. 

Add parent/child links between two sets. Makes parent point to child and child point to parent. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+are\+E\+H\+Valid@{i\+Mesh\+\_\+are\+E\+H\+Valid}}
\index{i\+Mesh\+\_\+are\+E\+H\+Valid@{i\+Mesh\+\_\+are\+E\+H\+Valid}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+are\+E\+H\+Valid(i\+Mesh\+\_\+\+Instance instance, int do\+Reset, int $\ast$are\+Handles\+Invariant, int $\ast$err)}{iMesh_areEHValid(iMesh_Instance instance, int doReset, int *areHandlesInvariant, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+are\+E\+H\+Valid (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int}]{do\+Reset, }
\item[{int $\ast$}]{are\+Handles\+Invariant, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a37e57041ef15b9ac25b6b2bad3e9f9a0}{}\label{i_mesh_8h_a37e57041ef15b9ac25b6b2bad3e9f9a0}


Return whether entity handles have changed since last reset or since instance construction. 

Return whether entity handles have changed since last reset or since instance construction. If non-\/zero value is returned, it is not guaranteed that a handle from before the last call to this function represents the same entity as the same handle value does now. If do\+Reset is non-\/zero, resets the starting point for this function. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em do\+Reset} & Perform a reset on the starting point after which handles are invariant. \\
\hline
{\em are\+Handles\+Invariant} & Pointer to invariant flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Ent@{i\+Mesh\+\_\+create\+Ent}}
\index{i\+Mesh\+\_\+create\+Ent@{i\+Mesh\+\_\+create\+Ent}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Ent(i\+Mesh\+\_\+\+Instance instance, const int new\+\_\+entity\+\_\+topology, const i\+Base\+\_\+\+Entity\+Handle $\ast$lower\+\_\+order\+\_\+entity\+\_\+handles, const int lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$new\+\_\+entity\+\_\+handle, int $\ast$status, int $\ast$err)}{iMesh_createEnt(iMesh_Instance instance, const int new_entity_topology, const iBase_EntityHandle *lower_order_entity_handles, const int lower_order_entity_handles_size, iBase_EntityHandle *new_entity_handle, int *status, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const int}]{new\+\_\+entity\+\_\+topology, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{lower\+\_\+order\+\_\+entity\+\_\+handles, }
\item[{const int}]{lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{new\+\_\+entity\+\_\+handle, }
\item[{int $\ast$}]{status, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a27772c2a82d0cb1244e3107238f28d7e}{}\label{i_mesh_8h_a27772c2a82d0cb1244e3107238f28d7e}


Create a new entity with specified lower-\/order topology. 

Create a new entity with specified lower-\/order topology. Specified new\+\_\+entity\+\_\+topology must be value in i\+Mesh\+\_\+\+Entity\+Topology enumeration. Value returned as status must be a value in the i\+Base\+\_\+\+Creation\+Status enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em new\+\_\+entity\+\_\+topology} & Topology of created entity \\
\hline
{\em lower\+\_\+order\+\_\+entity\+\_\+handles} & Array of lower order entity handles used to construct new entity \\
\hline
{\em lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size} & Number of entities in array of lower order entity handles \\
\hline
{\em new\+\_\+entity\+\_\+handle} & Pointer to new entity handle returned from function \\
\hline
{\em status} & Pointer to creation status returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Ent\+Arr@{i\+Mesh\+\_\+create\+Ent\+Arr}}
\index{i\+Mesh\+\_\+create\+Ent\+Arr@{i\+Mesh\+\_\+create\+Ent\+Arr}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Ent\+Arr(i\+Mesh\+\_\+\+Instance instance, const int new\+\_\+entity\+\_\+topology, const i\+Base\+\_\+\+Entity\+Handle $\ast$lower\+\_\+order\+\_\+entity\+\_\+handles, const int lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$new\+\_\+entity\+\_\+handles, int $\ast$new\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$new\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$status, int $\ast$status\+\_\+allocated, int $\ast$status\+\_\+size, int $\ast$err)}{iMesh_createEntArr(iMesh_Instance instance, const int new_entity_topology, const iBase_EntityHandle *lower_order_entity_handles, const int lower_order_entity_handles_size, iBase_EntityHandle **new_entity_handles, int *new_entity_handles_allocated, int *new_entity_handles_size, int **status, int *status_allocated, int *status_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Ent\+Arr (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const int}]{new\+\_\+entity\+\_\+topology, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{lower\+\_\+order\+\_\+entity\+\_\+handles, }
\item[{const int}]{lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{new\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{new\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{new\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{status, }
\item[{int $\ast$}]{status\+\_\+allocated, }
\item[{int $\ast$}]{status\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a817380ba91d5fff1fe0e656982f0375e}{}\label{i_mesh_8h_a817380ba91d5fff1fe0e656982f0375e}


Create an array of new entities with specified lower-\/order topology. 

Create an array of new entities with specified lower-\/order topology. Specified new\+\_\+entity\+\_\+topology must be value in i\+Mesh\+\_\+\+Entity\+Topology enumeration. Values return in status array must be values in the i\+Base\+\_\+\+Creation\+Status enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em new\+\_\+entity\+\_\+topology} & Topology of created entity \\
\hline
{\em lower\+\_\+order\+\_\+entity\+\_\+handles} & Array of lower order entity handles used to construct new entities \\
\hline
{\em lower\+\_\+order\+\_\+entity\+\_\+handles\+\_\+size} & Number of entities in array of lower order entity handles \\
\hline
{\em $\ast$new\+\_\+entity\+\_\+handles} & Pointer to array of new\+\_\+entity\+\_\+handles returned from function \\
\hline
{\em $\ast$new\+\_\+entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of new\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$new\+\_\+entity\+\_\+handles\+\_\+size} & Pointer to occupied size of new\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$status} & Pointer to array of creation status returned from function \\
\hline
{\em $\ast$status\+\_\+allocated} & Pointer to allocated size of status array \\
\hline
{\em $\ast$status\+\_\+size} & Pointer to occupied size of status array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Ent\+Set@{i\+Mesh\+\_\+create\+Ent\+Set}}
\index{i\+Mesh\+\_\+create\+Ent\+Set@{i\+Mesh\+\_\+create\+Ent\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Ent\+Set(i\+Mesh\+\_\+\+Instance instance, const int is\+List, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$entity\+\_\+set\+\_\+created, int $\ast$err)}{iMesh_createEntSet(iMesh_Instance instance, const int isList, iBase_EntitySetHandle *entity_set_created, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const int}]{is\+List, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{entity\+\_\+set\+\_\+created, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a5c011a4d7805b8c61aafaa5a121ff7a0}{}\label{i_mesh_8h_a5c011a4d7805b8c61aafaa5a121ff7a0}


Create an entity set. 

Create an entity set, either ordered (is\+List=1) or unordered (is\+List=0). Unordered entity sets can contain a given entity or set only once. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em is\+List} & If non-\/zero, an ordered list is created, otherwise an unordered set is created. \\
\hline
{\em entity\+\_\+set\+\_\+created} & Entity set created by function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Tag@{i\+Mesh\+\_\+create\+Tag}}
\index{i\+Mesh\+\_\+create\+Tag@{i\+Mesh\+\_\+create\+Tag}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Tag(i\+Mesh\+\_\+\+Instance instance, const char $\ast$tag\+\_\+name, const int tag\+\_\+size, const int tag\+\_\+type, i\+Base\+\_\+\+Tag\+Handle $\ast$tag\+\_\+handle, int $\ast$err, const int tag\+\_\+name\+\_\+len)}{iMesh_createTag(iMesh_Instance instance, const char *tag_name, const int tag_size, const int tag_type, iBase_TagHandle *tag_handle, int *err, const int tag_name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const char $\ast$}]{tag\+\_\+name, }
\item[{const int}]{tag\+\_\+size, }
\item[{const int}]{tag\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err, }
\item[{const int}]{tag\+\_\+name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad9968a85ef3ce2ace3e44328595fa288}{}\label{i_mesh_8h_ad9968a85ef3ce2ace3e44328595fa288}


Create a tag with specified name, size, and type. 

Create a tag with specified name, size, and type. Tag size is in units of size of tag\+\_\+type data types. Value input for tag type must be value in i\+Base\+\_\+\+Tag\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+name} & Character string indicating tag name \\
\hline
{\em tag\+\_\+size} & Size of each tag value, in units of number of tag\+\_\+type entities \\
\hline
{\em tag\+\_\+type} & Data type for data stored in this tag \\
\hline
{\em tag\+\_\+handle} & Pointer to tag handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em tag\+\_\+name\+\_\+len} & Length of tag name string \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Vtx@{i\+Mesh\+\_\+create\+Vtx}}
\index{i\+Mesh\+\_\+create\+Vtx@{i\+Mesh\+\_\+create\+Vtx}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Vtx(i\+Mesh\+\_\+\+Instance instance, const double x, const double y, const double z, i\+Base\+\_\+\+Entity\+Handle $\ast$new\+\_\+vertex\+\_\+handle, int $\ast$err)}{iMesh_createVtx(iMesh_Instance instance, const double x, const double y, const double z, iBase_EntityHandle *new_vertex_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Vtx (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const double}]{x, }
\item[{const double}]{y, }
\item[{const double}]{z, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{new\+\_\+vertex\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a28f79a4c8c445804215a751563c26688}{}\label{i_mesh_8h_a28f79a4c8c445804215a751563c26688}


Create a new vertex at specified coordinates. 

Create a new vertex at specified coordinates. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em x} & x coordinate of new vertex \\
\hline
{\em y} & y coordinate of new vertex \\
\hline
{\em z} & z coordinate of new vertex \\
\hline
{\em new\+\_\+vertex\+\_\+handle} & Pointer to new vertex handles returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+create\+Vtx\+Arr@{i\+Mesh\+\_\+create\+Vtx\+Arr}}
\index{i\+Mesh\+\_\+create\+Vtx\+Arr@{i\+Mesh\+\_\+create\+Vtx\+Arr}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+create\+Vtx\+Arr(i\+Mesh\+\_\+\+Instance instance, const int num\+\_\+verts, const int storage\+\_\+order, const double $\ast$new\+\_\+coords, const int new\+\_\+coords\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$new\+\_\+vertex\+\_\+handles, int $\ast$new\+\_\+vertex\+\_\+handles\+\_\+allocated, int $\ast$new\+\_\+vertex\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_createVtxArr(iMesh_Instance instance, const int num_verts, const int storage_order, const double *new_coords, const int new_coords_size, iBase_EntityHandle **new_vertex_handles, int *new_vertex_handles_allocated, int *new_vertex_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+create\+Vtx\+Arr (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const int}]{num\+\_\+verts, }
\item[{const int}]{storage\+\_\+order, }
\item[{const double $\ast$}]{new\+\_\+coords, }
\item[{const int}]{new\+\_\+coords\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{new\+\_\+vertex\+\_\+handles, }
\item[{int $\ast$}]{new\+\_\+vertex\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{new\+\_\+vertex\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a8596670832ac7365496ac586e85a2a11}{}\label{i_mesh_8h_a8596670832ac7365496ac586e85a2a11}


Create an array of new vertices at specified coordinates. 

Create an array of new vertices at specified coordinates. Value of storage\+\_\+order must be either i\+Base\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+V\+ED or i\+Base\+\_\+\+B\+L\+O\+C\+K\+ED. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em num\+\_\+verts} & Number of new vertices to be created \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates in new\+\_\+coords array \\
\hline
{\em new\+\_\+coords} & Array of coordinates of new vertices \\
\hline
{\em new\+\_\+coords\+\_\+size} & Number of coordinates in new\+\_\+coords array, should be 3$\ast$num\+\_\+verts \\
\hline
{\em $\ast$new\+\_\+vertex\+\_\+handles} & Pointer to array of new vertex handles returned from function \\
\hline
{\em $\ast$new\+\_\+vertex\+\_\+handles\+\_\+allocated} & Pointer to allocated size of new\+\_\+vertex\+\_\+handles array \\
\hline
{\em $\ast$new\+\_\+vertex\+\_\+handles\+\_\+size} & Pointer to occupied size of new\+\_\+vertex\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+delete\+Ent@{i\+Mesh\+\_\+delete\+Ent}}
\index{i\+Mesh\+\_\+delete\+Ent@{i\+Mesh\+\_\+delete\+Ent}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+delete\+Ent(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$err)}{iMesh_deleteEnt(iMesh_Instance instance, iBase_EntityHandle entity_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+delete\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a98f1c9d37ee6f7bf0795dda50d3b28f1}{}\label{i_mesh_8h_a98f1c9d37ee6f7bf0795dda50d3b28f1}


Delete specified entity. 

Delete specified entity 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity to be deleted \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+delete\+Ent\+Arr@{i\+Mesh\+\_\+delete\+Ent\+Arr}}
\index{i\+Mesh\+\_\+delete\+Ent\+Arr@{i\+Mesh\+\_\+delete\+Ent\+Arr}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+delete\+Ent\+Arr(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_deleteEntArr(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+delete\+Ent\+Arr (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a9b34843000571f5094298d483a45ed21}{}\label{i_mesh_8h_a9b34843000571f5094298d483a45ed21}


Delete specified entities. 

Delete specified entities 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles to be deleted \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array to be deleted \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+destroy\+Ent\+Set@{i\+Mesh\+\_\+destroy\+Ent\+Set}}
\index{i\+Mesh\+\_\+destroy\+Ent\+Set@{i\+Mesh\+\_\+destroy\+Ent\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+destroy\+Ent\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iMesh_destroyEntSet(iMesh_Instance instance, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+destroy\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a096ca8e137fa3149d303935839e09c94}{}\label{i_mesh_8h_a096ca8e137fa3149d303935839e09c94}


Destroy an entity set. 

Destroy an entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set to be destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+destroy\+Tag@{i\+Mesh\+\_\+destroy\+Tag}}
\index{i\+Mesh\+\_\+destroy\+Tag@{i\+Mesh\+\_\+destroy\+Tag}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+destroy\+Tag(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const int forced, int $\ast$err)}{iMesh_destroyTag(iMesh_Instance instance, iBase_TagHandle tag_handle, const int forced, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+destroy\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const int}]{forced, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a4153a6605adcdc67ef57c7d514388c23}{}\label{i_mesh_8h_a4153a6605adcdc67ef57c7d514388c23}


Destroy a tag. 

Destroy a tag. If forced is non-\/zero and entities still have values set for this tag, tag is deleted anyway and those values disappear, otherwise tag is not deleted. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag to be deleted \\
\hline
{\em forced} & If non-\/zero, delete the tag even if entities have values set for that tag \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+dtor@{i\+Mesh\+\_\+dtor}}
\index{i\+Mesh\+\_\+dtor@{i\+Mesh\+\_\+dtor}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+dtor(i\+Mesh\+\_\+\+Instance instance, int $\ast$err)}{iMesh_dtor(iMesh_Instance instance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+dtor (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7427c404c05781f8d033ed917d075a5c}{}\label{i_mesh_8h_a7427c404c05781f8d033ed917d075a5c}


Destroy an i\+Mesh instance. 

Destroy an i\+Mesh instance 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance to be destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+end\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+end\+Ent\+Arr\+Iter}}
\index{i\+Mesh\+\_\+end\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+end\+Ent\+Arr\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+end\+Ent\+Arr\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Arr\+Iterator ent\+Arr\+\_\+iterator, int $\ast$err)}{iMesh_endEntArrIter(iMesh_Instance instance, iMesh_EntityArrIterator entArr_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+end\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}}]{ent\+Arr\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a13f8cdb1b07e6c43fa92c4a71024d855}{}\label{i_mesh_8h_a13f8cdb1b07e6c43fa92c4a71024d855}


Destroy the specified array iterator. 

Destroy the specified array iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator which gets destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+end\+Ent\+Iter@{i\+Mesh\+\_\+end\+Ent\+Iter}}
\index{i\+Mesh\+\_\+end\+Ent\+Iter@{i\+Mesh\+\_\+end\+Ent\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+end\+Ent\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Iterator entity\+\_\+iterator, int $\ast$err)}{iMesh_endEntIter(iMesh_Instance instance, iMesh_EntityIterator entity_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+end\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Iterator}}]{entity\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a8aca84dd5a7882e98870dcf87f922448}{}\label{i_mesh_8h_a8aca84dd5a7882e98870dcf87f922448}


Destroy the specified iterator. 

Destroy the specified iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator which gets destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Adj\+Ent\+Indices@{i\+Mesh\+\_\+get\+Adj\+Ent\+Indices}}
\index{i\+Mesh\+\_\+get\+Adj\+Ent\+Indices@{i\+Mesh\+\_\+get\+Adj\+Ent\+Indices}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Adj\+Ent\+Indices(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int entity\+\_\+type\+\_\+requestor, int entity\+\_\+topology\+\_\+requestor, int entity\+\_\+type\+\_\+requested, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$adj\+\_\+entity\+\_\+indices, int $\ast$adj\+\_\+entity\+\_\+indices\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+indices\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)}{iMesh_getAdjEntIndices(iMesh_Instance instance, iBase_EntitySetHandle entity_set_handle, int entity_type_requestor, int entity_topology_requestor, int entity_type_requested, iBase_EntityHandle **entity_handles, int *entity_handles_allocated, int *entity_handles_size, iBase_EntityHandle **adj_entity_handles, int *adj_entity_handles_allocated, int *adj_entity_handles_size, int **adj_entity_indices, int *adj_entity_indices_allocated, int *adj_entity_indices_size, int **offset, int *offset_allocated, int *offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Adj\+Ent\+Indices (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int}]{entity\+\_\+type\+\_\+requestor, }
\item[{int}]{entity\+\_\+topology\+\_\+requestor, }
\item[{int}]{entity\+\_\+type\+\_\+requested, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{adj\+\_\+entity\+\_\+indices, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+indices\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+indices\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a79a6fe207698e2b29bbffac7f4a09e49}{}\label{i_mesh_8h_a79a6fe207698e2b29bbffac7f4a09e49}


Get indexed representation of mesh or subset of mesh. 

Given an entity set and optionally a type or topology, return\+:
\begin{DoxyItemize}
\item The entities in the set of the specified type or topology
\item The entities adjacent to those entities with a specified type, as a list of unique handles.
\item For each entity in the first list, the adjacent entities, specified as indices into the second list.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+set\+\_\+handle} & The set of entities from which to query \\
\hline
{\em entity\+\_\+type\+\_\+requestor} & If not i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES, act only on the subset of \textquotesingle{}entity\+\_\+set\+\_\+handle\textquotesingle{} of the specified type. \\
\hline
{\em entity\+\_\+topology\+\_\+requestor} & If not i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES, act only on the subset of \textquotesingle{}entity\+\_\+set\+\_\+handle\textquotesingle{} with the specified topology. \\
\hline
{\em entity\+\_\+type\+\_\+requested} & The type of the adjacent entities to return. \\
\hline
{\em entity\+\_\+handles} & The handles of the (non-\/struct) subset of the entity set indicated by \textquotesingle{}entity\+\_\+set\+\_\+handle\textquotesingle{} and the optional type and topology filtering arguments. \\
\hline
{\em adj\+\_\+entity\+\_\+handles} & The union of the unique entities of type \textquotesingle{}requested\+\_\+entity\+\_\+type\textquotesingle{} adjacent to each entity in \textquotesingle{}entity\+\_\+handles\textquotesingle{}. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em adj\+\_\+entity\+\_\+indices} & For each entity in \textquotesingle{}entity\+\_\+handles\textquotesingle{}, the adjacent entities of type \textquotesingle{}entity\+\_\+type\+\_\+requested\textquotesingle{}, specified as indices into \textquotesingle{}adj\+\_\+entity\+\_\+handles\textquotesingle{}. The values are concatenated into a single array in the order of the entity handles in \textquotesingle{}entity\+\_\+handles\textquotesingle{}. \\
\hline
{\em offset} & For each entity in the corresponding position in \textquotesingle{}entity\+\_\+handles\textquotesingle{}, the position in \textquotesingle{}adj\+\_\+entity\+\_\+indices\textquotesingle{} at which values for that entity are stored. \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Adj\+Table@{i\+Mesh\+\_\+get\+Adj\+Table}}
\index{i\+Mesh\+\_\+get\+Adj\+Table@{i\+Mesh\+\_\+get\+Adj\+Table}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Adj\+Table(i\+Mesh\+\_\+\+Instance instance, int $\ast$$\ast$adjacency\+\_\+table, int $\ast$adjacency\+\_\+table\+\_\+allocated, int $\ast$adjacency\+\_\+table\+\_\+size, int $\ast$err)}{iMesh_getAdjTable(iMesh_Instance instance, int **adjacency_table, int *adjacency_table_allocated, int *adjacency_table_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Adj\+Table (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$$\ast$}]{adjacency\+\_\+table, }
\item[{int $\ast$}]{adjacency\+\_\+table\+\_\+allocated, }
\item[{int $\ast$}]{adjacency\+\_\+table\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7ae5c3416715a80e3d7c3ad4a57bf0fc}{}\label{i_mesh_8h_a7ae5c3416715a80e3d7c3ad4a57bf0fc}


Get the adjacency table for this implementation. 

Get the adjacency table for this implementation. This table is a 4x4 array, with indices 0-\/based, where A(i,j) (i=row, j=column) represents the relative cost of retrieving adjacencies between entities of dimension i to entities of dimension j 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em $\ast$adjacency\+\_\+table} & Pointer to array representing adjacency table returned from function \\
\hline
{\em adjacency\+\_\+table\+\_\+allocated} & Pointer to allocated size of adjacency table \\
\hline
{\em adjacency\+\_\+table\+\_\+size} & Pointer to occupied size of adjacency table \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags@{i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags}}
\index{i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags@{i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getAllEntSetTags(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, iBase_TagHandle **tag_handles, int *tag_handles_allocated, int *tag_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+All\+Ent\+Set\+Tags (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$}]{tag\+\_\+handles, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a11afc42d0a3c066bcace23bf2fb0c3a2}{}\label{i_mesh_8h_a11afc42d0a3c066bcace23bf2fb0c3a2}


Get all the tags associated with a specified entity set. 

Get all the tags associated with a specified entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity being queried \\
\hline
{\em $\ast$tag\+\_\+handles} & Pointer to array of tag\+\_\+handles returned from function \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+allocated} & Pointer to allocated size of tag\+\_\+handles array \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+size} & Pointer to occupied size of tag\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+All\+Tags@{i\+Mesh\+\_\+get\+All\+Tags}}
\index{i\+Mesh\+\_\+get\+All\+Tags@{i\+Mesh\+\_\+get\+All\+Tags}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+All\+Tags(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getAllTags(iMesh_Instance instance, const iBase_EntityHandle entity_handle, iBase_TagHandle **tag_handles, int *tag_handles_allocated, int *tag_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+All\+Tags (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$}]{tag\+\_\+handles, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aa86c4931bb6e006310087074653f7f4d}{}\label{i_mesh_8h_aa86c4931bb6e006310087074653f7f4d}


Get all the tags associated with a specified entity handle. 

Get all the tags associated with a specified entity handle 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em $\ast$tag\+\_\+handles} & Pointer to array of tag\+\_\+handles returned from function \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+allocated} & Pointer to allocated size of tag\+\_\+handles array \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+size} & Pointer to occupied size of tag\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Arr\+Data@{i\+Mesh\+\_\+get\+Arr\+Data}}
\index{i\+Mesh\+\_\+get\+Arr\+Data@{i\+Mesh\+\_\+get\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_getArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, char **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7d0f309db733869e7257cb8fc1401dc5}{}\label{i_mesh_8h_a7d0f309db733869e7257cb8fc1401dc5}


Get tag values of arbitrary type for an array of entities. 

Get tag values of arbitrary type for an array of entities. Tag data is returned as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Chldn@{i\+Mesh\+\_\+get\+Chldn}}
\index{i\+Mesh\+\_\+get\+Chldn@{i\+Mesh\+\_\+get\+Chldn}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Chldn(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle from\+\_\+entity\+\_\+set, const int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getChldn(iMesh_Instance instance, const iBase_EntitySetHandle from_entity_set, const int num_hops, iBase_EntitySetHandle **entity_set_handles, int *entity_set_handles_allocated, int *entity_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Chldn (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{from\+\_\+entity\+\_\+set, }
\item[{const int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{entity\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a2bddf55659efb86437d17f9f04e845fe}{}\label{i_mesh_8h_a2bddf55659efb86437d17f9f04e845fe}


Get the child sets linked from a specified set. 

Get the child sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any child. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em from\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to child set, inclusive of the child set \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles} & Pointer to array of child sets returned from function \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Data@{i\+Mesh\+\_\+get\+Data}}
\index{i\+Mesh\+\_\+get\+Data@{i\+Mesh\+\_\+get\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iMesh_getData(iMesh_Instance instance, const iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, char **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aafe428b3299c2f8f949b6b4b8135f7d3}{}\label{i_mesh_8h_aafe428b3299c2f8f949b6b4b8135f7d3}


Get the value of a tag of arbitrary type on an entity. 

Get the value of a tag of arbitrary type on an entity. Tag data is passed back as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being queried \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+allocated} & Pointer to tag data array allocated size \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+size} & Pointer to tag data array occupied size \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Dbl\+Arr\+Data@{i\+Mesh\+\_\+get\+Dbl\+Arr\+Data}}
\index{i\+Mesh\+\_\+get\+Dbl\+Arr\+Data@{i\+Mesh\+\_\+get\+Dbl\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Dbl\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_getDblArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, double **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Dbl\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ade3868d5cbf2cafd64ed8aa77db278c6}{}\label{i_mesh_8h_ade3868d5cbf2cafd64ed8aa77db278c6}


Get tag values of double type for an array of entities. 

Get tag values of double type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Dbl\+Data@{i\+Mesh\+\_\+get\+Dbl\+Data}}
\index{i\+Mesh\+\_\+get\+Dbl\+Data@{i\+Mesh\+\_\+get\+Dbl\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Dbl\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getDblData(iMesh_Instance instance, const iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, double *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_acae9d3cd0a9d17904cd72385d9e51e7d}{}\label{i_mesh_8h_acae9d3cd0a9d17904cd72385d9e51e7d}


Get the value of a tag of double type on an entity. 

Get the value of a tag of double type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Description@{i\+Mesh\+\_\+get\+Description}}
\index{i\+Mesh\+\_\+get\+Description@{i\+Mesh\+\_\+get\+Description}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Description(i\+Mesh\+\_\+\+Instance instance, char $\ast$descr, int $\ast$err, int descr\+\_\+len)}{iMesh_getDescription(iMesh_Instance instance, char *descr, int *err, int descr_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Description (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{char $\ast$}]{descr, }
\item[{int $\ast$}]{err, }
\item[{int}]{descr\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a2032ff525b201ab75a17741e5aeede0b}{}\label{i_mesh_8h_a2032ff525b201ab75a17741e5aeede0b}


Get a description of the error returned from the last i\+Mesh function. 

Get a description of the error returned from the last i\+Mesh function 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em descr} & Pointer to a character string to be filled with a description of the error from the last i\+Mesh function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em descr\+\_\+len} & Length of the character string pointed to by descr \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Dflt\+Storage@{i\+Mesh\+\_\+get\+Dflt\+Storage}}
\index{i\+Mesh\+\_\+get\+Dflt\+Storage@{i\+Mesh\+\_\+get\+Dflt\+Storage}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Dflt\+Storage(i\+Mesh\+\_\+\+Instance instance, int $\ast$order, int $\ast$err)}{iMesh_getDfltStorage(iMesh_Instance instance, int *order, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Dflt\+Storage (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{order, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_acb9413fa63c18b0ff1dfce4b21956e58}{}\label{i_mesh_8h_acb9413fa63c18b0ff1dfce4b21956e58}


Get the default storage order used by this implementation. 

Get the default storage order used by this implementation. Value returned is a member of the i\+Base\+\_\+\+Storage\+Order enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em order} & Pointer to storage order returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+E\+H\+Arr\+Data@{i\+Mesh\+\_\+get\+E\+H\+Arr\+Data}}
\index{i\+Mesh\+\_\+get\+E\+H\+Arr\+Data@{i\+Mesh\+\_\+get\+E\+H\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+E\+H\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iMesh_getEHArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, iBase_EntityHandle **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+E\+H\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a61c5040e5c4ed2ebcd87928d830c06f2}{}\label{i_mesh_8h_a61c5040e5c4ed2ebcd87928d830c06f2}


Get tag values of entity handle type for an array of entities. 

Get tag values of entity handle type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being returned from function. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+value\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+value\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+E\+H\+Data@{i\+Mesh\+\_\+get\+E\+H\+Data}}
\index{i\+Mesh\+\_\+get\+E\+H\+Data@{i\+Mesh\+\_\+get\+E\+H\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+E\+H\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getEHData(iMesh_Instance instance, const iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, iBase_EntityHandle *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad49ce47881dbefc28fb21998e1ac17b7}{}\label{i_mesh_8h_ad49ce47881dbefc28fb21998e1ac17b7}


Get the value of a tag of entity handle type on an entity. 

Get the value of a tag of entity handle type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent2nd\+Adj@{i\+Mesh\+\_\+get\+Ent2nd\+Adj}}
\index{i\+Mesh\+\_\+get\+Ent2nd\+Adj@{i\+Mesh\+\_\+get\+Ent2nd\+Adj}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent2nd\+Adj(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int bridge\+\_\+entity\+\_\+type, int requested\+\_\+entity\+\_\+type, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adjacent\+\_\+entities, int $\ast$adjacent\+\_\+entities\+\_\+allocated, int $\ast$adjacent\+\_\+entities\+\_\+size, int $\ast$err)}{iMesh_getEnt2ndAdj(iMesh_Instance instance, iBase_EntityHandle entity_handle, int bridge_entity_type, int requested_entity_type, iBase_EntityHandle **adjacent_entities, int *adjacent_entities_allocated, int *adjacent_entities_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent2nd\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int}]{bridge\+\_\+entity\+\_\+type, }
\item[{int}]{requested\+\_\+entity\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adjacent\+\_\+entities, }
\item[{int $\ast$}]{adjacent\+\_\+entities\+\_\+allocated, }
\item[{int $\ast$}]{adjacent\+\_\+entities\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad390b53cb4e74dec0fcefdf6fb3be548}{}\label{i_mesh_8h_ad390b53cb4e74dec0fcefdf6fb3be548}


Get \char`\"{}2nd order\char`\"{} adjacencies to an entity Get \char`\"{}2nd order\char`\"{} adjacencies to an entity, that is, from an entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. 

Note 1\+: If the \char`\"{}bridge\char`\"{} dimension is the same as the \char`\"{}to\char`\"{} dimension or the dimension of the input entity, the output will be empty (and an error code of i\+Base\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+A\+R\+G\+U\+M\+E\+NT returned). This is consistent with the definition of adjacencies and the behavior of i\+Mesh first adjacency calls. Note 2\+: An entity will never be returned as a second adjacency of itself, on the grounds that this is the most likely expectation of applications, and that it is easier for an application to add the original entity to the returned data than to find and remove it.


\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance for this call \\
\hline
{\em entity\+\_\+handle} & Entity from which adjacencies are requested \\
\hline
{\em bridge\+\_\+entity\+\_\+type} & Type of bridge entity for 2nd order adjacencies \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of adjacent entities returned \\
\hline
{\em adjacent\+\_\+entities} & Adjacent entities \\
\hline
{\em adjacent\+\_\+entities\+\_\+allocated} & Allocated size of returned array \\
\hline
{\em adjacent\+\_\+entities\+\_\+size} & Occupied size of returned array \\
\hline
{\em err} & \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Adj@{i\+Mesh\+\_\+get\+Ent\+Adj}}
\index{i\+Mesh\+\_\+get\+Ent\+Adj@{i\+Mesh\+\_\+get\+Ent\+Adj}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Adj(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const int entity\+\_\+type\+\_\+requested, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getEntAdj(iMesh_Instance instance, const iBase_EntityHandle entity_handle, const int entity_type_requested, iBase_EntityHandle **adj_entity_handles, int *adj_entity_handles_allocated, int *adj_entity_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const int}]{entity\+\_\+type\+\_\+requested, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7c9b464b4ea3aa5f73d7662231a6d780}{}\label{i_mesh_8h_a7c9b464b4ea3aa5f73d7662231a6d780}


Get entities of specified type adjacent to an entity. 

Get entities of specified type adjacent to an entity. Specified type must be value in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity handle being queried \\
\hline
{\em entity\+\_\+type\+\_\+requested} & Type of adjacent entities requested \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles} & Pointer to array of adjacent entities returned from function \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of adj\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size} & Pointer to occupied size of adj\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj@{i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj}}
\index{i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj@{i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int bridge\+\_\+entity\+\_\+type, int requested\+\_\+entity\+\_\+type, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)}{iMesh_getEntArr2ndAdj(iMesh_Instance instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int bridge_entity_type, int requested_entity_type, iBase_EntityHandle **adj_entity_handles, int *adj_entity_handles_allocated, int *adj_entity_handles_size, int **offset, int *offset_allocated, int *offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Arr2nd\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{bridge\+\_\+entity\+\_\+type, }
\item[{int}]{requested\+\_\+entity\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a4001293d00b3d08228cf40328bfbbb2a}{}\label{i_mesh_8h_a4001293d00b3d08228cf40328bfbbb2a}


Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities, that is, from each entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. 

Note 1\+: If the \char`\"{}bridge\char`\"{} dimension is the same as the \char`\"{}to\char`\"{} dimension, the output will be empty (and an error code of i\+Base\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+A\+R\+G\+U\+M\+E\+NT returned). If the type of a particular entity matches the \char`\"{}bridge\char`\"{} dimension, there will be no entities returned for that input entity. This is consistent with the definition of adjacencies and the behavior of i\+Mesh first adjacency calls. Note 2\+: An entity will never be returned as a second adjacency of itself, on the grounds that this is the most likely expectation of applications, and that it is easier for an application to add the original entity to the returned data than to find and remove it.


\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance for this call \\
\hline
{\em entity\+\_\+handles} & Entities from which adjacencies are requested \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities whose adjacencies are requested \\
\hline
{\em bridge\+\_\+entity\+\_\+type} & Type of bridge entity for 2nd order adjacencies \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of adjacent entities returned \\
\hline
{\em adj\+\_\+entity\+\_\+handles} & Adjacent entities. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em adj\+\_\+entity\+\_\+handles\+\_\+allocated} & Allocated size of returned array \\
\hline
{\em adj\+\_\+entity\+\_\+handles\+\_\+size} & Occupied size of returned array \\
\hline
{\em offset} & Offset\mbox{[}i\mbox{]} is offset into adj\+\_\+entity\+\_\+handles of 2nd order adjacencies of ith entity in entity\+\_\+handles \\
\hline
{\em offset\+\_\+allocated} & Allocated size of offset array \\
\hline
{\em offset\+\_\+size} & Occupied size of offset array \\
\hline
{\em err} & \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Arr\+Adj@{i\+Mesh\+\_\+get\+Ent\+Arr\+Adj}}
\index{i\+Mesh\+\_\+get\+Ent\+Arr\+Adj@{i\+Mesh\+\_\+get\+Ent\+Arr\+Adj}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Arr\+Adj(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const int entity\+\_\+type\+\_\+requested, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adjacent\+Entity\+Handles, int $\ast$adjacent\+Entity\+Handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)}{iMesh_getEntArrAdj(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const int entity_type_requested, iBase_EntityHandle **adjacentEntityHandles, int *adjacentEntityHandles_allocated, int *adj_entity_handles_size, int **offset, int *offset_allocated, int *offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Arr\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const int}]{entity\+\_\+type\+\_\+requested, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adjacent\+Entity\+Handles, }
\item[{int $\ast$}]{adjacent\+Entity\+Handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a80563216001caf07de7c64481282fed9}{}\label{i_mesh_8h_a80563216001caf07de7c64481282fed9}


Get entities of specified type adjacent to entities. 

Get entities of specified type adjacent to entities. Specified type must be value in the i\+Base\+\_\+\+Entity\+Type enumeration. {\itshape offset(i)} is index of first entity in adjacent\+Entity\+Handles array adjacent to entity\+\_\+handles\mbox{[}i\mbox{]}. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+type\+\_\+requested} & Type of adjacent entities requested \\
\hline
{\em $\ast$adjacent\+Entity\+Handles} & Pointer to array of adjacent\+Entity\+Handles returned from function. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em $\ast$adjacent\+Entity\+Handles\+\_\+allocated} & Pointer to allocated size of adjacent\+Entity\+Handles array \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size} & Pointer to occupied size of adjacent\+Entity\+Handles array \\
\hline
{\em $\ast$offset} & Pointer to array of offsets returned from function \\
\hline
{\em $\ast$offset\+\_\+allocated} & Pointer to allocated size of offset array \\
\hline
{\em $\ast$offset\+\_\+size} & Pointer to occupied size of offset array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Arr\+Topo@{i\+Mesh\+\_\+get\+Ent\+Arr\+Topo}}
\index{i\+Mesh\+\_\+get\+Ent\+Arr\+Topo@{i\+Mesh\+\_\+get\+Ent\+Arr\+Topo}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Arr\+Topo(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$topology, int $\ast$topology\+\_\+allocated, int $\ast$topology\+\_\+size, int $\ast$err)}{iMesh_getEntArrTopo(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, int **topology, int *topology_allocated, int *topology_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Arr\+Topo (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{topology, }
\item[{int $\ast$}]{topology\+\_\+allocated, }
\item[{int $\ast$}]{topology\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a696531f49b668acc59304158fafebe71}{}\label{i_mesh_8h_a696531f49b668acc59304158fafebe71}


Get the entity topology for the specified entities. 

Get the entity topology for the specified entities. Topologies returned are values in the i\+Mesh\+\_\+\+Entity\+Topology enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em $\ast$topology} & Pointer to array of entity topologies returned from function \\
\hline
{\em $\ast$topology\+\_\+allocated} & Pointer to allocated size of topology array \\
\hline
{\em $\ast$topology\+\_\+size} & Pointer to occupied size of topology array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Arr\+Type@{i\+Mesh\+\_\+get\+Ent\+Arr\+Type}}
\index{i\+Mesh\+\_\+get\+Ent\+Arr\+Type@{i\+Mesh\+\_\+get\+Ent\+Arr\+Type}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Arr\+Type(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$type, int $\ast$type\+\_\+allocated, int $\ast$type\+\_\+size, int $\ast$err)}{iMesh_getEntArrType(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, int **type, int *type_allocated, int *type_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Arr\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{type, }
\item[{int $\ast$}]{type\+\_\+allocated, }
\item[{int $\ast$}]{type\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a85d470f5e5d4fef4a39ed17cd5af7f84}{}\label{i_mesh_8h_a85d470f5e5d4fef4a39ed17cd5af7f84}


Get the entity type for the specified entities. 

Get the entity type for the specified entities. Types returned are values in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em $\ast$type} & Pointer to array of types returned from function \\
\hline
{\em $\ast$type\+\_\+allocated} & Pointer to allocated size of type array \\
\hline
{\em $\ast$type\+\_\+size} & Pointer to occupied size of type array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Entities@{i\+Mesh\+\_\+get\+Entities}}
\index{i\+Mesh\+\_\+get\+Entities@{i\+Mesh\+\_\+get\+Entities}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Entities(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int entity\+\_\+type, const int entity\+\_\+topology, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getEntities(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int entity_type, const int entity_topology, iBase_EntityHandle **entity_handles, int *entity_handles_allocated, int *entity_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Entities (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{entity\+\_\+type, }
\item[{const int}]{entity\+\_\+topology, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a64c090fe396ca5a720344ed7cd57717f}{}\label{i_mesh_8h_a64c090fe396ca5a720344ed7cd57717f}


Get entities of specific type and/or topology in set or instance. 

Get entities of specific type and/or topology in set or instance. All entities of a given type or topology are requested by specifying i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES or i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Base\+\_\+\+Entity\+Topology enumeration, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em entity\+\_\+type} & Type of entities being requested \\
\hline
{\em entity\+\_\+topology} & Topology of entities being requested \\
\hline
{\em $\ast$entity\+\_\+handles} & Pointer to array of entity handles returned from function \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Set\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Data}}
\index{i\+Mesh\+\_\+get\+Ent\+Set\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Set\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iMesh_getEntSetData(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const iBase_TagHandle tag_handle, char **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a246fc9ee2305c0b1e2113c4ee7bc1a4c}{}\label{i_mesh_8h_a246fc9ee2305c0b1e2113c4ee7bc1a4c}


Get the value of a tag of arbitrary type on an entity set. 

Get the value of a tag of arbitrary type on an entity set. Tag data is passed back as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being queried \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+allocated} & Pointer to tag data array allocated size \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+size} & Pointer to tag data array occupied size \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data}}
\index{i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getEntSetDblData(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, double *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a8d064cd20d3620758ca5f64ae3511fc5}{}\label{i_mesh_8h_a8d064cd20d3620758ca5f64ae3511fc5}


Get the value of a tag of double type on an entity set. 

Get the value of a tag of double type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data}}
\index{i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getEntSetEHData(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, iBase_EntityHandle *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a4ee01020e3e23e35fcbb99740a331764}{}\label{i_mesh_8h_a4ee01020e3e23e35fcbb99740a331764}


Get the value of a tag of entity handle type on an entity set. 

Get the value of a tag of entity handle type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data}}
\index{i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data@{i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getEntSetIntData(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, int *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a582c3f1fd86ee82d2937cef00facc646}{}\label{i_mesh_8h_a582c3f1fd86ee82d2937cef00facc646}


Get the value of a tag of integer type on an entity set. 

Get the value of a tag of integer type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Sets@{i\+Mesh\+\_\+get\+Ent\+Sets}}
\index{i\+Mesh\+\_\+get\+Ent\+Sets@{i\+Mesh\+\_\+get\+Ent\+Sets}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Sets(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$contained\+\_\+set\+\_\+handles, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getEntSets(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int num_hops, iBase_EntitySetHandle **contained_set_handles, int *contained_set_handles_allocated, int *contained_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Sets (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{contained\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{contained\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{contained\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a29ef0f937b69721dd7974b01e785ba76}{}\label{i_mesh_8h_a29ef0f937b69721dd7974b01e785ba76}


Get the entity sets contained in a set or interface. 

Get the entity sets contained in a set or interface. If a set is input which is not the root set, num\+\_\+hops indicates the maximum number of contained sets from entity\+\_\+set\+\_\+handle to one of the contained sets, inclusive of the contained set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to contained set, inclusive of the contained set \\
\hline
{\em $\ast$contained\+\_\+set\+\_\+handles} & Pointer to array of set handles returned from function \\
\hline
{\em contained\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated length of contained\+\_\+set\+\_\+handles array \\
\hline
{\em contained\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied length of contained\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Topo@{i\+Mesh\+\_\+get\+Ent\+Topo}}
\index{i\+Mesh\+\_\+get\+Ent\+Topo@{i\+Mesh\+\_\+get\+Ent\+Topo}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Topo(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$out\+\_\+topo, int $\ast$err)}{iMesh_getEntTopo(iMesh_Instance instance, const iBase_EntityHandle entity_handle, int *out_topo, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Topo (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+topo, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ae613bc4feff6b416aaf4de5363e4d00b}{}\label{i_mesh_8h_ae613bc4feff6b416aaf4de5363e4d00b}


Get the entity topology for the specified entity. 

Get the entity topology for the specified entity. Topology returned is a value in the i\+Mesh\+\_\+\+Entity\+Topology enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity handle being queried \\
\hline
{\em $\ast$out\+\_\+topo} & Pointer to entity topology returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Ent\+Type@{i\+Mesh\+\_\+get\+Ent\+Type}}
\index{i\+Mesh\+\_\+get\+Ent\+Type@{i\+Mesh\+\_\+get\+Ent\+Type}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Ent\+Type(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$out\+\_\+type, int $\ast$err)}{iMesh_getEntType(iMesh_Instance instance, const iBase_EntityHandle entity_handle, int *out_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Ent\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aef13a6ad1cde578ececa899a44c205c5}{}\label{i_mesh_8h_aef13a6ad1cde578ececa899a44c205c5}


Get the entity type for the specified entity. 

Get the entity type for the specified entity. Type returned is a value in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity handle being queried \\
\hline
{\em $\ast$out\+\_\+type} & Pointer to entity type returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Error\+Type@{i\+Mesh\+\_\+get\+Error\+Type}}
\index{i\+Mesh\+\_\+get\+Error\+Type@{i\+Mesh\+\_\+get\+Error\+Type}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Error\+Type(i\+Mesh\+\_\+\+Instance instance, int $\ast$error\+\_\+type, int $\ast$err)}{iMesh_getErrorType(iMesh_Instance instance, int *error_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Error\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{error\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a6171289cdd1d235080d110b5648bd874}{}\label{i_mesh_8h_a6171289cdd1d235080d110b5648bd874}


Get the error type returned from the last i\+Mesh function. 

Get the error type returned from the last i\+Mesh function. Value returned is a member of the i\+Base\+\_\+\+Error\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em $\ast$error\+\_\+type} & Error type returned from last i\+Mesh function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Geometric\+Dimension@{i\+Mesh\+\_\+get\+Geometric\+Dimension}}
\index{i\+Mesh\+\_\+get\+Geometric\+Dimension@{i\+Mesh\+\_\+get\+Geometric\+Dimension}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Geometric\+Dimension(i\+Mesh\+\_\+\+Instance instance, int $\ast$geom\+\_\+dim, int $\ast$err)}{iMesh_getGeometricDimension(iMesh_Instance instance, int *geom_dim, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Geometric\+Dimension (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{geom\+\_\+dim, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ab7a715d93b00e313cee42b5cc2261c4e}{}\label{i_mesh_8h_ab7a715d93b00e313cee42b5cc2261c4e}


Get the geometric dimension of mesh represented in this instance. 

Get the geometric dimension of mesh represented in this instance 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em geom\+\_\+dim} & Pointer to dimension returned from this function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Int\+Arr\+Data@{i\+Mesh\+\_\+get\+Int\+Arr\+Data}}
\index{i\+Mesh\+\_\+get\+Int\+Arr\+Data@{i\+Mesh\+\_\+get\+Int\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Int\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_getIntArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, int **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Int\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ae11f965b537d25c0ada25e8ddb90e014}{}\label{i_mesh_8h_ae11f965b537d25c0ada25e8ddb90e014}


Get tag values of integer type for an array of entities. 

Get tag values of integer type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Int\+Data@{i\+Mesh\+\_\+get\+Int\+Data}}
\index{i\+Mesh\+\_\+get\+Int\+Data@{i\+Mesh\+\_\+get\+Int\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Int\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)}{iMesh_getIntData(iMesh_Instance instance, const iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, int *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad54d7dd86ac0fddb2559f70998aa44f2}{}\label{i_mesh_8h_ad54d7dd86ac0fddb2559f70998aa44f2}


Get the value of a tag of integer type on an entity. 

Get the value of a tag of integer type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter}}
\index{i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Arr\+Iterator ent\+Arr\+\_\+iterator, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$has\+\_\+data, int $\ast$err)}{iMesh_getNextEntArrIter(iMesh_Instance instance, iMesh_EntityArrIterator entArr_iterator, iBase_EntityHandle **entity_handles, int *entity_handles_allocated, int *entity_handles_size, int *has_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Next\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}}]{ent\+Arr\+\_\+iterator, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{has\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a55cf01def1dcc7e89e0aed1236fc4ca0}{}\label{i_mesh_8h_a55cf01def1dcc7e89e0aed1236fc4ca0}


Get entities contained in array iterator and increment iterator. 

Get the entities corresponding to an array iterator (e.\+g. de-\/reference the array iterator), and increment the iterator. The de-\/referenced value(s) are returned in entity\+\_\+handles. If the iterator is at the end of the iteration, the de-\/referenced value(s) are undefined and has\+\_\+data will be returned with a value of zero. Otherwise, has\+\_\+data will be returned with a non-\/zero value. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator being queried \\
\hline
{\em $\ast$entity\+\_\+handles} & Pointer to array of entity handles contained in current value of iterator \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+handles array \\
\hline
{\em has\+\_\+data} & Pointer to a flag indicating if the value(s) returned in entity\+\_\+handles are valid. A non-\/zero value indicates the value(s) are valid. A zero value indicates the value(s) are N\+OT valid. \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Next\+Ent\+Iter@{i\+Mesh\+\_\+get\+Next\+Ent\+Iter}}
\index{i\+Mesh\+\_\+get\+Next\+Ent\+Iter@{i\+Mesh\+\_\+get\+Next\+Ent\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Next\+Ent\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Iterator entity\+\_\+iterator, i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handle, int $\ast$has\+\_\+data, int $\ast$err)}{iMesh_getNextEntIter(iMesh_Instance instance, iMesh_EntityIterator entity_iterator, iBase_EntityHandle *entity_handle, int *has_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Next\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Iterator}}]{entity\+\_\+iterator, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handle, }
\item[{int $\ast$}]{has\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad0f4390e7048494bb102c08ecf101182}{}\label{i_mesh_8h_ad0f4390e7048494bb102c08ecf101182}


Get entity corresponding to an iterator and increment iterator. 

Get the entity corresponding to an iterator (that is, de-\/reference the iterator), and increment the iterator. The de-\/referenced value is returned in \textquotesingle{}entity\+\_\+handle\textquotesingle{}. If the iterator is at the end of the iteration, the de-\/referenced value will be undefined and \textquotesingle{}has\+\_\+data\textquotesingle{} will have a value of zero. Otherwise, \textquotesingle{}has\+\_\+data\textquotesingle{} will have a non-\/zero value. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator being queried \\
\hline
{\em entity\+\_\+handle} & Pointer to an entity handle corresponding to the current value of iterator just prior to the call. \\
\hline
{\em has\+\_\+data} & Pointer to a flag indicating if the value returned in entity\+\_\+handle is valid. A non-\/zero value indicates the value is valid. A zero value indicates the value is N\+OT valid. \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Num\+Chld@{i\+Mesh\+\_\+get\+Num\+Chld}}
\index{i\+Mesh\+\_\+get\+Num\+Chld@{i\+Mesh\+\_\+get\+Num\+Chld}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Num\+Chld(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const int num\+\_\+hops, int $\ast$num\+\_\+child, int $\ast$err)}{iMesh_getNumChld(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, const int num_hops, int *num_child, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Num\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+child, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ae026ab7bd6910e0061deddbad5824af2}{}\label{i_mesh_8h_ae026ab7bd6910e0061deddbad5824af2}


Get the number of child sets linked from a specified set. 

Get the number of child sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any child in the count. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to child set, inclusive of the child set \\
\hline
{\em num\+\_\+child} & Pointer to number of children returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Num\+Ent\+Sets@{i\+Mesh\+\_\+get\+Num\+Ent\+Sets}}
\index{i\+Mesh\+\_\+get\+Num\+Ent\+Sets@{i\+Mesh\+\_\+get\+Num\+Ent\+Sets}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Num\+Ent\+Sets(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int num\+\_\+hops, int $\ast$num\+\_\+sets, int $\ast$err)}{iMesh_getNumEntSets(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int num_hops, int *num_sets, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Num\+Ent\+Sets (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+sets, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a839d3d49cf96ac8f8a2e39334334f868}{}\label{i_mesh_8h_a839d3d49cf96ac8f8a2e39334334f868}


Get the number of entity sets contained in a set or interface. 

Get the number of entity sets contained in a set or interface. If a set is input which is not the root set, num\+\_\+hops indicates the maximum number of contained sets from entity\+\_\+set\+\_\+handle to one of the contained sets, inclusive of the contained set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to contained set, inclusive of the contained set \\
\hline
{\em num\+\_\+sets} & Pointer to the number of sets returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Num\+Of\+Topo@{i\+Mesh\+\_\+get\+Num\+Of\+Topo}}
\index{i\+Mesh\+\_\+get\+Num\+Of\+Topo@{i\+Mesh\+\_\+get\+Num\+Of\+Topo}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Num\+Of\+Topo(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int entity\+\_\+topology, int $\ast$num\+\_\+topo, int $\ast$err)}{iMesh_getNumOfTopo(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int entity_topology, int *num_topo, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Num\+Of\+Topo (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{entity\+\_\+topology, }
\item[{int $\ast$}]{num\+\_\+topo, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a83ad629a57d165cdd4391ce96c0d3667}{}\label{i_mesh_8h_a83ad629a57d165cdd4391ce96c0d3667}


Get the number of entities with the specified topology in the instance or set. 

Get the number of entities with the specified topology in the instance or set. If entity set handle is root set, return information for instance, otherwise for set. Value of entity topology must be from the i\+Mesh\+\_\+\+Entity\+Topology enumeration. If i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES is specified, total number of entities (excluding entity sets) is returned. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em entity\+\_\+topology} & Topology of entity requested \\
\hline
{\em num\+\_\+topo} & Pointer to number of entities, returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Num\+Of\+Type@{i\+Mesh\+\_\+get\+Num\+Of\+Type}}
\index{i\+Mesh\+\_\+get\+Num\+Of\+Type@{i\+Mesh\+\_\+get\+Num\+Of\+Type}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Num\+Of\+Type(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int entity\+\_\+type, int $\ast$num\+\_\+type, int $\ast$err)}{iMesh_getNumOfType(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int entity_type, int *num_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Num\+Of\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{entity\+\_\+type, }
\item[{int $\ast$}]{num\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad50cf7c272d0266227916e7cbc3a9b98}{}\label{i_mesh_8h_ad50cf7c272d0266227916e7cbc3a9b98}


Get the number of entities with the specified type in the instance or set. 

Get the number of entities with the specified type in the instance or set. If entity set handle is root set, return information for instance, otherwise for set. Value of entity type must be from the i\+Base\+\_\+\+Entity\+Type enumeration. If i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES is specified, total number of entities (excluding entity sets) is returned. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em entity\+\_\+type} & Type of entity requested \\
\hline
{\em num\+\_\+type} & Pointer to number of entities, returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Num\+Prnt@{i\+Mesh\+\_\+get\+Num\+Prnt}}
\index{i\+Mesh\+\_\+get\+Num\+Prnt@{i\+Mesh\+\_\+get\+Num\+Prnt}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Num\+Prnt(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const int num\+\_\+hops, int $\ast$num\+\_\+parent, int $\ast$err)}{iMesh_getNumPrnt(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, const int num_hops, int *num_parent, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Num\+Prnt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+parent, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad95b3ebf036990421d3bccf4705cdd6d}{}\label{i_mesh_8h_ad95b3ebf036990421d3bccf4705cdd6d}


Get the number of parent sets linked from a specified set. 

Get the number of parent sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any parent in the count. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to parent set, inclusive of the parent set \\
\hline
{\em num\+\_\+parent} & Pointer to number of parents returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Prnts@{i\+Mesh\+\_\+get\+Prnts}}
\index{i\+Mesh\+\_\+get\+Prnts@{i\+Mesh\+\_\+get\+Prnts}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Prnts(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle from\+\_\+entity\+\_\+set, const int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iMesh_getPrnts(iMesh_Instance instance, const iBase_EntitySetHandle from_entity_set, const int num_hops, iBase_EntitySetHandle **entity_set_handles, int *entity_set_handles_allocated, int *entity_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Prnts (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{from\+\_\+entity\+\_\+set, }
\item[{const int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{entity\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aae703e9789343cb39f04b373b046a31b}{}\label{i_mesh_8h_aae703e9789343cb39f04b373b046a31b}


Get the parent sets linked from a specified set. 

Get the parent sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any parent. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em from\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to parent set, inclusive of the parent set \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles} & Pointer to array of parent sets returned from function \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Root\+Set@{i\+Mesh\+\_\+get\+Root\+Set}}
\index{i\+Mesh\+\_\+get\+Root\+Set@{i\+Mesh\+\_\+get\+Root\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Root\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$root\+\_\+set, int $\ast$err)}{iMesh_getRootSet(iMesh_Instance instance, iBase_EntitySetHandle *root_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Root\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{root\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_adf856b94c7d790d283256cb98a0dc820}{}\label{i_mesh_8h_adf856b94c7d790d283256cb98a0dc820}


Get handle of the root set for this instance. 

Get handle of the root set for this instance. All mesh in this instance can be accessed from this set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em root\+\_\+set} & Pointer to set handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Tag\+Handle@{i\+Mesh\+\_\+get\+Tag\+Handle}}
\index{i\+Mesh\+\_\+get\+Tag\+Handle@{i\+Mesh\+\_\+get\+Tag\+Handle}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Tag\+Handle(i\+Mesh\+\_\+\+Instance instance, const char $\ast$tag\+\_\+name, i\+Base\+\_\+\+Tag\+Handle $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)}{iMesh_getTagHandle(iMesh_Instance instance, const char *tag_name, iBase_TagHandle *tag_handle, int *err, int tag_name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Tag\+Handle (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const char $\ast$}]{tag\+\_\+name, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err, }
\item[{int}]{tag\+\_\+name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a18189d281e139de4dd4f1c5f8ca160dc}{}\label{i_mesh_8h_a18189d281e139de4dd4f1c5f8ca160dc}


Get a the handle of an existing tag with the specified name. 

Get a the handle of an existing tag with the specified name 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+name} & Name of tag being queried \\
\hline
{\em tag\+\_\+handle} & Pointer to tag handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em tag\+\_\+name\+\_\+len} & Length of tag name string \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Tag\+Name@{i\+Mesh\+\_\+get\+Tag\+Name}}
\index{i\+Mesh\+\_\+get\+Tag\+Name@{i\+Mesh\+\_\+get\+Tag\+Name}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Tag\+Name(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$name, int $\ast$err, int name\+\_\+len)}{iMesh_getTagName(iMesh_Instance instance, const iBase_TagHandle tag_handle, char *name, int *err, int name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Tag\+Name (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$}]{name, }
\item[{int $\ast$}]{err, }
\item[{int}]{name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a2d38d21836b5b34afedf8618fa3ab0b1}{}\label{i_mesh_8h_a2d38d21836b5b34afedf8618fa3ab0b1}


Get the name for a given tag handle. 

Get the name for a given tag handle 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+handle} & Tag handle being queried \\
\hline
{\em name} & Pointer to character string to store name returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of character string input to function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Tag\+Size\+Bytes@{i\+Mesh\+\_\+get\+Tag\+Size\+Bytes}}
\index{i\+Mesh\+\_\+get\+Tag\+Size\+Bytes@{i\+Mesh\+\_\+get\+Tag\+Size\+Bytes}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Tag\+Size\+Bytes(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)}{iMesh_getTagSizeBytes(iMesh_Instance instance, const iBase_TagHandle tag_handle, int *tag_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Tag\+Size\+Bytes (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ac29b077838ecd9cdd108a495b0b3781b}{}\label{i_mesh_8h_ac29b077838ecd9cdd108a495b0b3781b}


Get size of a tag in units of bytes. 

Get size of a tag in units of bytes 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag being queried \\
\hline
{\em tag\+\_\+size} & Pointer to tag size returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Tag\+Size\+Values@{i\+Mesh\+\_\+get\+Tag\+Size\+Values}}
\index{i\+Mesh\+\_\+get\+Tag\+Size\+Values@{i\+Mesh\+\_\+get\+Tag\+Size\+Values}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Tag\+Size\+Values(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)}{iMesh_getTagSizeValues(iMesh_Instance instance, const iBase_TagHandle tag_handle, int *tag_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Tag\+Size\+Values (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad27ce96f257e893acf217a4cd4c0ff1a}{}\label{i_mesh_8h_ad27ce96f257e893acf217a4cd4c0ff1a}


Get size of a tag in units of numbers of tag data type. 

Get size of a tag in units of numbers of tag data type 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag being queried \\
\hline
{\em tag\+\_\+size} & Pointer to tag size returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Tag\+Type@{i\+Mesh\+\_\+get\+Tag\+Type}}
\index{i\+Mesh\+\_\+get\+Tag\+Type@{i\+Mesh\+\_\+get\+Tag\+Type}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Tag\+Type(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+type, int $\ast$err)}{iMesh_getTagType(iMesh_Instance instance, const iBase_TagHandle tag_handle, int *tag_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Tag\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ab27f8cd8b38e386ccb14475384db9daf}{}\label{i_mesh_8h_ab27f8cd8b38e386ccb14475384db9daf}


Get the data type of the specified tag handle. 

Get the data type of the specified tag handle. Tag type is a value in the i\+Base\+\_\+\+Tag\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em tag\+\_\+handle} & Handle for the tag being queried \\
\hline
{\em tag\+\_\+type} & Pointer to tag type returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords@{i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords}}
\index{i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords@{i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$vertex\+\_\+handles, const int vertex\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$coords, int $\ast$coords\+\_\+allocated, int $\ast$coords\+\_\+size, int $\ast$err)}{iMesh_getVtxArrCoords(iMesh_Instance instance, const iBase_EntityHandle *vertex_handles, const int vertex_handles_size, int storage_order, double **coords, int *coords_allocated, int *coords_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Vtx\+Arr\+Coords (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{vertex\+\_\+handles, }
\item[{const int}]{vertex\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{coords, }
\item[{int $\ast$}]{coords\+\_\+allocated, }
\item[{int $\ast$}]{coords\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_abd07e5b0e3f08eef8b87a2ca78998b71}{}\label{i_mesh_8h_abd07e5b0e3f08eef8b87a2ca78998b71}


Get coordinates of specified vertices. 

Get coordinates of specified vertices. Coordinates are returned in the storage order indicated by the storage\+\_\+order argument. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em vertex\+\_\+handles} & Array of mesh vertex handles whose coordinates are being requested \\
\hline
{\em vertex\+\_\+handles\+\_\+size} & Number of vertices in vertex\+\_\+handles array \\
\hline
{\em storage\+\_\+order} & Requested storage order of returned coordinates \\
\hline
{\em $\ast$coords} & Pointer to array of coordinates returned from function \\
\hline
{\em $\ast$coords\+\_\+allocated} & Pointer to allocated size of coords array \\
\hline
{\em $\ast$coords\+\_\+size} & Pointer to occupied size of coords array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+get\+Vtx\+Coord@{i\+Mesh\+\_\+get\+Vtx\+Coord}}
\index{i\+Mesh\+\_\+get\+Vtx\+Coord@{i\+Mesh\+\_\+get\+Vtx\+Coord}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+get\+Vtx\+Coord(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle vertex\+\_\+handle, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)}{iMesh_getVtxCoord(iMesh_Instance instance, const iBase_EntityHandle vertex_handle, double *x, double *y, double *z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+get\+Vtx\+Coord (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex\+\_\+handle, }
\item[{double $\ast$}]{x, }
\item[{double $\ast$}]{y, }
\item[{double $\ast$}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ae432d0985a52f15272058821c33e970e}{}\label{i_mesh_8h_ae432d0985a52f15272058821c33e970e}


Get coordinates of specified vertex. 

Get coordinates of specified vertex. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em vertex\+\_\+handle} & Mesh vertex being queried \\
\hline
{\em $\ast$x} & Pointer to x coordinate returned from function \\
\hline
{\em $\ast$y} & Pointer to y coordinate returned from function \\
\hline
{\em $\ast$z} & Pointer to z coordinate returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+init\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+init\+Ent\+Arr\+Iter}}
\index{i\+Mesh\+\_\+init\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+init\+Ent\+Arr\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+init\+Ent\+Arr\+Iter(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int requested\+\_\+entity\+\_\+type, const int requested\+\_\+entity\+\_\+topology, const int requested\+\_\+array\+\_\+size, i\+Mesh\+\_\+\+Entity\+Arr\+Iterator $\ast$ent\+Arr\+\_\+iterator, int $\ast$err)}{iMesh_initEntArrIter(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int requested_entity_type, const int requested_entity_topology, const int requested_array_size, iMesh_EntityArrIterator *entArr_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+init\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{requested\+\_\+entity\+\_\+type, }
\item[{const int}]{requested\+\_\+entity\+\_\+topology, }
\item[{const int}]{requested\+\_\+array\+\_\+size, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Arr\+Iterator} $\ast$}]{ent\+Arr\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ada98301d3d9aa31d407f6f340987b72b}{}\label{i_mesh_8h_ada98301d3d9aa31d407f6f340987b72b}


Initialize an array iterator over specified entity type, topology, and size. 

Initialize an array iterator over specified entity type, topology, and size, for a specified set or instance. Iterator returned can be used as input to functions returning entities for the iterator. If all entities of a specified type and/or topology are to be iterated, specify i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES or i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Mesh\+\_\+\+Entity\+Topology enumerations, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being iterated \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of entity to iterate \\
\hline
{\em requested\+\_\+entity\+\_\+topology} & Topology of entity to iterate \\
\hline
{\em requested\+\_\+array\+\_\+size} & Size of chunks of handles returned for each value of the iterator \\
\hline
{\em ent\+Arr\+\_\+iterator} & Pointer to iterator returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+init\+Ent\+Iter@{i\+Mesh\+\_\+init\+Ent\+Iter}}
\index{i\+Mesh\+\_\+init\+Ent\+Iter@{i\+Mesh\+\_\+init\+Ent\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+init\+Ent\+Iter(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const int requested\+\_\+entity\+\_\+type, const int requested\+\_\+entity\+\_\+topology, i\+Mesh\+\_\+\+Entity\+Iterator $\ast$entity\+\_\+iterator, int $\ast$err)}{iMesh_initEntIter(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const int requested_entity_type, const int requested_entity_topology, iMesh_EntityIterator *entity_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+init\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const int}]{requested\+\_\+entity\+\_\+type, }
\item[{const int}]{requested\+\_\+entity\+\_\+topology, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Iterator} $\ast$}]{entity\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_abb811fce5ee4806ecc41e2f90d6daa1c}{}\label{i_mesh_8h_abb811fce5ee4806ecc41e2f90d6daa1c}


Initialize an iterator over specified entity type, topology, and size. 

Initialize an iterator over specified entity type, topology, and size, for a specified set or instance. Iterator returned can be used as input to functions returning the entity for the iterator. If all entities of a specified type and/or topology are to be iterated, specify i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES or i\+Mesh\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Mesh\+\_\+\+Entity\+Topology enumerations, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being iterated \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of entity to iterate \\
\hline
{\em requested\+\_\+entity\+\_\+topology} & Topology of entity to iterate \\
\hline
{\em entity\+\_\+iterator} & Pointer to iterator returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+intersect@{i\+Mesh\+\_\+intersect}}
\index{i\+Mesh\+\_\+intersect@{i\+Mesh\+\_\+intersect}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+intersect(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iMesh_intersect(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_1, const iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+intersect (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_af723c3970c6a6c3fbc6e3e682b605959}{}\label{i_mesh_8h_af723c3970c6a6c3fbc6e3e682b605959}


Intersect contents of one entity set with another. 

Intersect contents of one entity set with another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set being intersected with another \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being intersected with another \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+is\+Child\+Of@{i\+Mesh\+\_\+is\+Child\+Of}}
\index{i\+Mesh\+\_\+is\+Child\+Of@{i\+Mesh\+\_\+is\+Child\+Of}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+is\+Child\+Of(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, const i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$is\+\_\+child, int $\ast$err)}{iMesh_isChildOf(iMesh_Instance instance, const iBase_EntitySetHandle parent_entity_set, const iBase_EntitySetHandle child_entity_set, int *is_child, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+is\+Child\+Of (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+child, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a225d1b47fc61a35a2b8c85082883731b}{}\label{i_mesh_8h_a225d1b47fc61a35a2b8c85082883731b}


Return whether two sets are related by parent/child links. 

Return whether two sets are related ($\ast$is\+\_\+child=1) or not ($\ast$is\+\_\+child=0) by parent/child links 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em is\+\_\+child} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+is\+Ent\+Arr\+Contained@{i\+Mesh\+\_\+is\+Ent\+Arr\+Contained}}
\index{i\+Mesh\+\_\+is\+Ent\+Arr\+Contained@{i\+Mesh\+\_\+is\+Ent\+Arr\+Contained}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+is\+Ent\+Arr\+Contained(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+set, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int num\+\_\+entity\+\_\+handles, int $\ast$$\ast$is\+\_\+contained, int $\ast$is\+\_\+contained\+\_\+allocated, int $\ast$is\+\_\+contained\+\_\+size, int $\ast$err)}{iMesh_isEntArrContained(iMesh_Instance instance, iBase_EntitySetHandle containing_set, const iBase_EntityHandle *entity_handles, int num_entity_handles, int **is_contained, int *is_contained_allocated, int *is_contained_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+is\+Ent\+Arr\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{num\+\_\+entity\+\_\+handles, }
\item[{int $\ast$$\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{is\+\_\+contained\+\_\+allocated, }
\item[{int $\ast$}]{is\+\_\+contained\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_af0dec15d1335706e08cd210416ca6b64}{}\label{i_mesh_8h_af0dec15d1335706e08cd210416ca6b64}


Return whether entities are contained in a set. 

Return whether each entity is contained in the set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em entity\+\_\+handles} & List of entities for which to check containment. \\
\hline
{\em is\+\_\+contained} & One value for each input entity, 1 if contained in set, zero otherwise. \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+is\+Ent\+Contained@{i\+Mesh\+\_\+is\+Ent\+Contained}}
\index{i\+Mesh\+\_\+is\+Ent\+Contained@{i\+Mesh\+\_\+is\+Ent\+Contained}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+is\+Ent\+Contained(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Handle contained\+\_\+entity, int $\ast$is\+\_\+contained, int $\ast$err)}{iMesh_isEntContained(iMesh_Instance instance, iBase_EntitySetHandle containing_entity_set, iBase_EntityHandle contained_entity, int *is_contained, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+is\+Ent\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{contained\+\_\+entity, }
\item[{int $\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a3e2b00fa7b0441314c36e59e30d5c039}{}\label{i_mesh_8h_a3e2b00fa7b0441314c36e59e30d5c039}


Return whether an entity is contained in another set. 

Return whether an entity is contained ($\ast$is\+\_\+contained=1) or not contained ($\ast$is\+\_\+contained=0) in another set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em contained\+\_\+entity} & Entity potentially contained in containing\+\_\+entity\+\_\+set \\
\hline
{\em is\+\_\+contained} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+is\+Ent\+Set\+Contained@{i\+Mesh\+\_\+is\+Ent\+Set\+Contained}}
\index{i\+Mesh\+\_\+is\+Ent\+Set\+Contained@{i\+Mesh\+\_\+is\+Ent\+Set\+Contained}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+is\+Ent\+Set\+Contained(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+entity\+\_\+set, const i\+Base\+\_\+\+Entity\+Set\+Handle contained\+\_\+entity\+\_\+set, int $\ast$is\+\_\+contained, int $\ast$err)}{iMesh_isEntSetContained(iMesh_Instance instance, const iBase_EntitySetHandle containing_entity_set, const iBase_EntitySetHandle contained_entity_set, int *is_contained, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+is\+Ent\+Set\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{contained\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a4c2d90242ba253c81a41415315c8c282}{}\label{i_mesh_8h_a4c2d90242ba253c81a41415315c8c282}


Return whether an entity set is contained in another set. 

Return whether a set is contained ($\ast$is\+\_\+contained=1) or not contained ($\ast$is\+\_\+contained=0) in another set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em contained\+\_\+entity\+\_\+set} & Entity set potentially contained in containing\+\_\+entity\+\_\+set \\
\hline
{\em is\+\_\+contained} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+is\+List@{i\+Mesh\+\_\+is\+List}}
\index{i\+Mesh\+\_\+is\+List@{i\+Mesh\+\_\+is\+List}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+is\+List(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$is\+\_\+list, int $\ast$err)}{iMesh_isList(iMesh_Instance instance, const iBase_EntitySetHandle entity_set, int *is_list, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+is\+List (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+list, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aa8dff2f4ba439506c5834010e652f1f4}{}\label{i_mesh_8h_aa8dff2f4ba439506c5834010e652f1f4}


Return whether a specified set is ordered or unordered. 

Return whether a specified set is ordered ($\ast$is\+\_\+list=1) or unordered ($\ast$is\+\_\+list=0) 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em is\+\_\+list} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+load@{i\+Mesh\+\_\+load}}
\index{i\+Mesh\+\_\+load@{i\+Mesh\+\_\+load}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+load(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const char $\ast$name, const char $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)}{iMesh_load(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const char *name, const char *options, int *err, int name_len, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+load (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const char $\ast$}]{name, }
\item[{const char $\ast$}]{options, }
\item[{int $\ast$}]{err, }
\item[{int}]{name\+\_\+len, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ac1afb5d0b8f5a8fbe6747b04c1c58ab6}{}\label{i_mesh_8h_ac1afb5d0b8f5a8fbe6747b04c1c58ab6}


Load a mesh from a file. 

Load a mesh from a file. If entity set is specified, loaded mesh is added to that set; specify root set if that is not desired. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Set to which loaded mesh will be added, root set if not desired \\
\hline
{\em name} & File name from which mesh is to be loaded \\
\hline
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of the file name character string \\
\hline
{\em options\+\_\+len} & Length of the options character string \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+new\+Mesh@{i\+Mesh\+\_\+new\+Mesh}}
\index{i\+Mesh\+\_\+new\+Mesh@{i\+Mesh\+\_\+new\+Mesh}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+new\+Mesh(const char $\ast$options, i\+Mesh\+\_\+\+Instance $\ast$instance, int $\ast$err, int options\+\_\+len)}{iMesh_newMesh(const char *options, iMesh_Instance *instance, int *err, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+new\+Mesh (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{options, }
\item[{{\bf i\+Mesh\+\_\+\+Instance} $\ast$}]{instance, }
\item[{int $\ast$}]{err, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a4cad54751326a7f612d10edef91268d6}{}\label{i_mesh_8h_a4cad54751326a7f612d10edef91268d6}


Construct a new i\+Mesh instance. 

Construct a new i\+Mesh instance, using implementation-\/specific options 
\begin{DoxyParams}{Parameters}
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em instance} & Pointer to i\+Mesh instance handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em options\+\_\+len} & Length of the character string pointed to by options \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter}}
\index{i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter@{i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Arr\+Iterator ent\+Arr\+\_\+iterator, int $\ast$err)}{iMesh_resetEntArrIter(iMesh_Instance instance, iMesh_EntityArrIterator entArr_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+reset\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Arr\+Iterator}}]{ent\+Arr\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a35ee44a4e22992190f2727fbe412adc5}{}\label{i_mesh_8h_a35ee44a4e22992190f2727fbe412adc5}


Reset the array iterator. 

Reset the array iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator to reset \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+reset\+Ent\+Iter@{i\+Mesh\+\_\+reset\+Ent\+Iter}}
\index{i\+Mesh\+\_\+reset\+Ent\+Iter@{i\+Mesh\+\_\+reset\+Ent\+Iter}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+reset\+Ent\+Iter(i\+Mesh\+\_\+\+Instance instance, i\+Mesh\+\_\+\+Entity\+Iterator entity\+\_\+iterator, int $\ast$err)}{iMesh_resetEntIter(iMesh_Instance instance, iMesh_EntityIterator entity_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+reset\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Mesh\+\_\+\+Entity\+Iterator}}]{entity\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a5ccc67144aae1a0361e5bde1262a1b3f}{}\label{i_mesh_8h_a5ccc67144aae1a0361e5bde1262a1b3f}


Reset the iterator. 

Reset the iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator to reset \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Arr\+Tag@{i\+Mesh\+\_\+rmv\+Arr\+Tag}}
\index{i\+Mesh\+\_\+rmv\+Arr\+Tag@{i\+Mesh\+\_\+rmv\+Arr\+Tag}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Arr\+Tag(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iMesh_rmvArrTag(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Arr\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a37d6d1101cbb4093bc06f3e22fda64ee}{}\label{i_mesh_8h_a37d6d1101cbb4093bc06f3e22fda64ee}


Remove a tag value from an array of entities. 

Remove a tag value from an array of entities 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity from which tag is being removed \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity array \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set@{i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set}}
\index{i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set@{i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iMesh_rmvEntArrFromSet(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Ent\+Arr\+From\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a14ceb1d85e28e22a52f3df0b6e8d938a}{}\label{i_mesh_8h_a14ceb1d85e28e22a52f3df0b6e8d938a}


Remove an array of entities from a set. 

Remove an array of entities from a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entities being remove \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+set} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Ent\+From\+Set@{i\+Mesh\+\_\+rmv\+Ent\+From\+Set}}
\index{i\+Mesh\+\_\+rmv\+Ent\+From\+Set@{i\+Mesh\+\_\+rmv\+Ent\+From\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Ent\+From\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iMesh_rmvEntFromSet(iMesh_Instance instance, iBase_EntityHandle entity_handle, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Ent\+From\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ac00e7cf0fb85976301ae8635e1ef844b}{}\label{i_mesh_8h_ac00e7cf0fb85976301ae8635e1ef844b}


Remove an entity from a set. 

Remove an entity from a set


\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & The entity being removed \\
\hline
{\em entity\+\_\+set} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Ent\+Set@{i\+Mesh\+\_\+rmv\+Ent\+Set}}
\index{i\+Mesh\+\_\+rmv\+Ent\+Set@{i\+Mesh\+\_\+rmv\+Ent\+Set}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Ent\+Set(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+to\+\_\+remove, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int $\ast$err)}{iMesh_rmvEntSet(iMesh_Instance instance, iBase_EntitySetHandle entity_set_to_remove, iBase_EntitySetHandle entity_set_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+to\+\_\+remove, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad6c792d5c60aee48658a7c9299b68b35}{}\label{i_mesh_8h_ad6c792d5c60aee48658a7c9299b68b35}


Remove an entity set from a set. 

Remove an entity set from a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+to\+\_\+remove} & The entity set being removed \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag@{i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag}}
\index{i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag@{i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iMesh_rmvEntSetTag(iMesh_Instance instance, iBase_EntitySetHandle entity_set_handle, const iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Ent\+Set\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a68ca4321313f179470cfc1bcf032a256}{}\label{i_mesh_8h_a68ca4321313f179470cfc1bcf032a256}


Remove a tag value from an entity set. 

Remove a tag value from an entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set from which tag is being removed \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Prnt\+Chld@{i\+Mesh\+\_\+rmv\+Prnt\+Chld}}
\index{i\+Mesh\+\_\+rmv\+Prnt\+Chld@{i\+Mesh\+\_\+rmv\+Prnt\+Chld}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Prnt\+Chld(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$err)}{iMesh_rmvPrntChld(iMesh_Instance instance, iBase_EntitySetHandle parent_entity_set, iBase_EntitySetHandle child_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Prnt\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a974552a248c18b04da2f5d8d27574039}{}\label{i_mesh_8h_a974552a248c18b04da2f5d8d27574039}


Remove parent/child links between two sets. 

Remove parent/child links between two sets. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+rmv\+Tag@{i\+Mesh\+\_\+rmv\+Tag}}
\index{i\+Mesh\+\_\+rmv\+Tag@{i\+Mesh\+\_\+rmv\+Tag}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+rmv\+Tag(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iMesh_rmvTag(iMesh_Instance instance, iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+rmv\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a88c6103c0714a55a7662d81957217293}{}\label{i_mesh_8h_a88c6103c0714a55a7662d81957217293}


Remove a tag value from an entity. 

Remove a tag value from an entity 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity from which tag is being removed \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+save@{i\+Mesh\+\_\+save}}
\index{i\+Mesh\+\_\+save@{i\+Mesh\+\_\+save}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+save(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const char $\ast$name, const char $\ast$options, int $\ast$err, const int name\+\_\+len, int options\+\_\+len)}{iMesh_save(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_handle, const char *name, const char *options, int *err, const int name_len, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+save (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const char $\ast$}]{name, }
\item[{const char $\ast$}]{options, }
\item[{int $\ast$}]{err, }
\item[{const int}]{name\+\_\+len, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aa52f6758cfb4f0bfe002adeb056aef9d}{}\label{i_mesh_8h_aa52f6758cfb4f0bfe002adeb056aef9d}


Save a mesh to a file. 

Save a mesh to a file. If entity set is specified, save only the mesh contained in that set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being saved \\
\hline
{\em name} & File name to which mesh is to be saved \\
\hline
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of the file name character string \\
\hline
{\em options\+\_\+len} & Length of the options character string \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Arr\+Data@{i\+Mesh\+\_\+set\+Arr\+Data}}
\index{i\+Mesh\+\_\+set\+Arr\+Data@{i\+Mesh\+\_\+set\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_setArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, const char *tag_values, const int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+values, }
\item[{const int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a467fa9fb220e96030947628d379436e9}{}\label{i_mesh_8h_a467fa9fb220e96030947628d379436e9}


Set tag values of arbitrary type on an array of entities. 

Set tag values of arbitrary type on an array of entities. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entity. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Data@{i\+Mesh\+\_\+set\+Data}}
\index{i\+Mesh\+\_\+set\+Data@{i\+Mesh\+\_\+set\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+value, const int tag\+\_\+value\+\_\+size, int $\ast$err)}{iMesh_setData(iMesh_Instance instance, iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, const char *tag_value, const int tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+value, }
\item[{const int}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a3784b0d130a09e20e1abc23865045f29}{}\label{i_mesh_8h_a3784b0d130a09e20e1abc23865045f29}


Set a tag value of arbitrary type on an entity. 

Set a tag value of arbitrary type on an entity. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Pointer to tag data being set on entity \\
\hline
{\em tag\+\_\+value\+\_\+size} & Size in bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Dbl\+Arr\+Data@{i\+Mesh\+\_\+set\+Dbl\+Arr\+Data}}
\index{i\+Mesh\+\_\+set\+Dbl\+Arr\+Data@{i\+Mesh\+\_\+set\+Dbl\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Dbl\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const double $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_setDblArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, const double *tag_values, const int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Dbl\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const double $\ast$}]{tag\+\_\+values, }
\item[{const int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ab1bc50f12d99f4ccd99e59fa30cc8c88}{}\label{i_mesh_8h_ab1bc50f12d99f4ccd99e59fa30cc8c88}


Set tag values of double type on an array of entities. 

Set tag values of double type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of doubles of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Dbl\+Data@{i\+Mesh\+\_\+set\+Dbl\+Data}}
\index{i\+Mesh\+\_\+set\+Dbl\+Data@{i\+Mesh\+\_\+set\+Dbl\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Dbl\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const double tag\+\_\+value, int $\ast$err)}{iMesh_setDblData(iMesh_Instance instance, iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, const double tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const double}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad59a555037d0d9abdd2cfaf2a6d90ddd}{}\label{i_mesh_8h_ad59a555037d0d9abdd2cfaf2a6d90ddd}


Set a tag value of double type on an entity. 

Set a tag value of double type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+E\+H\+Arr\+Data@{i\+Mesh\+\_\+set\+E\+H\+Arr\+Data}}
\index{i\+Mesh\+\_\+set\+E\+H\+Arr\+Data@{i\+Mesh\+\_\+set\+E\+H\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+E\+H\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const i\+Base\+\_\+\+Entity\+Handle $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_setEHArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, const iBase_EntityHandle *tag_values, const int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+E\+H\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{tag\+\_\+values, }
\item[{const int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ad77f0833c9420d9e00b0cff274308931}{}\label{i_mesh_8h_ad77f0833c9420d9e00b0cff274308931}


Set tag values of entity handle type on an array of entities. 

Set tag values of entity handle type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of entity handles of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+E\+H\+Data@{i\+Mesh\+\_\+set\+E\+H\+Data}}
\index{i\+Mesh\+\_\+set\+E\+H\+Data@{i\+Mesh\+\_\+set\+E\+H\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+E\+H\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const i\+Base\+\_\+\+Entity\+Handle tag\+\_\+value, int $\ast$err)}{iMesh_setEHData(iMesh_Instance instance, iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, const iBase_EntityHandle tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ada920950e552c1965f16142ecac1dcad}{}\label{i_mesh_8h_ada920950e552c1965f16142ecac1dcad}


Set a tag value of entity handle type on an entity. 

Set a tag value of entity handle type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Ent\+Set\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Data}}
\index{i\+Mesh\+\_\+set\+Ent\+Set\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Ent\+Set\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+value, const int tag\+\_\+value\+\_\+size, int $\ast$err)}{iMesh_setEntSetData(iMesh_Instance instance, iBase_EntitySetHandle entity_set_handle, const iBase_TagHandle tag_handle, const char *tag_value, const int tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Ent\+Set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+value, }
\item[{const int}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_aa16cbc90f20df85e6f3baf91b40afd3b}{}\label{i_mesh_8h_aa16cbc90f20df85e6f3baf91b40afd3b}


Set a tag value of arbitrary type on an entity set. 

Set a tag value of arbitrary type on an entity set. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Pointer to tag data being set on entity set \\
\hline
{\em tag\+\_\+value\+\_\+size} & Size in bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data}}
\index{i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const double tag\+\_\+value, int $\ast$err)}{iMesh_setEntSetDblData(iMesh_Instance instance, iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, const double tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Ent\+Set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const double}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a68084d46c2d4feb2a4a20682bb2d30ea}{}\label{i_mesh_8h_a68084d46c2d4feb2a4a20682bb2d30ea}


Set a tag value of double type on an entity set. 

Set a tag value of double type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data}}
\index{i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const i\+Base\+\_\+\+Entity\+Handle tag\+\_\+value, int $\ast$err)}{iMesh_setEntSetEHData(iMesh_Instance instance, iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, const iBase_EntityHandle tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Ent\+Set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ac1138feca0800d71fe8b812bf4060004}{}\label{i_mesh_8h_ac1138feca0800d71fe8b812bf4060004}


Set a tag value of entity handle type on an entity set. 

Set a tag value of entity handle type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data}}
\index{i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data@{i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const int tag\+\_\+value, int $\ast$err)}{iMesh_setEntSetIntData(iMesh_Instance instance, iBase_EntitySetHandle entity_set, const iBase_TagHandle tag_handle, const int tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Ent\+Set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const int}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a5ef07cc5e411248bb76fde6a205fca6e}{}\label{i_mesh_8h_a5ef07cc5e411248bb76fde6a205fca6e}


Set a tag value of integer type on an entity set. 

Set a tag value of integer type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Geometric\+Dimension@{i\+Mesh\+\_\+set\+Geometric\+Dimension}}
\index{i\+Mesh\+\_\+set\+Geometric\+Dimension@{i\+Mesh\+\_\+set\+Geometric\+Dimension}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Geometric\+Dimension(i\+Mesh\+\_\+\+Instance instance, int geom\+\_\+dim, int $\ast$err)}{iMesh_setGeometricDimension(iMesh_Instance instance, int geom_dim, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Geometric\+Dimension (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{int}]{geom\+\_\+dim, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_acd82803db0b898c6432521d081c1d15b}{}\label{i_mesh_8h_acd82803db0b898c6432521d081c1d15b}


Set geometric dimension of vertex coordinates. 

Set the geometric dimension of the mesh. Notes\+: An application should not expect this function to succeed unless the mesh database is empty (no vertices created, no files read, etc.) 
\begin{DoxyParams}{Parameters}
{\em instance} & Mesh database from which to request change. \\
\hline
{\em geom\+\_\+dim} & Requested geometric dimension. \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Int\+Arr\+Data@{i\+Mesh\+\_\+set\+Int\+Arr\+Data}}
\index{i\+Mesh\+\_\+set\+Int\+Arr\+Data@{i\+Mesh\+\_\+set\+Int\+Arr\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Int\+Arr\+Data(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, const int entity\+\_\+handles\+\_\+size, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const int $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)}{iMesh_setIntArrData(iMesh_Instance instance, const iBase_EntityHandle *entity_handles, const int entity_handles_size, const iBase_TagHandle tag_handle, const int *tag_values, const int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Int\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{const int}]{entity\+\_\+handles\+\_\+size, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const int $\ast$}]{tag\+\_\+values, }
\item[{const int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a50b7f1a1d4f16f5705cf73f16cb57d3f}{}\label{i_mesh_8h_a50b7f1a1d4f16f5705cf73f16cb57d3f}


Set tag values of integer type on an array of entities. 

Set tag values of integer type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities. Note that the implicit I\+N\+T\+E\+R\+L\+E\+A\+V\+ED storage order rule applies (see section I\+T\+A\+PS Storage Orders) \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of integers of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Int\+Data@{i\+Mesh\+\_\+set\+Int\+Data}}
\index{i\+Mesh\+\_\+set\+Int\+Data@{i\+Mesh\+\_\+set\+Int\+Data}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Int\+Data(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const int tag\+\_\+value, int $\ast$err)}{iMesh_setIntData(iMesh_Instance instance, iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, const int tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const int}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a49eab82549b65ca328bde367bcc14b0f}{}\label{i_mesh_8h_a49eab82549b65ca328bde367bcc14b0f}


Set a tag value of integer type on an entity. 

Set a tag value of integer type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords@{i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords}}
\index{i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords@{i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$vertex\+\_\+handles, const int vertex\+\_\+handles\+\_\+size, const int storage\+\_\+order, const double $\ast$new\+\_\+coords, const int new\+\_\+coords\+\_\+size, int $\ast$err)}{iMesh_setVtxArrCoords(iMesh_Instance instance, const iBase_EntityHandle *vertex_handles, const int vertex_handles_size, const int storage_order, const double *new_coords, const int new_coords_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Vtx\+Arr\+Coords (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{vertex\+\_\+handles, }
\item[{const int}]{vertex\+\_\+handles\+\_\+size, }
\item[{const int}]{storage\+\_\+order, }
\item[{const double $\ast$}]{new\+\_\+coords, }
\item[{const int}]{new\+\_\+coords\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a07da5a094467daf359fa9dfae961865a}{}\label{i_mesh_8h_a07da5a094467daf359fa9dfae961865a}


Set coordinates for an array of vertices. 

Set coordinates for an array of vertices. Specified storage order must be either i\+Base\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+V\+ED or i\+Base\+\_\+\+B\+L\+O\+C\+K\+ED, and indicates order of x, y, and z coordinates in coordinate array. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em vertex\+\_\+handles} & Array of vertex handles \\
\hline
{\em vertex\+\_\+handles\+\_\+size} & Number of vertex handles in array \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates in coordinate array \\
\hline
{\em new\+\_\+coords} & Coordinate array \\
\hline
{\em new\+\_\+coords\+\_\+size} & Size of coordinate array; should be 3$\ast$vertex\+\_\+handles\+\_\+size \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+set\+Vtx\+Coord@{i\+Mesh\+\_\+set\+Vtx\+Coord}}
\index{i\+Mesh\+\_\+set\+Vtx\+Coord@{i\+Mesh\+\_\+set\+Vtx\+Coord}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+set\+Vtx\+Coord(i\+Mesh\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle vertex\+\_\+handle, const double x, const double y, const double z, int $\ast$err)}{iMesh_setVtxCoord(iMesh_Instance instance, iBase_EntityHandle vertex_handle, const double x, const double y, const double z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+set\+Vtx\+Coord (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex\+\_\+handle, }
\item[{const double}]{x, }
\item[{const double}]{y, }
\item[{const double}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a0c96dfb94434cad6c7db29f220144fa9}{}\label{i_mesh_8h_a0c96dfb94434cad6c7db29f220144fa9}


Set coordinates for a vertex. 

Set coordinates for a vertex. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em vertex\+\_\+handle} & vertex handle being set \\
\hline
{\em x} & x coordinate being set \\
\hline
{\em y} & y coordinate being set \\
\hline
{\em z} & z coordinate being set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+subtract@{i\+Mesh\+\_\+subtract}}
\index{i\+Mesh\+\_\+subtract@{i\+Mesh\+\_\+subtract}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+subtract(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iMesh_subtract(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_1, const iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+subtract (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_a7cc3c2fcb7b439ebb5a88469fa17fa8f}{}\label{i_mesh_8h_a7cc3c2fcb7b439ebb5a88469fa17fa8f}


Subtract contents of one entity set from another. 

Subtract contents of one entity set from another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set from which other set is being subtracted \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being subtracted from other set \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Mesh.\+h@{i\+Mesh.\+h}!i\+Mesh\+\_\+unite@{i\+Mesh\+\_\+unite}}
\index{i\+Mesh\+\_\+unite@{i\+Mesh\+\_\+unite}!i\+Mesh.\+h@{i\+Mesh.\+h}}
\subsubsection[{\texorpdfstring{i\+Mesh\+\_\+unite(i\+Mesh\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, const i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iMesh_unite(iMesh_Instance instance, const iBase_EntitySetHandle entity_set_1, const iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Mesh\+\_\+unite (
\begin{DoxyParamCaption}
\item[{{\bf i\+Mesh\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_mesh_8h_ae3ab1deec82f6b9c4fb9104b91866a00}{}\label{i_mesh_8h_ae3ab1deec82f6b9c4fb9104b91866a00}


Unite contents of one entity set with another. 

Unite contents of one entity set with another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set being united with another \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being united with another \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
