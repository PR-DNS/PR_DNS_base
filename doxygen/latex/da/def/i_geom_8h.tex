\hypertarget{i_geom_8h}{}\section{D\+N\+S/src/intfc/i\+Geom.h File Reference}
\label{i_geom_8h}\index{D\+N\+S/src/intfc/i\+Geom.\+h@{D\+N\+S/src/intfc/i\+Geom.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{i_geom_8h_a52588733df76d324cb16d2cc8204c914}{I\+T\+A\+PS}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct i\+Geom\+\_\+\+Instance\+\_\+\+Private $\ast$ \hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}
\begin{DoxyCompactList}\small\item\em Type used to store i\+Geom interface handle. \end{DoxyCompactList}\item 
typedef struct i\+Geom\+\_\+\+Entity\+Iterator\+\_\+\+Private $\ast$ \hyperlink{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{i\+Geom\+\_\+\+Entity\+Iterator}
\begin{DoxyCompactList}\small\item\em Type used to store an iterator returned by i\+Geom. \end{DoxyCompactList}\item 
typedef struct i\+Geom\+\_\+\+Entity\+Arr\+Iterator\+\_\+\+Private $\ast$ \hyperlink{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}
\begin{DoxyCompactList}\small\item\em Type used to store an array iterator returned by i\+Geom. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{i_geom_8h_a738d7ef1b443d48cad1a1c6e588f904d}{i\+Geom\+\_\+get\+Description} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, char $\ast$descr, int $\ast$err, int descr\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get a description of the error returned from the last i\+Geom function. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9b69f9cce1b427c056f936efc6c2a188}{i\+Geom\+\_\+get\+Error\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, int $\ast$error\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the error type returned from the last i\+Geom function. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4e97b6376358c4092534589c94edab5f}{i\+Geom\+\_\+new\+Geom} (char const $\ast$options, \hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} $\ast$instance\+\_\+out, int $\ast$err, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Construct a new i\+Geom instance. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a33a1f4e8f54ce28b6abec5d2e9ca11ef}{i\+Geom\+\_\+dtor} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy an i\+Geom instance. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a5c9095cda17db5d2fef2078f4f52d165}{i\+Geom\+\_\+load} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, char const $\ast$name, char const $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Load a geom from a file. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aeba95fd535821fb99b52a9dca8b9a7ab}{i\+Geom\+\_\+save} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, char const $\ast$name, char const $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)
\begin{DoxyCompactList}\small\item\em Save a geom to a file. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a89bef37833d2bc31c5b5a0a68cc866c4}{i\+Geom\+\_\+get\+Root\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$root\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get handle of the root set for this instance. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abe6978722a9c8a5331e08fc1f3e856cb}{i\+Geom\+\_\+get\+Bound\+Box} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double $\ast$min\+\_\+x, double $\ast$min\+\_\+y, double $\ast$min\+\_\+z, double $\ast$max\+\_\+x, double $\ast$max\+\_\+y, double $\ast$max\+\_\+z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the bounding box of the entire model Get the bounding box of the entire model. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a1cd563e02b32f56e21bde64299a0492c}{i\+Geom\+\_\+get\+Entities} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} set\+\_\+handle, int entity\+\_\+type, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allococated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specific type and/or topology in set or instance. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aa5d08056eec1d9825d6e56988fd52a42}{i\+Geom\+\_\+get\+Num\+Of\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} set\+\_\+handle, int entity\+\_\+type, int $\ast$num\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of entities with the specified type in the instance or set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac339424fe3304b05c2cd57c886880664}{i\+Geom\+\_\+get\+Ent\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity type for the specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ab6c4c21ba5dde53e2972333424fdc257}{i\+Geom\+\_\+get\+Arr\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$type, int $\ast$type\+\_\+allocated, int $\ast$type\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity type for the specified entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_adbc0f5b5136eb18a2824ccae1184b24e}{i\+Geom\+\_\+get\+Ent\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int to\+\_\+dimension, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entities, int $\ast$adj\+\_\+entities\+\_\+allocated, int $\ast$adj\+\_\+entities\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specified type adjacent to an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8754a61b55ae9f452174df77c433c4a4}{i\+Geom\+\_\+get\+Arr\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int requested\+\_\+entity\+\_\+type, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities of specified type adjacent to entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ab8632165533ea43bfd6c4e69aaade6e3}{i\+Geom\+\_\+get\+Ent2nd\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int bridge\+\_\+dimension, int to\+\_\+dimension, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adjacent\+\_\+entities, int $\ast$adjacent\+\_\+entities\+\_\+allocated, int $\ast$adjacent\+\_\+entities\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get \char`\"{}2nd order\char`\"{} adjacencies to an entity Get \char`\"{}2nd order\char`\"{} adjacencies to an entity, that is, from an entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a5fb39281c740fa5a3ef113c63231f1e8}{i\+Geom\+\_\+get\+Arr2nd\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int order\+\_\+adjacent\+\_\+key, int requested\+\_\+entity\+\_\+type, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities, that is, from each entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af31f32348b3752d0fa477ba5159cf32a}{i\+Geom\+\_\+is\+Ent\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle1, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle2, int $\ast$are\+\_\+adjacent, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether two entities are adjacent Return whether two entities are adjacent. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aba8dd7fab5b74ea52e38ef5f296a9ec6}{i\+Geom\+\_\+is\+Arr\+Adj} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles\+\_\+1, int entity\+\_\+handles\+\_\+1\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles\+\_\+2, int entity\+\_\+handles\+\_\+2\+\_\+size, int $\ast$$\ast$is\+\_\+adjacent\+\_\+info, int $\ast$is\+\_\+adjacent\+\_\+info\+\_\+allocated, int $\ast$is\+\_\+adjacent\+\_\+info\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether entity pairs are adjacent Return whether entity pairs are adjacent, i.\+e. if entity\+\_\+handles\+\_\+1\mbox{[}i\mbox{]} is adjacent to entity\+\_\+handles\+\_\+2\mbox{[}i\mbox{]}. This function requires entity\+\_\+handles\+\_\+1\+\_\+size and entity\+\_\+handles\+\_\+2\+\_\+size to be equal. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a89a37345e783eab1d54b288a986cee08}{i\+Geom\+\_\+get\+Topo\+Level} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, int $\ast$topo\+\_\+level\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em D\+ON\textquotesingle{}T K\+N\+OW W\+H\+AT T\+H\+IS F\+U\+N\+C\+T\+I\+ON IS. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7510001cd9212a4e80c58467dd5e6a8d}{i\+Geom\+\_\+get\+Ent\+Closest\+Pt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double near\+\_\+x, double near\+\_\+y, double near\+\_\+z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get closest point to an entity Get closest point to a specified position on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a21b95b9d2bb46c891bd4f48a130007c1}{i\+Geom\+\_\+get\+Arr\+Closest\+Pt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$near\+\_\+coordinates, int near\+\_\+coordinates\+\_\+size, double $\ast$$\ast$on\+\_\+coordinates, int $\ast$on\+\_\+coordinates\+\_\+allocated, int $\ast$on\+\_\+coordinates\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get closest point for an array of entities and points Get closest point for an array of entities and points. If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a17bf7ab2a20eba43ef779ac28bed6522}{i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the normal vector on an entity at the given position Get the normal vector on an entity at the given position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_afc31e7a8db20572c14f688a634c63063}{i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the normal vector on an entity(ies) at given position(s) Get the normal vector on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8326905f53bee45c81e759282ae57791}{i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$pt\+\_\+x, double $\ast$pt\+\_\+y, double $\ast$pt\+\_\+z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the normal vector A\+ND closest point on an entity at given position Get the normal vector A\+ND closest point on an entity at a given position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a548dbec94f87e3aee01dc2b9b1915fc3}{i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$near\+\_\+coordinates, int near\+\_\+coordinates\+\_\+size, double $\ast$$\ast$on\+\_\+coordinates, int $\ast$on\+\_\+coordinates\+\_\+allocated, int $\ast$on\+\_\+coordinates\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the normal vector A\+ND closest point on an entity(ies) at given position(s) Get the normal vector A\+ND closest point on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a496337ad617a6bb60ba4ac7ebc9c0a87}{i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the tangent vector on an entity at given position Get the tangent vector on an entity at a given position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a57fd2149c76d0d56136157c469dba6ca}{i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$tangents, int $\ast$tangents\+\_\+allocated, int $\ast$tangents\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the tangent vector on an entity(ies) at given position(s) Get the tangent vector on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aa83f1ce2ad6dc2115dbaf99c104834d0}{i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, double x, double y, double z, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the two principle curvature vectors for a face at a point Get the two principle curvature vectors for a face at a point. Magnitudes of vectors are curvature, directions are directions of principal curvatures. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a35a5beee2e8f57d2ab198e510aef0fd9}{i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} edge\+\_\+handle, double x, double y, double z, double $\ast$cvtr\+\_\+i, double $\ast$cvtr\+\_\+j, double $\ast$cvtr\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the principle curvature vector for an edge at a point Get the principle curvature vector for an edge at a point. Magnitude of vector is the curvature, direction is direction of principal curvature. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a2edc7c8e243f1c7ec06bc933d411b8ca}{i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$cvtr\+\_\+1, int $\ast$cvtr\+\_\+1\+\_\+allocated, int $\ast$cvtr\+\_\+1\+\_\+size, double $\ast$$\ast$cvtr\+\_\+2, int $\ast$cvtr\+\_\+2\+\_\+allocated, int $\ast$cvtr\+\_\+2\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the curvature(s) on an entity(ies) at given position(s) Get the curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aac2be634a37fd55386cd4f177118c4aa}{i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} edge\+\_\+handle, double x, double y, double z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, double $\ast$cvtr\+\_\+i, double $\ast$cvtr\+\_\+j, double $\ast$cvtr\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get closest point, tangent, and curvature of edge Get closest point, tangent, and curvature of edge. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a395664d89eb83ddead571af4685bfffe}{i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, double x, double y, double z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get closest point, tangent, and curvature of face Get closest point, tangent, and curvature of face. If any of input coordinate pointers are N\+U\+LL, that value is not returned. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9aa5d1c6810ac5c0aab0753189872fe1}{i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, double $\ast$$\ast$\hyperlink{fuserhooks_8c_a0378d0358ee187c39930777ca8bced6a}{tangent}, int $\ast$tangent\+\_\+allocated, int $\ast$tangent\+\_\+size, double $\ast$$\ast$cvtr, int $\ast$cvtr\+\_\+allocated, int $\ast$cvtr\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s) Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac1f47fb66e80dd8f1e15b408bf50f9b2}{i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, double $\ast$$\ast$\hyperlink{fuserhooks_8c_a92beb80674cd0d86b6bcad12c062da8f}{normal}, int $\ast$normal\+\_\+allocated, int $\ast$normal\+\_\+size, double $\ast$$\ast$cvtr1, int $\ast$cvtr1\+\_\+allocated, int $\ast$cvtr1\+\_\+size, double $\ast$$\ast$cvtr2, int $\ast$cvtr2\+\_\+allocated, int $\ast$cvtr2\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s) Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a826d59e82b978a4a552274c3e799790b}{i\+Geom\+\_\+get\+Ent\+Bound\+Box} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double $\ast$min\+\_\+x, double $\ast$min\+\_\+y, double $\ast$min\+\_\+z, double $\ast$max\+\_\+x, double $\ast$max\+\_\+y, double $\ast$max\+\_\+z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the bounding box of the specified entity Get the bounding box of the specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9b7d6633fc8635834d0cbfdb33f4070e}{i\+Geom\+\_\+get\+Arr\+Bound\+Box} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$min\+\_\+corner, int $\ast$min\+\_\+corner\+\_\+allocated, int $\ast$min\+\_\+corner\+\_\+size, double $\ast$$\ast$max\+\_\+corner, int $\ast$max\+\_\+corner\+\_\+allocated, int $\ast$max\+\_\+corner\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the bounding box of the specified entities Get the bounding box of the specified entities. Storage order passed back will be member of i\+Base\+\_\+\+Storage\+Order enum. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a564afd920585388f5d4d28e811b158b6}{i\+Geom\+\_\+get\+Vtx\+Coord} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex\+\_\+handle, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get coordinates of specified vertex. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4b1b83d605611807cd5db7e320b76e1e}{i\+Geom\+\_\+get\+Vtx\+Arr\+Coords} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$coordinates, int $\ast$coordinates\+\_\+allocated, int $\ast$coordinates\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get coordinates of specified vertices. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a594adf2fcf2be835b2cd464eb9f74e8b}{i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double x, double y, double z, double dir\+\_\+x, double dir\+\_\+y, double dir\+\_\+z, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$intersect\+\_\+entity\+\_\+handles, int $\ast$intersect\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$intersect\+\_\+entity\+\_\+hangles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$intersect\+\_\+coords, int $\ast$intersect\+\_\+coords\+\_\+allocated, int $\ast$intersect\+\_\+coords\+\_\+size, double $\ast$$\ast$param\+\_\+coords, int $\ast$param\+\_\+coords\+\_\+allocated, int $\ast$param\+\_\+coords\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Intersect a ray with the model Intersect a ray with the model. Storage orders passed back are members of the i\+Base\+\_\+\+Storage\+Order enumeration; if output is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abaa49e85d29813347ebda7ab8e7e1180}{i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, int storage\+\_\+order, const double $\ast$coords, int coords\+\_\+size, const double $\ast$directions, int directions\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$intersect\+\_\+entity\+\_\+handles, int $\ast$intersect\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$intersect\+\_\+entity\+\_\+hangles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, double $\ast$$\ast$intersect\+\_\+coords, int $\ast$intersect\+\_\+coords\+\_\+allocated, int $\ast$intersect\+\_\+coords\+\_\+size, double $\ast$$\ast$param\+\_\+coords, int $\ast$param\+\_\+coords\+\_\+allocated, int $\ast$param\+\_\+coords\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Intersect an array of rays with the model Intersect an array of rays with the model. Storage orders passed back are members of the i\+Base\+\_\+\+Storage\+Order enumeration; if input/output is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a1431bba42628a16fc414036236393995}{i\+Geom\+\_\+get\+Pnt\+Clsf} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double x, double y, double z, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity on which a point is located Get the entity on which a point is located. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a25786f172fff3a9355b200efb974b71c}{i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entities on which points are located Get the entities on which points are located. Storage orders should be members of the i\+Base\+\_\+\+Storage\+Order enumeration; if input is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac33dcbb6c5f2deee0560cfd729fc40f3}{i\+Geom\+\_\+get\+Ent\+Nrml\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} region, int $\ast$sense\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the sense of a face with respect to a region Get the sense of a face with respect to a region. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that face bounds the region once with each sense. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0ecedf461ab7035ae5fd82f2bad6c840}{i\+Geom\+\_\+get\+Arr\+Nrml\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$region\+\_\+handles, int region\+\_\+handles\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the senses of an array of faces with respect to an array of regions Get the senses of an array of faces with respect to an array of regions. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that face bounds the region once with each sense. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a87e8f0e8da6adda7fbedc6c1c5d831d7}{i\+Geom\+\_\+get\+Eg\+Fc\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} \hyperlink{triangle_8c_d3/d3a/structedge}{edge}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face, int $\ast$sense\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the sense of an edge with respect to a face Get the sense of an edge with respect to a face. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that edge bounds the face once with each sense. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_afcc11d8da6bca1a6717315d4903f3855}{i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the senses of an array of edges with respect to an array of faces Get the senses of an array of edges with respect to an array of faces. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that edge bounds the face once with each sense. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a5b8e67c45ea4ca9ea5371035b3e6e3ff}{i\+Geom\+\_\+get\+Eg\+Vtx\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} \hyperlink{triangle_8c_d3/d3a/structedge}{edge}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex1, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex2, int $\ast$sense\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the sense of a vertex pair with respect to an edge Get the sense of a vertex pair with respect to an edge. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that vertices are identical and that vertex bounds both sides of the edge. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a34aeb1cb4fe4d2a99ea87fd1f5ec5fd9}{i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$vertex\+\_\+handles\+\_\+1, int veretx\+\_\+handles\+\_\+1\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$vertex\+\_\+handles\+\_\+2, int vertex\+\_\+handles\+\_\+2\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the senses of vertex pair with respect to a edges Get the senses of vertex pairs with respect to edges. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that both vertices in pair are identical and that vertex bounds both sides of the edge. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abc0483369e2d2a74cdddd969916331ee}{i\+Geom\+\_\+measure} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$measures, int $\ast$measures\+\_\+allocated, int $\ast$measures\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return the measure (length, area, volume) of entities Return the measure (length, area, volume) of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abe32ef722f5323cd8a2ab5d00dbfaac8}{i\+Geom\+\_\+get\+Face\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, char $\ast$face\+\_\+type, int $\ast$err, int $\ast$face\+\_\+type\+\_\+length)
\begin{DoxyCompactList}\small\item\em Get the geometric type of an entity Get the geometric type of an entity. Specific types depend on implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a1f36b26c5e63ff33c2c4371e88f322a8}{i\+Geom\+\_\+get\+Parametric} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, int $\ast$is\+\_\+parametric, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether interface has information about parameterization Return whether an interface has information about parameterization (!=0) or not (0) \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a53c8448024589d99945fd52c6088e485}{i\+Geom\+\_\+is\+Ent\+Parametric} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$parametric, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether an entity has a parameterization Return whether an entity has a parameterization (!= 0) or not (=0) \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_afb6bb6cd1b9305c164e5e4568aef27fb}{i\+Geom\+\_\+is\+Arr\+Parametric} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$is\+\_\+parametric, int $\ast$is\+\_\+parametric\+\_\+allocated, int $\ast$is\+\_\+parametric\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether entities have parameterizations Return whether entities have parameterizations (!= 0) or not (=0) \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8f3df358020b7155ca51a254c17468d0}{i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double v, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return coordinate position at specified parametric position on entity Return coordinate position at specified parametric position on entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aba86a3e1f8acd10ed3b4ad52b91c4757}{i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$coordinates, int $\ast$coordinates\+\_\+allocated, int $\ast$coordinates\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return coordinate positions at specified parametric position(s) on entity(ies) Return coordinate positions at specified parametric position(s) on entity(ies). If either the number of entities or number of parametric coordinate pairs is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ae04a7477f800d926ea39da9596081dc8}{i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return coordinate position at specified parametric position on entity Return coordinate position at specified parametric position on entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ad781f826b7170abe3c09ac63a99b8d70}{i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double const $\ast$u, int u\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return coordinate positions at specified parametric position(s) on entity(ies) Return coordinate positions at specified parametric position(s) on entity(ies). If either the number of entities or number of parametric coordinate pairs is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ae6ffe88fc59dfc7f740e40bfc679529a}{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$u, double $\ast$v, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric position at specified spatial position on entity Return parametric position at specified spatial position on entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a952c1c56035bfc9d67a456de12369559}{i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$u, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric position at specified spatial position on entity Return parametric position at specified spatial position on entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a886c20be48410ff274c11112f7d777c9}{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric positions at specified spatial position(s) on entity(ies) Return parametric positions at specified spatial position(s) on entity(ies). If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a852abfd9c32604561777f5ca311f2d6a}{i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$u, int $\ast$u\+\_\+allocated, int $\ast$u\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return spatial positions at specified parametric position(s) on entity(ies) Return spatial positions at specified parametric position(s) on entity(ies). If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a379a2ec85f3e0961f8630a7c95819189}{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double x, double y, double z, double $\ast$u, double $\ast$v, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric position at specified spatial position on entity, based on parametric position hint Return parametric position at specified spatial position on entity, based on parametric position hint. For this function, u and v are input with parameters from which to start search. Typically this will reduce the search time for new parametric coordinates. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8452c670e30c0aba846c251f83b8305b}{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric positions at specified spatial position(s) on entity(ies), based on parametric position hints Return parametric positions at specified spatial position(s) on entity(ies), based on parametric position hints. If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4bd3337d7bfea040b518c31797f19842}{i\+Geom\+\_\+get\+Ent\+U\+V\+Range} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double $\ast$u\+\_\+min, double $\ast$v\+\_\+min, double $\ast$u\+\_\+max, double $\ast$v\+\_\+max, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get parametric range of entity Get parametric range of entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9cd1cd2870eb934927323660c7ee64f1}{i\+Geom\+\_\+get\+Ent\+U\+Range} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double $\ast$u\+\_\+min, double $\ast$u\+\_\+max, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get parametric range of entity Get parametric range of entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac4471aa36a64ef27357363ceed873b0d}{i\+Geom\+\_\+get\+Arr\+U\+V\+Range} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv\+\_\+min, int $\ast$uv\+\_\+min\+\_\+allocated, int $\ast$uv\+\_\+min\+\_\+size, double $\ast$$\ast$uv\+\_\+max, int $\ast$uv\+\_\+max\+\_\+allocated, int $\ast$uv\+\_\+max\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get parametric range of entities Get parametric range of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_adafb9f7d543b41b722f46269a290c8e4}{i\+Geom\+\_\+get\+Arr\+U\+Range} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$u\+\_\+min, int $\ast$u\+\_\+min\+\_\+allocated, int $\ast$u\+\_\+min\+\_\+size, double $\ast$$\ast$u\+\_\+max, int $\ast$u\+\_\+max\+\_\+allocated, int $\ast$u\+\_\+max\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get parametric range of entities Get parametric range of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7f5eef6c746f4f4880681a381e8eef6c}{i\+Geom\+\_\+get\+Ent\+Uto\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} edge\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, double in\+\_\+u, double $\ast$u, double $\ast$v, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return the face parametric coordinates for a parametric position on a bounding edge Return the face parametric coordinates for a parametric position on a bounding edge. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7450d4a57c81453c69c5773864c32e64}{i\+Geom\+\_\+get\+Vtx\+To\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, double $\ast$u, double $\ast$v, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric coordinates on face of vertex position Return parametric coordinates on face of vertex position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac499accb8514d8eec221e06a66a767bc}{i\+Geom\+\_\+get\+Vtx\+ToU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} vertex\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} edge\+\_\+handle, double $\ast$u, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric coordinates on edge of vertex position Return parametric coordinates on edge of vertex position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a2ee7bb4b47b7e3e39fc3e6db1e43ddb9}{i\+Geom\+\_\+get\+Arr\+Uto\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, double const $\ast$u\+\_\+in, int u\+\_\+in\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return the face parametric coordinates for a parametric position on bounding edges Return the face parametric coordinates for a parametric position on bounding edges. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a25ae9c486d3abef323435d64df7c03df}{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$vertex\+\_\+handles, int vertex\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric coordinates on faces of vertex positions Return parametric coordinates on faces of vertex positions. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aadbbf3ae57c55f5662a4cb90d25229df}{i\+Geom\+\_\+get\+Vtx\+Arr\+ToU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$vertex\+\_\+handles, int vertex\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, double $\ast$$\ast$u, int $\ast$u\+\_\+allocated, int $\ast$u\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return parametric coordinates on edges of vertex positions Return parametric coordinates on edges of vertex positions. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ae2fc2aa8c509922d230d027bbf88e2b9}{i\+Geom\+\_\+get\+Ent\+Nrml\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double v, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return the normal at a specified parametric position Return the normal at a specified parametric position. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9b49913a17d4ef09b04193c61d5c884d}{i\+Geom\+\_\+get\+Arr\+Nrml\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$parameters, int parameters\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return the normals at a specified parametric positions Return the normals at a specified parametric positions. If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4dd7584d76fca7339150c7a22dace063}{i\+Geom\+\_\+get\+Ent\+TgntU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a10ee890d9a42f23cf764ab923988ce36}{i\+Geom\+\_\+get\+Arr\+TgntU} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$parameters, int parameters\+\_\+size, double $\ast$$\ast$tangents, int $\ast$tangents\+\_\+allocated, int $\ast$tangents\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a1d9e2832dd5a74c8160862ef40881e15}{i\+Geom\+\_\+get\+Ent1st\+Drvt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double v, double $\ast$$\ast$drvt\+\_\+u, int $\ast$drvt\+\_\+u\+\_\+allocated, int $\ast$drvt\+\_\+u\+\_\+size, double $\ast$$\ast$drvt\+\_\+v, int $\ast$dvrt\+\_\+v\+\_\+allocated, int $\ast$dvrt\+\_\+v\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ac3e055066aba483dc8a3765473a791b3}{i\+Geom\+\_\+get\+Arr1st\+Drvt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$dvtr\+\_\+u, int $\ast$dvrt\+\_\+u\+\_\+allocated, int $\ast$dvrt\+\_\+u\+\_\+size, int $\ast$$\ast$u\+\_\+offset, int $\ast$u\+\_\+offset\+\_\+allocated, int $\ast$u\+\_\+offset\+\_\+size, double $\ast$$\ast$dvrt\+\_\+v, int $\ast$dvrt\+\_\+v\+\_\+allocated, int $\ast$dvrt\+\_\+v\+\_\+size, int $\ast$$\ast$v\+\_\+offset, int $\ast$v\+\_\+offset\+\_\+allocated, int $\ast$v\+\_\+offset\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a65b6a3336691d76db5b9e3ae7f49f022}{i\+Geom\+\_\+get\+Ent2nd\+Drvt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double v, double $\ast$$\ast$drvt\+\_\+uu, int $\ast$drvt\+\_\+uu\+\_\+allocated, int $\ast$drvt\+\_\+uu\+\_\+size, double $\ast$$\ast$drvt\+\_\+vv, int $\ast$dvrt\+\_\+vv\+\_\+allocated, int $\ast$dvrt\+\_\+vv\+\_\+size, double $\ast$$\ast$drvt\+\_\+uv, int $\ast$dvrt\+\_\+uv\+\_\+allocated, int $\ast$dvrt\+\_\+uv\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a0dd8c46a52eef0c691f542db4b930cd6}{i\+Geom\+\_\+get\+Arr2nd\+Drvt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$dvtr\+\_\+uu, int $\ast$dvrt\+\_\+uu\+\_\+allocated, int $\ast$dvrt\+\_\+uu\+\_\+size, int $\ast$$\ast$uu\+\_\+offset, int $\ast$uu\+\_\+offset\+\_\+allocated, int $\ast$uu\+\_\+offset\+\_\+size, double $\ast$$\ast$dvtr\+\_\+vv, int $\ast$dvrt\+\_\+vv\+\_\+allocated, int $\ast$dvrt\+\_\+vv\+\_\+size, int $\ast$$\ast$vv\+\_\+offset, int $\ast$vv\+\_\+offset\+\_\+allocated, int $\ast$vv\+\_\+offset\+\_\+size, double $\ast$$\ast$dvrt\+\_\+uv, int $\ast$dvrt\+\_\+uv\+\_\+allocated, int $\ast$dvrt\+\_\+uv\+\_\+size, int $\ast$$\ast$uv\+\_\+offset, int $\ast$uv\+\_\+offset\+\_\+allocated, int $\ast$uv\+\_\+offset\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a82e59cf84e8a88197992d6100ea8cb95}{i\+Geom\+\_\+get\+Fc\+Cvtr\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double u, double v, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_aad26e514e604bef87e2f87c5ae61a7ff}{i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$cvtr\+\_\+1, int $\ast$cvtr\+\_\+1\+\_\+allocated, int $\ast$cvtr\+\_\+1\+\_\+size, double $\ast$$\ast$cvtr\+\_\+2, int $\ast$cvtr\+\_\+2\+\_\+allocated, int $\ast$cvtr\+\_\+2\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a547d0a3d2ca9c4747703ee2c045b12c2}{i\+Geom\+\_\+is\+Ent\+Periodic} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, int $\ast$in\+\_\+u, int $\ast$in\+\_\+v, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a49313c2bc29a099f069b54d8af215858}{i\+Geom\+\_\+is\+Arr\+Periodic} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$in\+\_\+uv, int $\ast$in\+\_\+uv\+\_\+allocated, int $\ast$in\+\_\+uv\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a21276f0da3df35353b42c60b0b53be72}{i\+Geom\+\_\+is\+Fc\+Degenerate} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} face\+\_\+handle, int $\ast$is\+\_\+degenerate, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a3c148ad9e6bf1447e7910b5a7bab3c04}{i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int $\ast$$\ast$degenerate, int $\ast$degenerate\+\_\+allocated, int $\ast$degenerate\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_aaada5f298da6559da46710da32778dad}{i\+Geom\+\_\+get\+Tolerance} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, int $\ast$type, double $\ast$tolerance, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ad63f1408d7cd8de28bcf0041b379276e}{i\+Geom\+\_\+get\+Ent\+Tolerance} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, double $\ast$tolerance, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a35e82ff89851048991d0110a4fee9ca6}{i\+Geom\+\_\+get\+Arr\+Tolerance} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$tolerances, int $\ast$tolerances\+\_\+allocated, int $\ast$tolerances\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a95d57db1f6df20f5f939bf67d334992e}{i\+Geom\+\_\+init\+Ent\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int entity\+\_\+dimension, \hyperlink{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{i\+Geom\+\_\+\+Entity\+Iterator} $\ast$entity\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Initialize an iterator over specified entity type, topology, and size. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_adb6872f5c34b3d90858aac6db72bee50}{i\+Geom\+\_\+init\+Ent\+Arr\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int entity\+\_\+dimension, int requested\+\_\+array\+\_\+size, \hyperlink{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{i\+Geom\+\_\+\+Entity\+Arr\+Iterator} $\ast$ent\+Arr\+\_\+iterator, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Initialize an array iterator over specified entity type, topology, and size. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a03ca40825cbc07436cfc8041be82d135}{i\+Geom\+\_\+get\+Next\+Ent\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{i\+Geom\+\_\+\+Entity\+Iterator}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handle, int $\ast$has\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entity corresponding to an iterator and increment iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aa574aa5f0bcea2996ffbd721e242a36b}{i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$has\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get entities contained in array iterator and increment iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af08614c041248ce944c27fa13dd1bdae}{i\+Geom\+\_\+reset\+Ent\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{i\+Geom\+\_\+\+Entity\+Iterator}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Reset the iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a98bfcb8c45737e0456caca00591f9e52}{i\+Geom\+\_\+reset\+Ent\+Arr\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Reset the array iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aa0f2636b7bb10b36b08c0c7ae0c0aa64}{i\+Geom\+\_\+end\+Ent\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{i\+Geom\+\_\+\+Entity\+Iterator}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy the specified iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4d2c78b79c4ec28347f03cf5f453baeb}{i\+Geom\+\_\+end\+Ent\+Arr\+Iter} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy the specified array iterator. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a67b7e535ce6c2c3c3c7f0317d514f15b}{i\+Geom\+\_\+copy\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} source, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$copy, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a2014ad2bf529f0536c52459e6f5ff634}{i\+Geom\+\_\+sweep\+Ent\+About\+Axis} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double \hyperlink{geomutils_8c_a3b0540d922a851790bae4f7b442cb60b}{angle}, double axis\+\_\+normal\+\_\+x, double axis\+\_\+normal\+\_\+y, double axis\+\_\+normal\+\_\+z, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity2, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a3e2c0e70d2569301e03d1233f4a61b83}{i\+Geom\+\_\+delete\+All} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Delete all entities and sets. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a56ab5a72a8470c43ba171037e7e5b1bc}{i\+Geom\+\_\+delete\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle}, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Delete specified entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a907603552fcbc652b8c760ce579b3672}{i\+Geom\+\_\+create\+Sphere} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double radius, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$sphere\+\_\+handle\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create a sphere centered on the origin. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0e5ccc90e1f2f33eb55c419e31881cd8}{i\+Geom\+\_\+create\+Prism} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double height, int n\+\_\+sides, double major\+\_\+rad, double minor\+\_\+rad, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$prism\+\_\+handle\+\_\+out, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create a prism centered on the origin. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_acf4d82dc2e52a3790820799a44baf9f8}{i\+Geom\+\_\+create\+Brick} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double x, double y, double z, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a098b6846a68cbd7b6b3070ecf0d0da66}{i\+Geom\+\_\+create\+Cylinder} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double height, double major\+\_\+rad, double minor\+\_\+rad, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_acfa73fab78672dc60d29ce246719aebf}{i\+Geom\+\_\+create\+Torus} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, double major\+\_\+rad, double minor\+\_\+rad, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_af350856e8cd2d163ee3de4424df17136}{i\+Geom\+\_\+move\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double x, double y, double z, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ae75e252f951667f300ecf52d083788f9}{i\+Geom\+\_\+rotate\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double \hyperlink{geomutils_8c_a3b0540d922a851790bae4f7b442cb60b}{angle}, double axis\+\_\+normal\+\_\+x, double axis\+\_\+normal\+\_\+y, double axis\+\_\+normal\+\_\+z, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ae4ce65d222cdf9ab06bfe9e791fedc66}{i\+Geom\+\_\+reflect\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double plane\+\_\+normal\+\_\+x, double plane\+\_\+normal\+\_\+y, double plane\+\_\+normal\+\_\+z, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a9743afe399a52a26898e0272b68d1b17}{i\+Geom\+\_\+scale\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double scale\+\_\+x, double scale\+\_\+y, double scale\+\_\+z, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a6eb2310c9849e52a9c97ed9c85211800}{i\+Geom\+\_\+unite\+Ents} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a140eb55491f86b0a35c2b006b9b463e8}{i\+Geom\+\_\+subtract\+Ents} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} blank, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} tool, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ab53628e5a3b2eaad65b0264a8c8e7ff7}{i\+Geom\+\_\+intersect\+Ents} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity2, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity1, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ab660da001afa1fd24cdaabd66859a569}{i\+Geom\+\_\+section\+Ent} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} geom\+\_\+entity, double plane\+\_\+normal\+\_\+x, double plane\+\_\+normal\+\_\+y, double plane\+\_\+normal\+\_\+z, double offset, int reverse, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$geom\+\_\+entity2, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_aa5e42f81ee4e782cae33c02f192ef45b}{i\+Geom\+\_\+imprint\+Ents} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_ad7bc0eae7967f3222326d684a284ac28}{i\+Geom\+\_\+merge\+Ents} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance}, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, double tolerance, int $\ast$err)
\item 
void \hyperlink{i_geom_8h_a3a060f2abb6a9f39c28422258bc161bf}{i\+Geom\+\_\+create\+Ent\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, int is\+List, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$entity\+\_\+set\+\_\+created, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Create an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0cfb421e9ab67819e664558ae45faf6d}{i\+Geom\+\_\+destroy\+Ent\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8606f71754c183a408f9118cf317bc25}{i\+Geom\+\_\+is\+List} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$is\+\_\+list, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether a specified set is ordered or unordered. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a846e6bd490fd8eb64c425a81d909051a}{i\+Geom\+\_\+get\+Num\+Ent\+Sets} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int num\+\_\+hops, int $\ast$num\+\_\+sets, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of entity sets contained in a set or interface. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a09943820467db183cff879e66a11553c}{i\+Geom\+\_\+get\+Ent\+Sets} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$contained\+\_\+set\+\_\+handles, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the entity sets contained in a set or interface. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0e4ef7a7323a6943ab13019892a5ea18}{i\+Geom\+\_\+add\+Ent\+To\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an entity to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a535a2ab95d4a2f7c39b426a38ca908c7}{i\+Geom\+\_\+rmv\+Ent\+From\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an entity from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_adc7407ce1b3f0fab817aea366c5e5066}{i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an array of entities to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac76fb2ff2c27e994551f8c5cbeb3af7a}{i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an array of entities from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8bdd552b4b02cca3d90b770438c5eed7}{i\+Geom\+\_\+add\+Ent\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+to\+\_\+add, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add an entity set to a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af223ff0f80f76b9a3e27098f01f06180}{i\+Geom\+\_\+rmv\+Ent\+Set} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+to\+\_\+remove, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove an entity set from a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a2809c03d33f14c01ef1bab5b43553fc4}{i\+Geom\+\_\+is\+Ent\+Contained} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} contained\+\_\+entity, int $\ast$is\+\_\+contained, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether an entity is contained in another set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a24f08e0b41f4ad876418c75d0f93e6de}{i\+Geom\+\_\+is\+Ent\+Arr\+Contained} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+set, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int num\+\_\+entity\+\_\+handles, int $\ast$$\ast$is\+\_\+contained, int $\ast$is\+\_\+contained\+\_\+allocated, int $\ast$is\+\_\+contained\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether entities are contained in a set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9003d572c32edd3a76225412930ae308}{i\+Geom\+\_\+is\+Ent\+Set\+Contained} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} containing\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} contained\+\_\+entity\+\_\+set, int $\ast$is\+\_\+contained, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether an entity set is contained in another set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_accb81aab4775d77ac42fdcdd1ce6bf89}{i\+Geom\+\_\+add\+Prnt\+Chld} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Add parent/child links between two sets. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aa790d6d187bb9199aa9bd05662ded3dd}{i\+Geom\+\_\+rmv\+Prnt\+Chld} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove parent/child links between two sets. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aef980675b00e378854d4ef9ecf12b113}{i\+Geom\+\_\+is\+Child\+Of} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} parent\+\_\+entity\+\_\+set, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} child\+\_\+entity\+\_\+set, int $\ast$is\+\_\+child, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Return whether two sets are related by parent/child links. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ad1211d552c990e5da37da5345e3b9d85}{i\+Geom\+\_\+get\+Num\+Chld} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int num\+\_\+hops, int $\ast$num\+\_\+child, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of child sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8db5cd217e4d2f2197d2a8740277415c}{i\+Geom\+\_\+get\+Num\+Prnt} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, int num\+\_\+hops, int $\ast$num\+\_\+parent, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the number of parent sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac74f82f4df9c7226f137d47ec2bcb8a2}{i\+Geom\+\_\+get\+Chldn} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} from\+\_\+entity\+\_\+set, int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the child sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a22d57535f64053db711c949dfc5dd673}{i\+Geom\+\_\+get\+Prnts} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} from\+\_\+entity\+\_\+set, int num\+\_\+hops, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the parent sets linked from a specified set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a5f4cea9894ca7984844d1fe4093f589d}{i\+Geom\+\_\+create\+Tag} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const char $\ast$tag\+\_\+name, int tag\+\_\+size, int tag\+\_\+type, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Create a tag with specified name, size, and type. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0a4246c72b176b3bf0e0570aef53d491}{i\+Geom\+\_\+destroy\+Tag} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int forced, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Destroy a tag. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a53f54202145284a6cd137117183bf68e}{i\+Geom\+\_\+get\+Tag\+Name} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$name, int $\ast$err, int name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get the name for a given tag handle. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af909a0968a1386b98611056ea9a66f7f}{i\+Geom\+\_\+get\+Tag\+Size\+Values} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get size of a tag in units of numbers of tag data type. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a9c7ee245bd1124433c4f6f40612d92b7}{i\+Geom\+\_\+get\+Tag\+Size\+Bytes} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get size of a tag in units of bytes. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a62390d1c3fe226e4b3dc8905c831d606}{i\+Geom\+\_\+get\+Tag\+Handle} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const char $\ast$tag\+\_\+name, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)
\begin{DoxyCompactList}\small\item\em Get a the handle of an existing tag with the specified name. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a838dadccb5360f3949a86d43c56c4fcd}{i\+Geom\+\_\+get\+Tag\+Type} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$tag\+\_\+type, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the data type of the specified tag handle. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8be6aaff1f6a5cd80535d68d977f4ac3}{i\+Geom\+\_\+set\+Ent\+Set\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+value, int tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of arbitrary type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4a2a30a2e566371836dd9d0a32bfc3ea}{i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of integer type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abf9d824d0130fc0639069c7e854f3642}{i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of double type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7fb506af597e996e1602723527b0a72e}{i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of entity handle type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af4964d23422c1242d82824ebcf4db9e8}{i\+Geom\+\_\+get\+Ent\+Set\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of arbitrary type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a39e24e464e00976959636378b45a83ca}{i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of integer type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a4e9def652e9d22051b54914b3612cd56}{i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of double type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a6e9d84db3b24e17e297f48f71f02a779}{i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of entity handle type on an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a3f332db7dc8d8b7493c0a36c73278164}{i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get all the tags associated with a specified entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af21c90406724bda3ceb950e16b0eb8f9}{i\+Geom\+\_\+rmv\+Ent\+Set\+Tag} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an entity set. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8f326f5dc161b3c113dd818340fd61f0}{i\+Geom\+\_\+get\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of arbitrary type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ac744d09db82b2762286ee484728cf082}{i\+Geom\+\_\+get\+Int\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of integer type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a027f197cce68791a816c4b2ab27d26b0}{i\+Geom\+\_\+get\+Dbl\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of double type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_af4be8ff6828c1160b8421885b6658ee5}{i\+Geom\+\_\+get\+E\+H\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get tag values of entity handle type for an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aaee91f35ef33a1f24ff1933694dfc189}{i\+Geom\+\_\+set\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of arbitrary type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a78deb26c15dacc4bc2129232ffc73123}{i\+Geom\+\_\+set\+Int\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const int $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of integer type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_aebb343ecd1156c359c276eae890bfe56}{i\+Geom\+\_\+set\+Dbl\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const double $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of double type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a2f46bc65e017978f8eca1814fe3bbfb8}{i\+Geom\+\_\+set\+E\+H\+Arr\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set tag values of entity handle type on an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8f5dbf11e9d377c7eb3dbae2927a590b}{i\+Geom\+\_\+rmv\+Arr\+Tag} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an array of entities. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_ad26f68498573769d51600ebfc8095df3}{i\+Geom\+\_\+get\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of arbitrary type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7c91d075e12506fc0ff00ad812a78242}{i\+Geom\+\_\+get\+Int\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of integer type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_abbcdf6c67a5a21262c2150aaa7fc958d}{i\+Geom\+\_\+get\+Dbl\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, const \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, const \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of double type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a8c9df25475f6787939adf8930d436ed1}{i\+Geom\+\_\+get\+E\+H\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} $\ast$out\+\_\+data, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get the value of a tag of entity handle type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a36e3079e9dfeee2687d2fde863eec8af}{i\+Geom\+\_\+set\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, const char $\ast$tag\+\_\+value, int tag\+\_\+value\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of arbitrary type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a7f580d046ee543ed958a7049e352dad8}{i\+Geom\+\_\+set\+Int\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of integer type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a59aaa169b52e602833cf6f804b54167e}{i\+Geom\+\_\+set\+Dbl\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, double tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of double type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a1e3f0abcdd325ef34ed148081f107b9b}{i\+Geom\+\_\+set\+E\+H\+Data} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} tag\+\_\+value, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Set a tag value of entity handle type on an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a64201715c4e6529741fe8c4a9f5abd90}{i\+Geom\+\_\+get\+All\+Tags} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Get all the tags associated with a specified entity handle. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a6f24a2024048ba51296765ba1129d947}{i\+Geom\+\_\+rmv\+Tag} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_a0a23828dc837370ead1813e9c05752e3}{i\+Base\+\_\+\+Entity\+Handle} entity\+\_\+handle, \hyperlink{i_base_8h_adfd1e2bbc08c6dc44941d8303b25a8e5}{i\+Base\+\_\+\+Tag\+Handle} tag\+\_\+handle, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Remove a tag value from an entity. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a748d2630bbc285fa6d878c615dedce6e}{i\+Geom\+\_\+subtract} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Subtract contents of one entity set from another. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a6c2e51853284c67e302b421ac4e1f863}{i\+Geom\+\_\+intersect} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Intersect contents of one entity set with another. \end{DoxyCompactList}\item 
void \hyperlink{i_geom_8h_a0fa341941b5adc507e5bbdf75e03224a}{i\+Geom\+\_\+unite} (\hyperlink{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{i\+Geom\+\_\+\+Instance} instance, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+1, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} entity\+\_\+set\+\_\+2, \hyperlink{i_base_8h_ac4685c95b3ba606ba3d62fd70ab6d971}{i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)
\begin{DoxyCompactList}\small\item\em Unite contents of one entity set with another. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\index{i\+Geom.\+h@{i\+Geom.\+h}!I\+T\+A\+PS@{I\+T\+A\+PS}}
\index{I\+T\+A\+PS@{I\+T\+A\+PS}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{I\+T\+A\+PS}{ITAPS}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+T\+A\+PS}\hypertarget{i_geom_8h_a52588733df76d324cb16d2cc8204c914}{}\label{i_geom_8h_a52588733df76d324cb16d2cc8204c914}


\subsection{Typedef Documentation}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+\+Entity\+Arr\+Iterator@{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}}
\index{i\+Geom\+\_\+\+Entity\+Arr\+Iterator@{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+\+Entity\+Arr\+Iterator}{iGeom_EntityArrIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Geom\+\_\+\+Entity\+Arr\+Iterator\+\_\+\+Private$\ast$ {\bf i\+Geom\+\_\+\+Entity\+Arr\+Iterator}}\hypertarget{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}{}\label{i_geom_8h_a50952c4dee5dbaf22540b635640d1a1a}


Type used to store an array iterator returned by i\+Geom. 

Type used to store an array iterator returned by i\+Geom \index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+\+Entity\+Iterator@{i\+Geom\+\_\+\+Entity\+Iterator}}
\index{i\+Geom\+\_\+\+Entity\+Iterator@{i\+Geom\+\_\+\+Entity\+Iterator}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+\+Entity\+Iterator}{iGeom_EntityIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Geom\+\_\+\+Entity\+Iterator\+\_\+\+Private$\ast$ {\bf i\+Geom\+\_\+\+Entity\+Iterator}}\hypertarget{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}{}\label{i_geom_8h_a9fa97eb1cb489688c646a2dd16677608}


Type used to store an iterator returned by i\+Geom. 

Type used to store an iterator returned by i\+Geom \index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+\+Instance@{i\+Geom\+\_\+\+Instance}}
\index{i\+Geom\+\_\+\+Instance@{i\+Geom\+\_\+\+Instance}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+\+Instance}{iGeom_Instance}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct i\+Geom\+\_\+\+Instance\+\_\+\+Private$\ast$ {\bf i\+Geom\+\_\+\+Instance}}\hypertarget{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}{}\label{i_geom_8h_a108ea0f63b32b57b7dee5876a91989f8}


Type used to store i\+Geom interface handle. 

Type used to store i\+Geom interface handle 

\subsection{Function Documentation}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set@{i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set}}
\index{i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set@{i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iGeom_addEntArrToSet(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+add\+Ent\+Arr\+To\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_adc7407ce1b3f0fab817aea366c5e5066}{}\label{i_geom_8h_adc7407ce1b3f0fab817aea366c5e5066}


Add an array of entities to a set. 

Add an array of entities to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entities being added \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+set} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+add\+Ent\+Set@{i\+Geom\+\_\+add\+Ent\+Set}}
\index{i\+Geom\+\_\+add\+Ent\+Set@{i\+Geom\+\_\+add\+Ent\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+add\+Ent\+Set(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+to\+\_\+add, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int $\ast$err)}{iGeom_addEntSet(iGeom_Instance instance, iBase_EntitySetHandle entity_set_to_add, iBase_EntitySetHandle entity_set_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+add\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+to\+\_\+add, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8bdd552b4b02cca3d90b770438c5eed7}{}\label{i_geom_8h_a8bdd552b4b02cca3d90b770438c5eed7}


Add an entity set to a set. 

Add an entity set to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+to\+\_\+add} & The entity set being added \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+add\+Ent\+To\+Set@{i\+Geom\+\_\+add\+Ent\+To\+Set}}
\index{i\+Geom\+\_\+add\+Ent\+To\+Set@{i\+Geom\+\_\+add\+Ent\+To\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+add\+Ent\+To\+Set(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iGeom_addEntToSet(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+add\+Ent\+To\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0e4ef7a7323a6943ab13019892a5ea18}{}\label{i_geom_8h_a0e4ef7a7323a6943ab13019892a5ea18}


Add an entity to a set. 

Add an entity to a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & The entity being added \\
\hline
{\em entity\+\_\+set} & Pointer to the set being added to \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+add\+Prnt\+Chld@{i\+Geom\+\_\+add\+Prnt\+Chld}}
\index{i\+Geom\+\_\+add\+Prnt\+Chld@{i\+Geom\+\_\+add\+Prnt\+Chld}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+add\+Prnt\+Chld(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$err)}{iGeom_addPrntChld(iGeom_Instance instance, iBase_EntitySetHandle parent_entity_set, iBase_EntitySetHandle child_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+add\+Prnt\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_accb81aab4775d77ac42fdcdd1ce6bf89}{}\label{i_geom_8h_accb81aab4775d77ac42fdcdd1ce6bf89}


Add parent/child links between two sets. 

Add parent/child links between two sets. Makes parent point to child and child point to parent. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+copy\+Ent@{i\+Geom\+\_\+copy\+Ent}}
\index{i\+Geom\+\_\+copy\+Ent@{i\+Geom\+\_\+copy\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+copy\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle source, i\+Base\+\_\+\+Entity\+Handle $\ast$copy, int $\ast$err)}{iGeom_copyEnt(iGeom_Instance, iBase_EntityHandle source, iBase_EntityHandle *copy, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+copy\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{source, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{copy, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a67b7e535ce6c2c3c3c7f0317d514f15b}{}\label{i_geom_8h_a67b7e535ce6c2c3c3c7f0317d514f15b}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Brick@{i\+Geom\+\_\+create\+Brick}}
\index{i\+Geom\+\_\+create\+Brick@{i\+Geom\+\_\+create\+Brick}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Brick(i\+Geom\+\_\+\+Instance, double x, double y, double z, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_createBrick(iGeom_Instance, double x, double y, double z, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Brick (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_acf4d82dc2e52a3790820799a44baf9f8}{}\label{i_geom_8h_acf4d82dc2e52a3790820799a44baf9f8}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Cylinder@{i\+Geom\+\_\+create\+Cylinder}}
\index{i\+Geom\+\_\+create\+Cylinder@{i\+Geom\+\_\+create\+Cylinder}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Cylinder(i\+Geom\+\_\+\+Instance, double height, double major\+\_\+rad, double minor\+\_\+rad, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_createCylinder(iGeom_Instance, double height, double major_rad, double minor_rad, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Cylinder (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{height, }
\item[{double}]{major\+\_\+rad, }
\item[{double}]{minor\+\_\+rad, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a098b6846a68cbd7b6b3070ecf0d0da66}{}\label{i_geom_8h_a098b6846a68cbd7b6b3070ecf0d0da66}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Ent\+Set@{i\+Geom\+\_\+create\+Ent\+Set}}
\index{i\+Geom\+\_\+create\+Ent\+Set@{i\+Geom\+\_\+create\+Ent\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Ent\+Set(i\+Geom\+\_\+\+Instance instance, int is\+List, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$entity\+\_\+set\+\_\+created, int $\ast$err)}{iGeom_createEntSet(iGeom_Instance instance, int isList, iBase_EntitySetHandle *entity_set_created, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{int}]{is\+List, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{entity\+\_\+set\+\_\+created, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a3a060f2abb6a9f39c28422258bc161bf}{}\label{i_geom_8h_a3a060f2abb6a9f39c28422258bc161bf}


Create an entity set. 

Create an entity set, either ordered (is\+List=1) or unordered (is\+List=0). Unordered entity sets can contain a given entity or set only once. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em is\+List} & If non-\/zero, an ordered list is created, otherwise an unordered set is created. \\
\hline
{\em entity\+\_\+set\+\_\+created} & Entity set created by function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Prism@{i\+Geom\+\_\+create\+Prism}}
\index{i\+Geom\+\_\+create\+Prism@{i\+Geom\+\_\+create\+Prism}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Prism(i\+Geom\+\_\+\+Instance, double height, int n\+\_\+sides, double major\+\_\+rad, double minor\+\_\+rad, i\+Base\+\_\+\+Entity\+Handle $\ast$prism\+\_\+handle\+\_\+out, int $\ast$err)}{iGeom_createPrism(iGeom_Instance, double height, int n_sides, double major_rad, double minor_rad, iBase_EntityHandle *prism_handle_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Prism (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{height, }
\item[{int}]{n\+\_\+sides, }
\item[{double}]{major\+\_\+rad, }
\item[{double}]{minor\+\_\+rad, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{prism\+\_\+handle\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0e5ccc90e1f2f33eb55c419e31881cd8}{}\label{i_geom_8h_a0e5ccc90e1f2f33eb55c419e31881cd8}


Create a prism centered on the origin. 

\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Sphere@{i\+Geom\+\_\+create\+Sphere}}
\index{i\+Geom\+\_\+create\+Sphere@{i\+Geom\+\_\+create\+Sphere}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Sphere(i\+Geom\+\_\+\+Instance, double radius, i\+Base\+\_\+\+Entity\+Handle $\ast$sphere\+\_\+handle\+\_\+out, int $\ast$err)}{iGeom_createSphere(iGeom_Instance, double radius, iBase_EntityHandle *sphere_handle_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Sphere (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{radius, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{sphere\+\_\+handle\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a907603552fcbc652b8c760ce579b3672}{}\label{i_geom_8h_a907603552fcbc652b8c760ce579b3672}


Create a sphere centered on the origin. 

\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Tag@{i\+Geom\+\_\+create\+Tag}}
\index{i\+Geom\+\_\+create\+Tag@{i\+Geom\+\_\+create\+Tag}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Tag(i\+Geom\+\_\+\+Instance instance, const char $\ast$tag\+\_\+name, int tag\+\_\+size, int tag\+\_\+type, i\+Base\+\_\+\+Tag\+Handle $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)}{iGeom_createTag(iGeom_Instance instance, const char *tag_name, int tag_size, int tag_type, iBase_TagHandle *tag_handle, int *err, int tag_name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const char $\ast$}]{tag\+\_\+name, }
\item[{int}]{tag\+\_\+size, }
\item[{int}]{tag\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err, }
\item[{int}]{tag\+\_\+name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a5f4cea9894ca7984844d1fe4093f589d}{}\label{i_geom_8h_a5f4cea9894ca7984844d1fe4093f589d}


Create a tag with specified name, size, and type. 

Create a tag with specified name, size, and type. Tag size is in units of size of tag\+\_\+type data types. Value input for tag type must be value in i\+Base\+\_\+\+Tag\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+name} & Character string indicating tag name \\
\hline
{\em tag\+\_\+size} & Size of each tag value, in units of number of tag\+\_\+type entities \\
\hline
{\em tag\+\_\+type} & Data type for data stored in this tag \\
\hline
{\em tag\+\_\+handle} & Pointer to tag handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em tag\+\_\+name\+\_\+len} & Length of tag name string \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+create\+Torus@{i\+Geom\+\_\+create\+Torus}}
\index{i\+Geom\+\_\+create\+Torus@{i\+Geom\+\_\+create\+Torus}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+create\+Torus(i\+Geom\+\_\+\+Instance, double major\+\_\+rad, double minor\+\_\+rad, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_createTorus(iGeom_Instance, double major_rad, double minor_rad, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+create\+Torus (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{major\+\_\+rad, }
\item[{double}]{minor\+\_\+rad, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_acfa73fab78672dc60d29ce246719aebf}{}\label{i_geom_8h_acfa73fab78672dc60d29ce246719aebf}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+delete\+All@{i\+Geom\+\_\+delete\+All}}
\index{i\+Geom\+\_\+delete\+All@{i\+Geom\+\_\+delete\+All}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+delete\+All(i\+Geom\+\_\+\+Instance, int $\ast$err)}{iGeom_deleteAll(iGeom_Instance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+delete\+All (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a3e2c0e70d2569301e03d1233f4a61b83}{}\label{i_geom_8h_a3e2c0e70d2569301e03d1233f4a61b83}


Delete all entities and sets. 

\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+delete\+Ent@{i\+Geom\+\_\+delete\+Ent}}
\index{i\+Geom\+\_\+delete\+Ent@{i\+Geom\+\_\+delete\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+delete\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle, int $\ast$err)}{iGeom_deleteEnt(iGeom_Instance, iBase_EntityHandle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+delete\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a56ab5a72a8470c43ba171037e7e5b1bc}{}\label{i_geom_8h_a56ab5a72a8470c43ba171037e7e5b1bc}


Delete specified entity. 

Delete specified entity 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity to be deleted \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+destroy\+Ent\+Set@{i\+Geom\+\_\+destroy\+Ent\+Set}}
\index{i\+Geom\+\_\+destroy\+Ent\+Set@{i\+Geom\+\_\+destroy\+Ent\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+destroy\+Ent\+Set(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iGeom_destroyEntSet(iGeom_Instance instance, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+destroy\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0cfb421e9ab67819e664558ae45faf6d}{}\label{i_geom_8h_a0cfb421e9ab67819e664558ae45faf6d}


Destroy an entity set. 

Destroy an entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set to be destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+destroy\+Tag@{i\+Geom\+\_\+destroy\+Tag}}
\index{i\+Geom\+\_\+destroy\+Tag@{i\+Geom\+\_\+destroy\+Tag}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+destroy\+Tag(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int forced, int $\ast$err)}{iGeom_destroyTag(iGeom_Instance instance, iBase_TagHandle tag_handle, int forced, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+destroy\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int}]{forced, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0a4246c72b176b3bf0e0570aef53d491}{}\label{i_geom_8h_a0a4246c72b176b3bf0e0570aef53d491}


Destroy a tag. 

Destroy a tag. If forced is non-\/zero and entities still have values set for this tag, tag is deleted anyway and those values disappear, otherwise tag is not deleted. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag to be deleted \\
\hline
{\em forced} & If non-\/zero, delete the tag even if entities have values set for that tag \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+dtor@{i\+Geom\+\_\+dtor}}
\index{i\+Geom\+\_\+dtor@{i\+Geom\+\_\+dtor}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+dtor(i\+Geom\+\_\+\+Instance instance, int $\ast$err)}{iGeom_dtor(iGeom_Instance instance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+dtor (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a33a1f4e8f54ce28b6abec5d2e9ca11ef}{}\label{i_geom_8h_a33a1f4e8f54ce28b6abec5d2e9ca11ef}


Destroy an i\+Geom instance. 

Destroy an i\+Geom instance 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance to be destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+end\+Ent\+Arr\+Iter@{i\+Geom\+\_\+end\+Ent\+Arr\+Iter}}
\index{i\+Geom\+\_\+end\+Ent\+Arr\+Iter@{i\+Geom\+\_\+end\+Ent\+Arr\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+end\+Ent\+Arr\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Arr\+Iterator, int $\ast$err)}{iGeom_endEntArrIter(iGeom_Instance, iGeom_EntityArrIterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+end\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Arr\+Iterator}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4d2c78b79c4ec28347f03cf5f453baeb}{}\label{i_geom_8h_a4d2c78b79c4ec28347f03cf5f453baeb}


Destroy the specified array iterator. 

Destroy the specified array iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator which gets destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+end\+Ent\+Iter@{i\+Geom\+\_\+end\+Ent\+Iter}}
\index{i\+Geom\+\_\+end\+Ent\+Iter@{i\+Geom\+\_\+end\+Ent\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+end\+Ent\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Iterator, int $\ast$err)}{iGeom_endEntIter(iGeom_Instance, iGeom_EntityIterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+end\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Iterator}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa0f2636b7bb10b36b08c0c7ae0c0aa64}{}\label{i_geom_8h_aa0f2636b7bb10b36b08c0c7ae0c0aa64}


Destroy the specified iterator. 

Destroy the specified iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator which gets destroyed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags@{i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags}}
\index{i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags@{i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getAllEntSetTags(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, iBase_TagHandle **tag_handles, int *tag_handles_allocated, int *tag_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+All\+Ent\+Set\+Tags (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$}]{tag\+\_\+handles, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a3f332db7dc8d8b7493c0a36c73278164}{}\label{i_geom_8h_a3f332db7dc8d8b7493c0a36c73278164}


Get all the tags associated with a specified entity set. 

Get all the tags associated with a specified entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity being queried \\
\hline
{\em $\ast$tag\+\_\+handles} & Pointer to array of tag\+\_\+handles returned from function \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+allocated} & Pointer to allocated size of tag\+\_\+handles array \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+size} & Pointer to occupied size of tag\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+All\+Tags@{i\+Geom\+\_\+get\+All\+Tags}}
\index{i\+Geom\+\_\+get\+All\+Tags@{i\+Geom\+\_\+get\+All\+Tags}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+All\+Tags(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle $\ast$$\ast$tag\+\_\+handles, int $\ast$tag\+\_\+handles\+\_\+allocated, int $\ast$tag\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getAllTags(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle **tag_handles, int *tag_handles_allocated, int *tag_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+All\+Tags (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$$\ast$}]{tag\+\_\+handles, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a64201715c4e6529741fe8c4a9f5abd90}{}\label{i_geom_8h_a64201715c4e6529741fe8c4a9f5abd90}


Get all the tags associated with a specified entity handle. 

Get all the tags associated with a specified entity handle 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em $\ast$tag\+\_\+handles} & Pointer to array of tag\+\_\+handles returned from function \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+allocated} & Pointer to allocated size of tag\+\_\+handles array \\
\hline
{\em $\ast$tag\+\_\+handles\+\_\+size} & Pointer to occupied size of tag\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr1st\+Drvt@{i\+Geom\+\_\+get\+Arr1st\+Drvt}}
\index{i\+Geom\+\_\+get\+Arr1st\+Drvt@{i\+Geom\+\_\+get\+Arr1st\+Drvt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr1st\+Drvt(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$dvtr\+\_\+u, int $\ast$dvrt\+\_\+u\+\_\+allocated, int $\ast$dvrt\+\_\+u\+\_\+size, int $\ast$$\ast$u\+\_\+offset, int $\ast$u\+\_\+offset\+\_\+allocated, int $\ast$u\+\_\+offset\+\_\+size, double $\ast$$\ast$dvrt\+\_\+v, int $\ast$dvrt\+\_\+v\+\_\+allocated, int $\ast$dvrt\+\_\+v\+\_\+size, int $\ast$$\ast$v\+\_\+offset, int $\ast$v\+\_\+offset\+\_\+allocated, int $\ast$v\+\_\+offset\+\_\+size, int $\ast$err)}{iGeom_getArr1stDrvt(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *uv, int uv_size, double **dvtr_u, int *dvrt_u_allocated, int *dvrt_u_size, int **u_offset, int *u_offset_allocated, int *u_offset_size, double **dvrt_v, int *dvrt_v_allocated, int *dvrt_v_size, int **v_offset, int *v_offset_allocated, int *v_offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr1st\+Drvt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{uv, }
\item[{int}]{uv\+\_\+size, }
\item[{double $\ast$$\ast$}]{dvtr\+\_\+u, }
\item[{int $\ast$}]{dvrt\+\_\+u\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+u\+\_\+size, }
\item[{int $\ast$$\ast$}]{u\+\_\+offset, }
\item[{int $\ast$}]{u\+\_\+offset\+\_\+allocated, }
\item[{int $\ast$}]{u\+\_\+offset\+\_\+size, }
\item[{double $\ast$$\ast$}]{dvrt\+\_\+v, }
\item[{int $\ast$}]{dvrt\+\_\+v\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+v\+\_\+size, }
\item[{int $\ast$$\ast$}]{v\+\_\+offset, }
\item[{int $\ast$}]{v\+\_\+offset\+\_\+allocated, }
\item[{int $\ast$}]{v\+\_\+offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac3e055066aba483dc8a3765473a791b3}{}\label{i_geom_8h_ac3e055066aba483dc8a3765473a791b3}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr2nd\+Adj@{i\+Geom\+\_\+get\+Arr2nd\+Adj}}
\index{i\+Geom\+\_\+get\+Arr2nd\+Adj@{i\+Geom\+\_\+get\+Arr2nd\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr2nd\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int order\+\_\+adjacent\+\_\+key, int requested\+\_\+entity\+\_\+type, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)}{iGeom_getArr2ndAdj(iGeom_Instance instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int order_adjacent_key, int requested_entity_type, iBase_EntityHandle **adj_entity_handles, int *adj_entity_handles_allocated, int *adj_entity_handles_size, int **offset, int *offset_allocated, int *offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr2nd\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{order\+\_\+adjacent\+\_\+key, }
\item[{int}]{requested\+\_\+entity\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a5fb39281c740fa5a3ef113c63231f1e8}{}\label{i_geom_8h_a5fb39281c740fa5a3ef113c63231f1e8}


Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities Get \char`\"{}2nd order\char`\"{} adjacencies to an array of entities, that is, from each entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities from which adjacencies are requested \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities whose adjacencies are requested \\
\hline
{\em bridge\+\_\+dimension} & Bridge dimension for 2nd order adjacencies \\
\hline
{\em to\+\_\+dimension} & Dimension of adjacent entities returned \\
\hline
{\em adj\+\_\+entity\+\_\+handles} & Adjacent entities \\
\hline
{\em adj\+\_\+entity\+\_\+handles\+\_\+allocated} & Allocated size of returned array \\
\hline
{\em adj\+\_\+entity\+\_\+handles\+\_\+size} & Occupied size of returned array \\
\hline
{\em offset} & Offset\mbox{[}i\mbox{]} is offset into adj\+\_\+entity\+\_\+handles of 2nd order adjacencies of ith entity in entity\+\_\+handles \\
\hline
{\em offset\+\_\+allocated} & Allocated size of offset array \\
\hline
{\em offset\+\_\+size} & Occupied size of offset array \\
\hline
{\em err} & \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr2nd\+Drvt@{i\+Geom\+\_\+get\+Arr2nd\+Drvt}}
\index{i\+Geom\+\_\+get\+Arr2nd\+Drvt@{i\+Geom\+\_\+get\+Arr2nd\+Drvt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr2nd\+Drvt(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$dvtr\+\_\+uu, int $\ast$dvrt\+\_\+uu\+\_\+allocated, int $\ast$dvrt\+\_\+uu\+\_\+size, int $\ast$$\ast$uu\+\_\+offset, int $\ast$uu\+\_\+offset\+\_\+allocated, int $\ast$uu\+\_\+offset\+\_\+size, double $\ast$$\ast$dvtr\+\_\+vv, int $\ast$dvrt\+\_\+vv\+\_\+allocated, int $\ast$dvrt\+\_\+vv\+\_\+size, int $\ast$$\ast$vv\+\_\+offset, int $\ast$vv\+\_\+offset\+\_\+allocated, int $\ast$vv\+\_\+offset\+\_\+size, double $\ast$$\ast$dvrt\+\_\+uv, int $\ast$dvrt\+\_\+uv\+\_\+allocated, int $\ast$dvrt\+\_\+uv\+\_\+size, int $\ast$$\ast$uv\+\_\+offset, int $\ast$uv\+\_\+offset\+\_\+allocated, int $\ast$uv\+\_\+offset\+\_\+size, int $\ast$err)}{iGeom_getArr2ndDrvt(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *uv, int uv_size, double **dvtr_uu, int *dvrt_uu_allocated, int *dvrt_uu_size, int **uu_offset, int *uu_offset_allocated, int *uu_offset_size, double **dvtr_vv, int *dvrt_vv_allocated, int *dvrt_vv_size, int **vv_offset, int *vv_offset_allocated, int *vv_offset_size, double **dvrt_uv, int *dvrt_uv_allocated, int *dvrt_uv_size, int **uv_offset, int *uv_offset_allocated, int *uv_offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr2nd\+Drvt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{uv, }
\item[{int}]{uv\+\_\+size, }
\item[{double $\ast$$\ast$}]{dvtr\+\_\+uu, }
\item[{int $\ast$}]{dvrt\+\_\+uu\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+uu\+\_\+size, }
\item[{int $\ast$$\ast$}]{uu\+\_\+offset, }
\item[{int $\ast$}]{uu\+\_\+offset\+\_\+allocated, }
\item[{int $\ast$}]{uu\+\_\+offset\+\_\+size, }
\item[{double $\ast$$\ast$}]{dvtr\+\_\+vv, }
\item[{int $\ast$}]{dvrt\+\_\+vv\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+vv\+\_\+size, }
\item[{int $\ast$$\ast$}]{vv\+\_\+offset, }
\item[{int $\ast$}]{vv\+\_\+offset\+\_\+allocated, }
\item[{int $\ast$}]{vv\+\_\+offset\+\_\+size, }
\item[{double $\ast$$\ast$}]{dvrt\+\_\+uv, }
\item[{int $\ast$}]{dvrt\+\_\+uv\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+uv\+\_\+size, }
\item[{int $\ast$$\ast$}]{uv\+\_\+offset, }
\item[{int $\ast$}]{uv\+\_\+offset\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0dd8c46a52eef0c691f542db4b930cd6}{}\label{i_geom_8h_a0dd8c46a52eef0c691f542db4b930cd6}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Adj@{i\+Geom\+\_\+get\+Arr\+Adj}}
\index{i\+Geom\+\_\+get\+Arr\+Adj@{i\+Geom\+\_\+get\+Arr\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int requested\+\_\+entity\+\_\+type, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entity\+\_\+handles, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, int $\ast$err)}{iGeom_getArrAdj(iGeom_Instance instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int requested_entity_type, iBase_EntityHandle **adj_entity_handles, int *adj_entity_handles_allocated, int *adj_entity_handles_size, int **offset, int *offset_allocated, int *offset_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{requested\+\_\+entity\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8754a61b55ae9f452174df77c433c4a4}{}\label{i_geom_8h_a8754a61b55ae9f452174df77c433c4a4}


Get entities of specified type adjacent to entities. 

Get entities of specified type adjacent to entities. Specified type must be value in the i\+Base\+\_\+\+Entity\+Type enumeration. {\itshape offset(i)} is index of first entity in adjacent\+Entity\+Handles array adjacent to entity\+\_\+handles\mbox{[}i\mbox{]}. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+type\+\_\+requested} & Type of adjacent entities requested \\
\hline
{\em $\ast$adjacent\+Entity\+Handles} & Pointer to array of adjacent\+Entity\+Handles returned from function \\
\hline
{\em $\ast$adjacent\+Entity\+Handles\+\_\+allocated} & Pointer to allocated size of adjacent\+Entity\+Handles array \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size} & Pointer to occupied size of adjacent\+Entity\+Handles array \\
\hline
{\em $\ast$offset} & Pointer to array of offsets returned from function \\
\hline
{\em $\ast$offset\+\_\+allocated} & Pointer to allocated size of offset array \\
\hline
{\em $\ast$offset\+\_\+size} & Pointer to occupied size of offset array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Bound\+Box@{i\+Geom\+\_\+get\+Arr\+Bound\+Box}}
\index{i\+Geom\+\_\+get\+Arr\+Bound\+Box@{i\+Geom\+\_\+get\+Arr\+Bound\+Box}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Bound\+Box(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$min\+\_\+corner, int $\ast$min\+\_\+corner\+\_\+allocated, int $\ast$min\+\_\+corner\+\_\+size, double $\ast$$\ast$max\+\_\+corner, int $\ast$max\+\_\+corner\+\_\+allocated, int $\ast$max\+\_\+corner\+\_\+size, int $\ast$err)}{iGeom_getArrBoundBox(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double **min_corner, int *min_corner_allocated, int *min_corner_size, double **max_corner, int *max_corner_allocated, int *max_corner_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Bound\+Box (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{min\+\_\+corner, }
\item[{int $\ast$}]{min\+\_\+corner\+\_\+allocated, }
\item[{int $\ast$}]{min\+\_\+corner\+\_\+size, }
\item[{double $\ast$$\ast$}]{max\+\_\+corner, }
\item[{int $\ast$}]{max\+\_\+corner\+\_\+allocated, }
\item[{int $\ast$}]{max\+\_\+corner\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9b7d6633fc8635834d0cbfdb33f4070e}{}\label{i_geom_8h_a9b7d6633fc8635834d0cbfdb33f4070e}


Get the bounding box of the specified entities Get the bounding box of the specified entities. Storage order passed back will be member of i\+Base\+\_\+\+Storage\+Order enum. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity handles being queried \\
\hline
{\em enttiy\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates passed back \\
\hline
{\em min\+\_\+corner} & Minimum coordinates of bounding boxes \\
\hline
{\em min\+\_\+corner\+\_\+allocated} & Allocated size of minimum coordinates array \\
\hline
{\em min\+\_\+corner\+\_\+size} & Occupied size of minimum coordinates array \\
\hline
{\em max\+\_\+corner} & Maximum coordinates of bounding boxes \\
\hline
{\em max\+\_\+corner\+\_\+allocated} & Allocated size of maximum coordinates array \\
\hline
{\em max\+\_\+corner\+\_\+size} & Occupied size of maximum coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Closest\+Pt@{i\+Geom\+\_\+get\+Arr\+Closest\+Pt}}
\index{i\+Geom\+\_\+get\+Arr\+Closest\+Pt@{i\+Geom\+\_\+get\+Arr\+Closest\+Pt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Closest\+Pt(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$near\+\_\+coordinates, int near\+\_\+coordinates\+\_\+size, double $\ast$$\ast$on\+\_\+coordinates, int $\ast$on\+\_\+coordinates\+\_\+allocated, int $\ast$on\+\_\+coordinates\+\_\+size, int $\ast$err)}{iGeom_getArrClosestPt(iGeom_Instance instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *near_coordinates, int near_coordinates_size, double **on_coordinates, int *on_coordinates_allocated, int *on_coordinates_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Closest\+Pt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{near\+\_\+coordinates, }
\item[{int}]{near\+\_\+coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{on\+\_\+coordinates, }
\item[{int $\ast$}]{on\+\_\+coordinates\+\_\+allocated, }
\item[{int $\ast$}]{on\+\_\+coordinates\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a21b95b9d2bb46c891bd4f48a130007c1}{}\label{i_geom_8h_a21b95b9d2bb46c891bd4f48a130007c1}


Get closest point for an array of entities and points Get closest point for an array of entities and points. If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity(ies) being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of input points \\
\hline
{\em near\+\_\+coordinates} & Coordinates of starting \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)} \\
\hline
{\em near\+\_\+coordinates\+\_\+size} & Number of values in near\+\_\+coordinates array \\
\hline
{\em on\+\_\+coordinates} & Coordinates of closest points \\
\hline
{\em on\+\_\+coordinates\+\_\+allocated} & Allocated size of closest point array \\
\hline
{\em on\+\_\+coordinates\+\_\+size} & Occupied size of closest point array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Data@{i\+Geom\+\_\+get\+Arr\+Data}}
\index{i\+Geom\+\_\+get\+Arr\+Data@{i\+Geom\+\_\+get\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_getArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, char **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8f326f5dc161b3c113dd818340fd61f0}{}\label{i_geom_8h_a8f326f5dc161b3c113dd818340fd61f0}


Get tag values of arbitrary type for an array of entities. 

Get tag values of arbitrary type for an array of entities. Tag data is returned as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, double $\ast$$\ast$tangent, int $\ast$tangent\+\_\+allocated, int $\ast$tangent\+\_\+size, double $\ast$$\ast$cvtr, int $\ast$cvtr\+\_\+allocated, int $\ast$cvtr\+\_\+size, int $\ast$err)}{iGeom_getArrEgEvalXYZ(iGeom_Instance, iBase_EntityHandle const *edge_handles, int edge_handles_size, int storage_order, double const *coords, int coords_size, double **on_coords, int *on_coords_allocated, int *on_coords_size, double **tangent, int *tangent_allocated, int *tangent_size, double **cvtr, int *cvtr_allocated, int *cvtr_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Eg\+Eval\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{on\+\_\+coords, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{tangent, }
\item[{int $\ast$}]{tangent\+\_\+allocated, }
\item[{int $\ast$}]{tangent\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr, }
\item[{int $\ast$}]{cvtr\+\_\+allocated, }
\item[{int $\ast$}]{cvtr\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9aa5d1c6810ac5c0aab0753189872fe1}{}\label{i_geom_8h_a9aa5d1c6810ac5c0aab0753189872fe1}


Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s) Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handles} & Edge(s) being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Number of edges being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates \\
\hline
{\em coords} & Starting coordinates \\
\hline
{\em coords\+\_\+size} & Number of values in coordinates array \\
\hline
{\em on\+\_\+coords} & Closest point array \\
\hline
{\em on\+\_\+coords\+\_\+allocated} & Allocated size of closest point array \\
\hline
{\em on\+\_\+coords\+\_\+size} & Occupied size of closest point array \\
\hline
{\em tangent} & Tangent array \\
\hline
{\em tangent\+\_\+allocated} & Allocated size of tangent array \\
\hline
{\em tangent\+\_\+size} & Occupied size of tangent array \\
\hline
{\em cvtr} & First principal curvatures \\
\hline
{\em cvtr\+\_\+allocated} & Allocated size of first curvature array \\
\hline
{\em cvtr\+\_\+size} & Occupied size of first curvature array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, double $\ast$$\ast$normal, int $\ast$normal\+\_\+allocated, int $\ast$normal\+\_\+size, double $\ast$$\ast$cvtr1, int $\ast$cvtr1\+\_\+allocated, int $\ast$cvtr1\+\_\+size, double $\ast$$\ast$cvtr2, int $\ast$cvtr2\+\_\+allocated, int $\ast$cvtr2\+\_\+size, int $\ast$err)}{iGeom_getArrFcEvalXYZ(iGeom_Instance, iBase_EntityHandle const *face_handles, int face_handles_size, int storage_order, double const *coords, int coords_size, double **on_coords, int *on_coords_allocated, int *on_coords_size, double **normal, int *normal_allocated, int *normal_size, double **cvtr1, int *cvtr1_allocated, int *cvtr1_size, double **cvtr2, int *cvtr2_allocated, int *cvtr2_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Fc\+Eval\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{on\+\_\+coords, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{normal, }
\item[{int $\ast$}]{normal\+\_\+allocated, }
\item[{int $\ast$}]{normal\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr1, }
\item[{int $\ast$}]{cvtr1\+\_\+allocated, }
\item[{int $\ast$}]{cvtr1\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr2, }
\item[{int $\ast$}]{cvtr2\+\_\+allocated, }
\item[{int $\ast$}]{cvtr2\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac1f47fb66e80dd8f1e15b408bf50f9b2}{}\label{i_geom_8h_ac1f47fb66e80dd8f1e15b408bf50f9b2}


Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s) Get the closest \hyperlink{plotdecs_8h_a4ccddf70df3a5e808503d2bf495d5279}{point(s)}, tangent(s), and curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handles} & Edge(s) being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Number of edges being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates \\
\hline
{\em coords} & Starting coordinates \\
\hline
{\em coords\+\_\+size} & Number of values in coordinates array \\
\hline
{\em on\+\_\+coords} & Closest point array \\
\hline
{\em on\+\_\+coords\+\_\+allocated} & Allocated size of closest point array \\
\hline
{\em on\+\_\+coords\+\_\+size} & Occupied size of closest point array \\
\hline
{\em normal} & Normal array \\
\hline
{\em normal\+\_\+allocated} & Allocated size of normal array \\
\hline
{\em normal\+\_\+size} & Occupied size of normal array \\
\hline
{\em cvtr\+\_\+1} & First principal curvatures \\
\hline
{\em cvtr\+\_\+1\+\_\+allocated} & Allocated size of first curvature array \\
\hline
{\em cvtr\+\_\+1\+\_\+size} & Occupied size of first curvature array \\
\hline
{\em cvtr\+\_\+2} & Second principal curvatures \\
\hline
{\em cvtr\+\_\+2\+\_\+allocated} & Allocated size of second curvature array \\
\hline
{\em cvtr\+\_\+2\+\_\+size} & Occupied size of second curvature array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$near\+\_\+coordinates, int near\+\_\+coordinates\+\_\+size, double $\ast$$\ast$on\+\_\+coordinates, int $\ast$on\+\_\+coordinates\+\_\+allocated, int $\ast$on\+\_\+coordinates\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)}{iGeom_getArrNrmlPlXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *near_coordinates, int near_coordinates_size, double **on_coordinates, int *on_coordinates_allocated, int *on_coordinates_size, double **normals, int *normals_allocated, int *normals_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Nrml\+Pl\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{near\+\_\+coordinates, }
\item[{int}]{near\+\_\+coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{on\+\_\+coordinates, }
\item[{int $\ast$}]{on\+\_\+coordinates\+\_\+allocated, }
\item[{int $\ast$}]{on\+\_\+coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{normals, }
\item[{int $\ast$}]{normals\+\_\+allocated, }
\item[{int $\ast$}]{normals\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a548dbec94f87e3aee01dc2b9b1915fc3}{}\label{i_geom_8h_a548dbec94f87e3aee01dc2b9b1915fc3}


Get the normal vector A\+ND closest point on an entity(ies) at given position(s) Get the normal vector A\+ND closest point on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity(ies) being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entity(ies) being queried \\
\hline
{\em storage\+\_\+order} & Storage order in near\+\_\+coordinates array \\
\hline
{\em near\+\_\+coordinates} & Starting coordinates \\
\hline
{\em near\+\_\+coordinates\+\_\+size} & Number of values in near\+\_\+coordinates array \\
\hline
{\em on\+\_\+coordinates} & Closest point array \\
\hline
{\em on\+\_\+coordinates\+\_\+allocated} & Allocated size of closest point array \\
\hline
{\em on\+\_\+coordinates\+\_\+size} & Occupied size of closest point array \\
\hline
{\em normals} & Normal array \\
\hline
{\em normals\+\_\+allocated} & Allocated size of normal array \\
\hline
{\em normals\+\_\+size} & Occupied size of normal array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Nrml\+Sense@{i\+Geom\+\_\+get\+Arr\+Nrml\+Sense}}
\index{i\+Geom\+\_\+get\+Arr\+Nrml\+Sense@{i\+Geom\+\_\+get\+Arr\+Nrml\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Nrml\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$region\+\_\+handles, int region\+\_\+handles\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)}{iGeom_getArrNrmlSense(iGeom_Instance, iBase_EntityHandle const *face_handles, int face_handles_size, iBase_EntityHandle const *region_handles, int region_handles_size, int **sense, int *sense_allocated, int *sense_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Nrml\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{region\+\_\+handles, }
\item[{int}]{region\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{sense, }
\item[{int $\ast$}]{sense\+\_\+allocated, }
\item[{int $\ast$}]{sense\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0ecedf461ab7035ae5fd82f2bad6c840}{}\label{i_geom_8h_a0ecedf461ab7035ae5fd82f2bad6c840}


Get the senses of an array of faces with respect to an array of regions Get the senses of an array of faces with respect to an array of regions. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that face bounds the region once with each sense. 


\begin{DoxyParams}{Parameters}
{\em face\+\_\+handles} & Faces being queried \\
\hline
{\em face\+\_\+handles\+\_\+size} & Size of face handles array \\
\hline
{\em region\+\_\+handles} & Regions being queried \\
\hline
{\em region\+\_\+handles\+\_\+size} & Size of region handles array \\
\hline
{\em sense} & Senses of faces with respect to regions \\
\hline
{\em sense\+\_\+allocated} & Allocated size of senses array \\
\hline
{\em sense\+\_\+size} & Occupied size of senses array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Nrml\+UV@{i\+Geom\+\_\+get\+Arr\+Nrml\+UV}}
\index{i\+Geom\+\_\+get\+Arr\+Nrml\+UV@{i\+Geom\+\_\+get\+Arr\+Nrml\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Nrml\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$parameters, int parameters\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)}{iGeom_getArrNrmlUV(iGeom_Instance, iBase_EntityHandle const *face_handles, int face_handles_size, int storage_order, double const *parameters, int parameters_size, double **normals, int *normals_allocated, int *normals_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Nrml\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{parameters, }
\item[{int}]{parameters\+\_\+size, }
\item[{double $\ast$$\ast$}]{normals, }
\item[{int $\ast$}]{normals\+\_\+allocated, }
\item[{int $\ast$}]{normals\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9b49913a17d4ef09b04193c61d5c884d}{}\label{i_geom_8h_a9b49913a17d4ef09b04193c61d5c884d}


Return the normals at a specified parametric positions Return the normals at a specified parametric positions. If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u} & Parametric position being queried \\
\hline
{\em v} & Parametric position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Nrml\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$normals, int $\ast$normals\+\_\+allocated, int $\ast$normals\+\_\+size, int $\ast$err)}{iGeom_getArrNrmlXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coordinates, int coordinates_size, double **normals, int *normals_allocated, int *normals_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Nrml\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coordinates, }
\item[{int}]{coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{normals, }
\item[{int $\ast$}]{normals\+\_\+allocated, }
\item[{int $\ast$}]{normals\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_afc31e7a8db20572c14f688a634c63063}{}\label{i_geom_8h_afc31e7a8db20572c14f688a634c63063}


Get the normal vector on an entity(ies) at given position(s) Get the normal vector on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity(ies) being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates \\
\hline
{\em coordinates} & Starting coordinates \\
\hline
{\em coordinates\+\_\+size} & Number of values in coordinates array \\
\hline
{\em normals} & Normal coordinates \\
\hline
{\em normals\+\_\+allocated} & Allocated size of normals array \\
\hline
{\em normals\+\_\+size} & Occupied size of normals array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+TgntU@{i\+Geom\+\_\+get\+Arr\+TgntU}}
\index{i\+Geom\+\_\+get\+Arr\+TgntU@{i\+Geom\+\_\+get\+Arr\+TgntU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Tgnt\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$parameters, int parameters\+\_\+size, double $\ast$$\ast$tangents, int $\ast$tangents\+\_\+allocated, int $\ast$tangents\+\_\+size, int $\ast$err)}{iGeom_getArrTgntU(iGeom_Instance, iBase_EntityHandle const *edge_handles, int edge_handles_size, int storage_order, double const *parameters, int parameters_size, double **tangents, int *tangents_allocated, int *tangents_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+TgntU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{parameters, }
\item[{int}]{parameters\+\_\+size, }
\item[{double $\ast$$\ast$}]{tangents, }
\item[{int $\ast$}]{tangents\+\_\+allocated, }
\item[{int $\ast$}]{tangents\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a10ee890d9a42f23cf764ab923988ce36}{}\label{i_geom_8h_a10ee890d9a42f23cf764ab923988ce36}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$tangents, int $\ast$tangents\+\_\+allocated, int $\ast$tangents\+\_\+size, int $\ast$err)}{iGeom_getArrTgntXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coordinates, int coordinates_size, double **tangents, int *tangents_allocated, int *tangents_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Tgnt\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coordinates, }
\item[{int}]{coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{tangents, }
\item[{int $\ast$}]{tangents\+\_\+allocated, }
\item[{int $\ast$}]{tangents\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a57fd2149c76d0d56136157c469dba6ca}{}\label{i_geom_8h_a57fd2149c76d0d56136157c469dba6ca}


Get the tangent vector on an entity(ies) at given position(s) Get the tangent vector on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity(ies) being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates \\
\hline
{\em coordinates} & Starting coordinates \\
\hline
{\em coordinates\+\_\+size} & Number of values in coordinates array \\
\hline
{\em tangents} & Tangent coordinates \\
\hline
{\em tangents\+\_\+allocated} & Allocated size of tangents array \\
\hline
{\em tangents\+\_\+size} & Occupied size of tangents array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Tolerance@{i\+Geom\+\_\+get\+Arr\+Tolerance}}
\index{i\+Geom\+\_\+get\+Arr\+Tolerance@{i\+Geom\+\_\+get\+Arr\+Tolerance}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Tolerance(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$tolerances, int $\ast$tolerances\+\_\+allocated, int $\ast$tolerances\+\_\+size, int $\ast$err)}{iGeom_getArrTolerance(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, double **tolerances, int *tolerances_allocated, int *tolerances_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Tolerance (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{double $\ast$$\ast$}]{tolerances, }
\item[{int $\ast$}]{tolerances\+\_\+allocated, }
\item[{int $\ast$}]{tolerances\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a35e82ff89851048991d0110a4fee9ca6}{}\label{i_geom_8h_a35e82ff89851048991d0110a4fee9ca6}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Type@{i\+Geom\+\_\+get\+Arr\+Type}}
\index{i\+Geom\+\_\+get\+Arr\+Type@{i\+Geom\+\_\+get\+Arr\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Type(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$type, int $\ast$type\+\_\+allocated, int $\ast$type\+\_\+size, int $\ast$err)}{iGeom_getArrType(iGeom_Instance instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int **type, int *type_allocated, int *type_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{type, }
\item[{int $\ast$}]{type\+\_\+allocated, }
\item[{int $\ast$}]{type\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ab6c4c21ba5dde53e2972333424fdc257}{}\label{i_geom_8h_ab6c4c21ba5dde53e2972333424fdc257}


Get the entity type for the specified entities. 

Get the entity type for the specified entities. Types returned are values in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entity handles being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em $\ast$type} & Pointer to array of types returned from function \\
\hline
{\em $\ast$type\+\_\+allocated} & Pointer to allocated size of type array \\
\hline
{\em $\ast$type\+\_\+size} & Pointer to occupied size of type array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+U\+Range@{i\+Geom\+\_\+get\+Arr\+U\+Range}}
\index{i\+Geom\+\_\+get\+Arr\+U\+Range@{i\+Geom\+\_\+get\+Arr\+U\+Range}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+U\+Range(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$u\+\_\+min, int $\ast$u\+\_\+min\+\_\+allocated, int $\ast$u\+\_\+min\+\_\+size, double $\ast$$\ast$u\+\_\+max, int $\ast$u\+\_\+max\+\_\+allocated, int $\ast$u\+\_\+max\+\_\+size, int $\ast$err)}{iGeom_getArrURange(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, double **u_min, int *u_min_allocated, int *u_min_size, double **u_max, int *u_max_allocated, int *u_max_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+U\+Range (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{double $\ast$$\ast$}]{u\+\_\+min, }
\item[{int $\ast$}]{u\+\_\+min\+\_\+allocated, }
\item[{int $\ast$}]{u\+\_\+min\+\_\+size, }
\item[{double $\ast$$\ast$}]{u\+\_\+max, }
\item[{int $\ast$}]{u\+\_\+max\+\_\+allocated, }
\item[{int $\ast$}]{u\+\_\+max\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_adafb9f7d543b41b722f46269a290c8e4}{}\label{i_geom_8h_adafb9f7d543b41b722f46269a290c8e4}


Get parametric range of entities Get parametric range of entities. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of parametric coordinates being returned \\
\hline
{\em u\+\_\+min} & Minimum parametric coordinate for entities \\
\hline
{\em u\+\_\+min\+\_\+allocated} & Allocated size of minimum parametric coordinate array \\
\hline
{\em u\+\_\+min\+\_\+size} & Occupied size of minimum parametric coordinate array \\
\hline
{\em u\+\_\+max} & Maximum parametric coordinate for entities \\
\hline
{\em u\+\_\+max\+\_\+allocated} & Allocated size of maximum parametric coordinate array \\
\hline
{\em u\+\_\+max\+\_\+size} & Occupied size of maximum parametric coordinate array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Uto\+UV@{i\+Geom\+\_\+get\+Arr\+Uto\+UV}}
\index{i\+Geom\+\_\+get\+Arr\+Uto\+UV@{i\+Geom\+\_\+get\+Arr\+Uto\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Uto\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, double const $\ast$u\+\_\+in, int u\+\_\+in\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)}{iGeom_getArrUtoUV(iGeom_Instance, iBase_EntityHandle const *edge_handles, int edge_handles_size, iBase_EntityHandle const *face_handles, int face_handles_size, double const *u_in, int u_in_size, int storage_order, double **uv, int *uv_allocated, int *uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Uto\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{double const $\ast$}]{u\+\_\+in, }
\item[{int}]{u\+\_\+in\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{uv, }
\item[{int $\ast$}]{uv\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a2ee7bb4b47b7e3e39fc3e6db1e43ddb9}{}\label{i_geom_8h_a2ee7bb4b47b7e3e39fc3e6db1e43ddb9}


Return the face parametric coordinates for a parametric position on bounding edges Return the face parametric coordinates for a parametric position on bounding edges. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handles} & Edges being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Number of edges being queried \\
\hline
{\em face\+\_\+handles} & Faces being queried \\
\hline
{\em face\+\_\+handles\+\_\+size} & Number of faces being queried \\
\hline
{\em u\+\_\+in} & Parametric positions on edges \\
\hline
{\em u\+\_\+in\+\_\+size} & Number of parametric positions on edges \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates returned \\
\hline
{\em uv} & Corresponding parametric positions on faces \\
\hline
{\em uv\+\_\+allocated} & Allocated size of parameter array \\
\hline
{\em uv\+\_\+size} & Occupied size of parameter array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+Uto\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double const $\ast$u, int u\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$on\+\_\+coords, int $\ast$on\+\_\+coords\+\_\+allocated, int $\ast$on\+\_\+coords\+\_\+size, int $\ast$err)}{iGeom_getArrUtoXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, double const *u, int u_size, int storage_order, double **on_coords, int *on_coords_allocated, int *on_coords_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+Uto\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{double const $\ast$}]{u, }
\item[{int}]{u\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{on\+\_\+coords, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{on\+\_\+coords\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ad781f826b7170abe3c09ac63a99b8d70}{}\label{i_geom_8h_ad781f826b7170abe3c09ac63a99b8d70}


Return coordinate positions at specified parametric position(s) on entity(ies) Return coordinate positions at specified parametric position(s) on entity(ies). If either the number of entities or number of parametric coordinate pairs is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of resulting coordinates \\
\hline
{\em uv} & Coordinates being queried \\
\hline
{\em uv\+\_\+size} & Number of coordinates in array \\
\hline
{\em coordinates} & Coordinates of parametric positions \\
\hline
{\em coordinates\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em coordinates\+\_\+size} & Occupied size of coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+U\+V\+Range@{i\+Geom\+\_\+get\+Arr\+U\+V\+Range}}
\index{i\+Geom\+\_\+get\+Arr\+U\+V\+Range@{i\+Geom\+\_\+get\+Arr\+U\+V\+Range}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+U\+V\+Range(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv\+\_\+min, int $\ast$uv\+\_\+min\+\_\+allocated, int $\ast$uv\+\_\+min\+\_\+size, double $\ast$$\ast$uv\+\_\+max, int $\ast$uv\+\_\+max\+\_\+allocated, int $\ast$uv\+\_\+max\+\_\+size, int $\ast$err)}{iGeom_getArrUVRange(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double **uv_min, int *uv_min_allocated, int *uv_min_size, double **uv_max, int *uv_max_allocated, int *uv_max_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+U\+V\+Range (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{uv\+\_\+min, }
\item[{int $\ast$}]{uv\+\_\+min\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+min\+\_\+size, }
\item[{double $\ast$$\ast$}]{uv\+\_\+max, }
\item[{int $\ast$}]{uv\+\_\+max\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+max\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac4471aa36a64ef27357363ceed873b0d}{}\label{i_geom_8h_ac4471aa36a64ef27357363ceed873b0d}


Get parametric range of entities Get parametric range of entities. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of parametric coordinates being returned \\
\hline
{\em uv\+\_\+min} & Minimum parametric coordinate for entities \\
\hline
{\em uv\+\_\+min\+\_\+allocated} & Allocated size of minimum parametric coordinate array \\
\hline
{\em uv\+\_\+min\+\_\+size} & Occupied size of minimum parametric coordinate array \\
\hline
{\em uv\+\_\+max} & Maximum parametric coordinate for entities \\
\hline
{\em uv\+\_\+max\+\_\+allocated} & Allocated size of maximum parametric coordinate array \\
\hline
{\em uv\+\_\+max\+\_\+size} & Occupied size of maximum parametric coordinate array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ@{i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$coordinates, int $\ast$coordinates\+\_\+allocated, int $\ast$coordinates\+\_\+size, int $\ast$err)}{iGeom_getArrUVtoXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *uv, int uv_size, double **coordinates, int *coordinates_allocated, int *coordinates_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+U\+Vto\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{uv, }
\item[{int}]{uv\+\_\+size, }
\item[{double $\ast$$\ast$}]{coordinates, }
\item[{int $\ast$}]{coordinates\+\_\+allocated, }
\item[{int $\ast$}]{coordinates\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aba86a3e1f8acd10ed3b4ad52b91c4757}{}\label{i_geom_8h_aba86a3e1f8acd10ed3b4ad52b91c4757}


Return coordinate positions at specified parametric position(s) on entity(ies) Return coordinate positions at specified parametric position(s) on entity(ies). If either the number of entities or number of parametric coordinate pairs is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of uv coordinates input and xyz coordinate output \\
\hline
{\em uv} & Coordinates being queried \\
\hline
{\em uv\+\_\+size} & Number of coordinates in array \\
\hline
{\em coordinates} & Coordinates of parametric positions \\
\hline
{\em coordinates\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em coordinates\+\_\+size} & Occupied size of coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU@{i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU}}
\index{i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU@{i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$u, int $\ast$u\+\_\+allocated, int $\ast$u\+\_\+size, int $\ast$err)}{iGeom_getArrXYZtoU(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coordinates, int coordinates_size, double **u, int *u_allocated, int *u_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+X\+Y\+ZtoU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coordinates, }
\item[{int}]{coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{u, }
\item[{int $\ast$}]{u\+\_\+allocated, }
\item[{int $\ast$}]{u\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a852abfd9c32604561777f5ca311f2d6a}{}\label{i_geom_8h_a852abfd9c32604561777f5ca311f2d6a}


Return spatial positions at specified parametric position(s) on entity(ies) Return spatial positions at specified parametric position(s) on entity(ies). If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of spatial coordinates input \\
\hline
{\em coordinates} & Coordinates being queried \\
\hline
{\em coordinates\+\_\+size} & Number of coordinates in array \\
\hline
{\em u} & Coordinates of parametric positions \\
\hline
{\em u\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em u\+\_\+size} & Occupied size of coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV@{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV}}
\index{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV@{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coordinates, int coordinates\+\_\+size, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)}{iGeom_getArrXYZtoUV(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coordinates, int coordinates_size, double **uv, int *uv_allocated, int *uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coordinates, }
\item[{int}]{coordinates\+\_\+size, }
\item[{double $\ast$$\ast$}]{uv, }
\item[{int $\ast$}]{uv\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a886c20be48410ff274c11112f7d777c9}{}\label{i_geom_8h_a886c20be48410ff274c11112f7d777c9}


Return parametric positions at specified spatial position(s) on entity(ies) Return parametric positions at specified spatial position(s) on entity(ies). If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of spatial coordinates input \\
\hline
{\em coordinates} & Coordinates being queried \\
\hline
{\em coordinates\+\_\+size} & Number of coordinates in array \\
\hline
{\em uv} & Coordinates of parametric positions \\
\hline
{\em uv\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em uv\+\_\+size} & Occupied size of coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint@{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint}}
\index{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint@{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)}{iGeom_getArrXYZtoUVHint(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coords, int coords_size, double **uv, int *uv_allocated, int *uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Arr\+X\+Y\+Zto\+U\+V\+Hint (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{uv, }
\item[{int $\ast$}]{uv\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8452c670e30c0aba846c251f83b8305b}{}\label{i_geom_8h_a8452c670e30c0aba846c251f83b8305b}


Return parametric positions at specified spatial position(s) on entity(ies), based on parametric position hints Return parametric positions at specified spatial position(s) on entity(ies), based on parametric position hints. If either the number of entities or number of spatial coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of spatial coordinates input \\
\hline
{\em coordinates} & Coordinates being queried \\
\hline
{\em coordinates\+\_\+size} & Number of coordinates in array \\
\hline
{\em uv} & Coordinates of parametric positions \\
\hline
{\em uv\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em uv\+\_\+size} & Occupied size of coordinates array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Bound\+Box@{i\+Geom\+\_\+get\+Bound\+Box}}
\index{i\+Geom\+\_\+get\+Bound\+Box@{i\+Geom\+\_\+get\+Bound\+Box}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Bound\+Box(i\+Geom\+\_\+\+Instance, double $\ast$min\+\_\+x, double $\ast$min\+\_\+y, double $\ast$min\+\_\+z, double $\ast$max\+\_\+x, double $\ast$max\+\_\+y, double $\ast$max\+\_\+z, int $\ast$err)}{iGeom_getBoundBox(iGeom_Instance, double *min_x, double *min_y, double *min_z, double *max_x, double *max_y, double *max_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Bound\+Box (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double $\ast$}]{min\+\_\+x, }
\item[{double $\ast$}]{min\+\_\+y, }
\item[{double $\ast$}]{min\+\_\+z, }
\item[{double $\ast$}]{max\+\_\+x, }
\item[{double $\ast$}]{max\+\_\+y, }
\item[{double $\ast$}]{max\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abe6978722a9c8a5331e08fc1f3e856cb}{}\label{i_geom_8h_abe6978722a9c8a5331e08fc1f3e856cb}


Get the bounding box of the entire model Get the bounding box of the entire model. 


\begin{DoxyParams}{Parameters}
{\em min\+\_\+x} & Minimum coordinate of bounding box \\
\hline
{\em min\+\_\+y} & Minimum coordinate of bounding box \\
\hline
{\em min\+\_\+z} & Minimum coordinate of bounding box \\
\hline
{\em max\+\_\+x} & Maximum coordinate of bounding box \\
\hline
{\em max\+\_\+y} & Maximum coordinate of bounding box \\
\hline
{\em max\+\_\+z} & Maximum coordinate of bounding box \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Chldn@{i\+Geom\+\_\+get\+Chldn}}
\index{i\+Geom\+\_\+get\+Chldn@{i\+Geom\+\_\+get\+Chldn}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Chldn(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle from\+\_\+entity\+\_\+set, int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getChldn(iGeom_Instance instance, iBase_EntitySetHandle from_entity_set, int num_hops, iBase_EntitySetHandle **entity_set_handles, int *entity_set_handles_allocated, int *entity_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Chldn (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{from\+\_\+entity\+\_\+set, }
\item[{int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{entity\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac74f82f4df9c7226f137d47ec2bcb8a2}{}\label{i_geom_8h_ac74f82f4df9c7226f137d47ec2bcb8a2}


Get the child sets linked from a specified set. 

Get the child sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any child. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em from\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to child set, inclusive of the child set \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles} & Pointer to array of child sets returned from function \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Data@{i\+Geom\+\_\+get\+Data}}
\index{i\+Geom\+\_\+get\+Data@{i\+Geom\+\_\+get\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iGeom_getData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, char **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ad26f68498573769d51600ebfc8095df3}{}\label{i_geom_8h_ad26f68498573769d51600ebfc8095df3}


Get the value of a tag of arbitrary type on an entity. 

Get the value of a tag of arbitrary type on an entity. Tag data is passed back as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being queried \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+allocated} & Pointer to tag data array allocated size \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+size} & Pointer to tag data array occupied size \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Dbl\+Arr\+Data@{i\+Geom\+\_\+get\+Dbl\+Arr\+Data}}
\index{i\+Geom\+\_\+get\+Dbl\+Arr\+Data@{i\+Geom\+\_\+get\+Dbl\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Dbl\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_getDblArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, double **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Dbl\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a027f197cce68791a816c4b2ab27d26b0}{}\label{i_geom_8h_a027f197cce68791a816c4b2ab27d26b0}


Get tag values of double type for an array of entities. 

Get tag values of double type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Dbl\+Data@{i\+Geom\+\_\+get\+Dbl\+Data}}
\index{i\+Geom\+\_\+get\+Dbl\+Data@{i\+Geom\+\_\+get\+Dbl\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Dbl\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, const i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getDblData(iGeom_Instance instance, const iBase_EntityHandle entity_handle, const iBase_TagHandle tag_handle, double *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abbcdf6c67a5a21262c2150aaa7fc958d}{}\label{i_geom_8h_abbcdf6c67a5a21262c2150aaa7fc958d}


Get the value of a tag of double type on an entity. 

Get the value of a tag of double type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Description@{i\+Geom\+\_\+get\+Description}}
\index{i\+Geom\+\_\+get\+Description@{i\+Geom\+\_\+get\+Description}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Description(i\+Geom\+\_\+\+Instance instance, char $\ast$descr, int $\ast$err, int descr\+\_\+len)}{iGeom_getDescription(iGeom_Instance instance, char *descr, int *err, int descr_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Description (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{char $\ast$}]{descr, }
\item[{int $\ast$}]{err, }
\item[{int}]{descr\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a738d7ef1b443d48cad1a1c6e588f904d}{}\label{i_geom_8h_a738d7ef1b443d48cad1a1c6e588f904d}


Get a description of the error returned from the last i\+Geom function. 

Get a description of the error returned from the last i\+Geom function 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em descr} & Pointer to a character string to be filled with a description of the error from the last i\+Geom function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em descr\+\_\+len} & Length of the character string pointed to by descr \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle edge\+\_\+handle, double x, double y, double z, double $\ast$cvtr\+\_\+i, double $\ast$cvtr\+\_\+j, double $\ast$cvtr\+\_\+k, int $\ast$err)}{iGeom_getEgCvtrXYZ(iGeom_Instance, iBase_EntityHandle edge_handle, double x, double y, double z, double *cvtr_i, double *cvtr_j, double *cvtr_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Cvtr\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{cvtr\+\_\+i, }
\item[{double $\ast$}]{cvtr\+\_\+j, }
\item[{double $\ast$}]{cvtr\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a35a5beee2e8f57d2ab198e510aef0fd9}{}\label{i_geom_8h_a35a5beee2e8f57d2ab198e510aef0fd9}


Get the principle curvature vector for an edge at a point Get the principle curvature vector for an edge at a point. Magnitude of vector is the curvature, direction is direction of principal curvature. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handle} & Edge being queried \\
\hline
{\em x} & Position being queried \\
\hline
{\em y} & Position being queried \\
\hline
{\em z} & Position being queried \\
\hline
{\em cvtr\+\_\+i} & Maximum curvature vector \\
\hline
{\em cvtr\+\_\+j} & Maximum curvature vector \\
\hline
{\em cvtr\+\_\+k} & Maximum curvature vector \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Eval\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle edge\+\_\+handle, double x, double y, double z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, double $\ast$cvtr\+\_\+i, double $\ast$cvtr\+\_\+j, double $\ast$cvtr\+\_\+k, int $\ast$err)}{iGeom_getEgEvalXYZ(iGeom_Instance, iBase_EntityHandle edge_handle, double x, double y, double z, double *on_x, double *on_y, double *on_z, double *tgnt_i, double *tgnt_j, double *tgnt_k, double *cvtr_i, double *cvtr_j, double *cvtr_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Eval\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{on\+\_\+x, }
\item[{double $\ast$}]{on\+\_\+y, }
\item[{double $\ast$}]{on\+\_\+z, }
\item[{double $\ast$}]{tgnt\+\_\+i, }
\item[{double $\ast$}]{tgnt\+\_\+j, }
\item[{double $\ast$}]{tgnt\+\_\+k, }
\item[{double $\ast$}]{cvtr\+\_\+i, }
\item[{double $\ast$}]{cvtr\+\_\+j, }
\item[{double $\ast$}]{cvtr\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aac2be634a37fd55386cd4f177118c4aa}{}\label{i_geom_8h_aac2be634a37fd55386cd4f177118c4aa}


Get closest point, tangent, and curvature of edge Get closest point, tangent, and curvature of edge. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handle} & Edge being queried \\
\hline
{\em x} & Point at which entity is being queried \\
\hline
{\em y} & Point at which entity is being queried \\
\hline
{\em z} & Point at which entity is being queried \\
\hline
{\em on\+\_\+x} & Closest point at point being queried \\
\hline
{\em on\+\_\+y} & Closest point at point being queried \\
\hline
{\em on\+\_\+z} & Closest point at point being queried \\
\hline
{\em tgnt\+\_\+i} & Tangent at point being queried \\
\hline
{\em tgnt\+\_\+j} & Tangent at point being queried \\
\hline
{\em tgnt\+\_\+k} & Tangent at point being queried \\
\hline
{\em cvtr\+\_\+i} & Curvature at point being queried \\
\hline
{\em cvtr\+\_\+j} & Curvature at point being queried \\
\hline
{\em cvtr\+\_\+k} & Curvature at point being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense@{i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense}}
\index{i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense@{i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)}{iGeom_getEgFcArrSense(iGeom_Instance, iBase_EntityHandle const *edge_handles, int edge_handles_size, iBase_EntityHandle const *face_handles, int face_handles_size, int **sense, int *sense_allocated, int *sense_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Fc\+Arr\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{sense, }
\item[{int $\ast$}]{sense\+\_\+allocated, }
\item[{int $\ast$}]{sense\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_afcc11d8da6bca1a6717315d4903f3855}{}\label{i_geom_8h_afcc11d8da6bca1a6717315d4903f3855}


Get the senses of an array of edges with respect to an array of faces Get the senses of an array of edges with respect to an array of faces. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that edge bounds the face once with each sense. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handles} & Edges being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Size of edge handles array \\
\hline
{\em face\+\_\+handles} & Faces being queried \\
\hline
{\em face\+\_\+handles\+\_\+size} & Size of face handles array \\
\hline
{\em sense} & Senses of faces with respect to regions \\
\hline
{\em sense\+\_\+allocated} & Allocated size of senses array \\
\hline
{\em sense\+\_\+size} & Occupied size of senses array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Fc\+Sense@{i\+Geom\+\_\+get\+Eg\+Fc\+Sense}}
\index{i\+Geom\+\_\+get\+Eg\+Fc\+Sense@{i\+Geom\+\_\+get\+Eg\+Fc\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Fc\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle edge, i\+Base\+\_\+\+Entity\+Handle face, int $\ast$sense\+\_\+out, int $\ast$err)}{iGeom_getEgFcSense(iGeom_Instance, iBase_EntityHandle edge, iBase_EntityHandle face, int *sense_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Fc\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face, }
\item[{int $\ast$}]{sense\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a87e8f0e8da6adda7fbedc6c1c5d831d7}{}\label{i_geom_8h_a87e8f0e8da6adda7fbedc6c1c5d831d7}


Get the sense of an edge with respect to a face Get the sense of an edge with respect to a face. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that edge bounds the face once with each sense. 


\begin{DoxyParams}{Parameters}
{\em edge} & Edge being queried \\
\hline
{\em face} & Face being queried \\
\hline
{\em sense\+\_\+out} & Sense of edge with respect to face \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense@{i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense}}
\index{i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense@{i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$vertex\+\_\+handles\+\_\+1, int veretx\+\_\+handles\+\_\+1\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$vertex\+\_\+handles\+\_\+2, int vertex\+\_\+handles\+\_\+2\+\_\+size, int $\ast$$\ast$sense, int $\ast$sense\+\_\+allocated, int $\ast$sense\+\_\+size, int $\ast$err)}{iGeom_getEgVtxArrSense(iGeom_Instance, iBase_EntityHandle const *edge_handles, int edge_handles_size, iBase_EntityHandle const *vertex_handles_1, int veretx_handles_1_size, iBase_EntityHandle const *vertex_handles_2, int vertex_handles_2_size, int **sense, int *sense_allocated, int *sense_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Vtx\+Arr\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{vertex\+\_\+handles\+\_\+1, }
\item[{int}]{veretx\+\_\+handles\+\_\+1\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{vertex\+\_\+handles\+\_\+2, }
\item[{int}]{vertex\+\_\+handles\+\_\+2\+\_\+size, }
\item[{int $\ast$$\ast$}]{sense, }
\item[{int $\ast$}]{sense\+\_\+allocated, }
\item[{int $\ast$}]{sense\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a34aeb1cb4fe4d2a99ea87fd1f5ec5fd9}{}\label{i_geom_8h_a34aeb1cb4fe4d2a99ea87fd1f5ec5fd9}


Get the senses of vertex pair with respect to a edges Get the senses of vertex pairs with respect to edges. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that both vertices in pair are identical and that vertex bounds both sides of the edge. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handles} & Edges being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Number of edges being queried \\
\hline
{\em vertex\+\_\+handles\+\_\+1} & First vertex being queried \\
\hline
{\em vertex\+\_\+handles\+\_\+1\+\_\+size} & Number of vertices in vertices array \\
\hline
{\em vertex\+\_\+handles\+\_\+2} & Second vertex being queried \\
\hline
{\em vertex\+\_\+handles\+\_\+2\+\_\+size} & Number of vertices in vertices array \\
\hline
{\em sense} & Sense of vertex pair with respect to edge \\
\hline
{\em sense\+\_\+allocated} & Allocated size of sense array \\
\hline
{\em sense\+\_\+size} & Occupied size of sense array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Eg\+Vtx\+Sense@{i\+Geom\+\_\+get\+Eg\+Vtx\+Sense}}
\index{i\+Geom\+\_\+get\+Eg\+Vtx\+Sense@{i\+Geom\+\_\+get\+Eg\+Vtx\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Eg\+Vtx\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle edge, i\+Base\+\_\+\+Entity\+Handle vertex1, i\+Base\+\_\+\+Entity\+Handle vertex2, int $\ast$sense\+\_\+out, int $\ast$err)}{iGeom_getEgVtxSense(iGeom_Instance, iBase_EntityHandle edge, iBase_EntityHandle vertex1, iBase_EntityHandle vertex2, int *sense_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Eg\+Vtx\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex2, }
\item[{int $\ast$}]{sense\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a5b8e67c45ea4ca9ea5371035b3e6e3ff}{}\label{i_geom_8h_a5b8e67c45ea4ca9ea5371035b3e6e3ff}


Get the sense of a vertex pair with respect to an edge Get the sense of a vertex pair with respect to an edge. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that vertices are identical and that vertex bounds both sides of the edge. 


\begin{DoxyParams}{Parameters}
{\em edge} & Edge being queried \\
\hline
{\em vertex1} & First vertex being queried \\
\hline
{\em vertex2} & Second vertex being queried \\
\hline
{\em sense\+\_\+out} & Sense of vertex pair with respect to edge \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+E\+H\+Arr\+Data@{i\+Geom\+\_\+get\+E\+H\+Arr\+Data}}
\index{i\+Geom\+\_\+get\+E\+H\+Arr\+Data@{i\+Geom\+\_\+get\+E\+H\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+E\+H\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iGeom_getEHArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, iBase_EntityHandle **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+E\+H\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af4be8ff6828c1160b8421885b6658ee5}{}\label{i_geom_8h_af4be8ff6828c1160b8421885b6658ee5}


Get tag values of entity handle type for an array of entities. 

Get tag values of entity handle type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being returned from function \\
\hline
{\em tag\+\_\+value\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+value\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+E\+H\+Data@{i\+Geom\+\_\+get\+E\+H\+Data}}
\index{i\+Geom\+\_\+get\+E\+H\+Data@{i\+Geom\+\_\+get\+E\+H\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+E\+H\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getEHData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, iBase_EntityHandle *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8c9df25475f6787939adf8930d436ed1}{}\label{i_geom_8h_a8c9df25475f6787939adf8930d436ed1}


Get the value of a tag of entity handle type on an entity. 

Get the value of a tag of entity handle type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent1st\+Drvt@{i\+Geom\+\_\+get\+Ent1st\+Drvt}}
\index{i\+Geom\+\_\+get\+Ent1st\+Drvt@{i\+Geom\+\_\+get\+Ent1st\+Drvt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent1st\+Drvt(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double v, double $\ast$$\ast$drvt\+\_\+u, int $\ast$drvt\+\_\+u\+\_\+allocated, int $\ast$drvt\+\_\+u\+\_\+size, double $\ast$$\ast$drvt\+\_\+v, int $\ast$dvrt\+\_\+v\+\_\+allocated, int $\ast$dvrt\+\_\+v\+\_\+size, int $\ast$err)}{iGeom_getEnt1stDrvt(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double v, double **drvt_u, int *drvt_u_allocated, int *drvt_u_size, double **drvt_v, int *dvrt_v_allocated, int *dvrt_v_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent1st\+Drvt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double}]{v, }
\item[{double $\ast$$\ast$}]{drvt\+\_\+u, }
\item[{int $\ast$}]{drvt\+\_\+u\+\_\+allocated, }
\item[{int $\ast$}]{drvt\+\_\+u\+\_\+size, }
\item[{double $\ast$$\ast$}]{drvt\+\_\+v, }
\item[{int $\ast$}]{dvrt\+\_\+v\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+v\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a1d9e2832dd5a74c8160862ef40881e15}{}\label{i_geom_8h_a1d9e2832dd5a74c8160862ef40881e15}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent2nd\+Adj@{i\+Geom\+\_\+get\+Ent2nd\+Adj}}
\index{i\+Geom\+\_\+get\+Ent2nd\+Adj@{i\+Geom\+\_\+get\+Ent2nd\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent2nd\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int bridge\+\_\+dimension, int to\+\_\+dimension, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adjacent\+\_\+entities, int $\ast$adjacent\+\_\+entities\+\_\+allocated, int $\ast$adjacent\+\_\+entities\+\_\+size, int $\ast$err)}{iGeom_getEnt2ndAdj(iGeom_Instance instance, iBase_EntityHandle entity_handle, int bridge_dimension, int to_dimension, iBase_EntityHandle **adjacent_entities, int *adjacent_entities_allocated, int *adjacent_entities_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent2nd\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int}]{bridge\+\_\+dimension, }
\item[{int}]{to\+\_\+dimension, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adjacent\+\_\+entities, }
\item[{int $\ast$}]{adjacent\+\_\+entities\+\_\+allocated, }
\item[{int $\ast$}]{adjacent\+\_\+entities\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ab8632165533ea43bfd6c4e69aaade6e3}{}\label{i_geom_8h_ab8632165533ea43bfd6c4e69aaade6e3}


Get \char`\"{}2nd order\char`\"{} adjacencies to an entity Get \char`\"{}2nd order\char`\"{} adjacencies to an entity, that is, from an entity, through other entities of a specified \char`\"{}bridge\char`\"{} dimension, to other entities of another specified \char`\"{}to\char`\"{} dimension. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity from which adjacencies are requested \\
\hline
{\em bridge\+\_\+dimension} & Bridge dimension for 2nd order adjacencies \\
\hline
{\em to\+\_\+dimension} & Dimension of adjacent entities returned \\
\hline
{\em adjacent\+\_\+entities} & Adjacent entities \\
\hline
{\em adjacent\+\_\+entities\+\_\+allocated} & Allocated size of returned array \\
\hline
{\em adjacent\+\_\+entities\+\_\+size} & Occupied size of returned array \\
\hline
{\em err} & \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent2nd\+Drvt@{i\+Geom\+\_\+get\+Ent2nd\+Drvt}}
\index{i\+Geom\+\_\+get\+Ent2nd\+Drvt@{i\+Geom\+\_\+get\+Ent2nd\+Drvt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent2nd\+Drvt(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double v, double $\ast$$\ast$drvt\+\_\+uu, int $\ast$drvt\+\_\+uu\+\_\+allocated, int $\ast$drvt\+\_\+uu\+\_\+size, double $\ast$$\ast$drvt\+\_\+vv, int $\ast$dvrt\+\_\+vv\+\_\+allocated, int $\ast$dvrt\+\_\+vv\+\_\+size, double $\ast$$\ast$drvt\+\_\+uv, int $\ast$dvrt\+\_\+uv\+\_\+allocated, int $\ast$dvrt\+\_\+uv\+\_\+size, int $\ast$err)}{iGeom_getEnt2ndDrvt(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double v, double **drvt_uu, int *drvt_uu_allocated, int *drvt_uu_size, double **drvt_vv, int *dvrt_vv_allocated, int *dvrt_vv_size, double **drvt_uv, int *dvrt_uv_allocated, int *dvrt_uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent2nd\+Drvt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double}]{v, }
\item[{double $\ast$$\ast$}]{drvt\+\_\+uu, }
\item[{int $\ast$}]{drvt\+\_\+uu\+\_\+allocated, }
\item[{int $\ast$}]{drvt\+\_\+uu\+\_\+size, }
\item[{double $\ast$$\ast$}]{drvt\+\_\+vv, }
\item[{int $\ast$}]{dvrt\+\_\+vv\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+vv\+\_\+size, }
\item[{double $\ast$$\ast$}]{drvt\+\_\+uv, }
\item[{int $\ast$}]{dvrt\+\_\+uv\+\_\+allocated, }
\item[{int $\ast$}]{dvrt\+\_\+uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a65b6a3336691d76db5b9e3ae7f49f022}{}\label{i_geom_8h_a65b6a3336691d76db5b9e3ae7f49f022}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Adj@{i\+Geom\+\_\+get\+Ent\+Adj}}
\index{i\+Geom\+\_\+get\+Ent\+Adj@{i\+Geom\+\_\+get\+Ent\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int to\+\_\+dimension, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$adj\+\_\+entities, int $\ast$adj\+\_\+entities\+\_\+allocated, int $\ast$adj\+\_\+entities\+\_\+size, int $\ast$err)}{iGeom_getEntAdj(iGeom_Instance instance, iBase_EntityHandle entity_handle, int to_dimension, iBase_EntityHandle **adj_entities, int *adj_entities_allocated, int *adj_entities_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int}]{to\+\_\+dimension, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{adj\+\_\+entities, }
\item[{int $\ast$}]{adj\+\_\+entities\+\_\+allocated, }
\item[{int $\ast$}]{adj\+\_\+entities\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_adbc0f5b5136eb18a2824ccae1184b24e}{}\label{i_geom_8h_adbc0f5b5136eb18a2824ccae1184b24e}


Get entities of specified type adjacent to an entity. 

Get entities of specified type adjacent to an entity. Specified type must be value in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity handle being queried \\
\hline
{\em entity\+\_\+type\+\_\+requested} & Type of adjacent entities requested \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles} & Pointer to array of adjacent entities returned from function \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of adj\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$adj\+\_\+entity\+\_\+handles\+\_\+size} & Pointer to occupied size of adj\+\_\+entity\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, double $\ast$$\ast$cvtr\+\_\+1, int $\ast$cvtr\+\_\+1\+\_\+allocated, int $\ast$cvtr\+\_\+1\+\_\+size, double $\ast$$\ast$cvtr\+\_\+2, int $\ast$cvtr\+\_\+2\+\_\+allocated, int $\ast$cvtr\+\_\+2\+\_\+size, int $\ast$err)}{iGeom_getEntArrCvtrXYZ(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double const *coords, int coords_size, double **cvtr_1, int *cvtr_1_allocated, int *cvtr_1_size, double **cvtr_2, int *cvtr_2_allocated, int *cvtr_2_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Arr\+Cvtr\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr\+\_\+1, }
\item[{int $\ast$}]{cvtr\+\_\+1\+\_\+allocated, }
\item[{int $\ast$}]{cvtr\+\_\+1\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr\+\_\+2, }
\item[{int $\ast$}]{cvtr\+\_\+2\+\_\+allocated, }
\item[{int $\ast$}]{cvtr\+\_\+2\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a2edc7c8e243f1c7ec06bc933d411b8ca}{}\label{i_geom_8h_a2edc7c8e243f1c7ec06bc933d411b8ca}


Get the curvature(s) on an entity(ies) at given position(s) Get the curvature(s) on an entity(ies) at given position(s). If either the number of entities or number of coordinate triples is unity, then all points or entities are queried for that entity or point, respectively, otherwise each point corresponds to each entity. storage\+\_\+order should be a value in the i\+Base\+\_\+\+Storage\+Order enum; if input as i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entity(ies) being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates \\
\hline
{\em coords} & Starting coordinates \\
\hline
{\em coords\+\_\+size} & Number of values in coordinates array \\
\hline
{\em cvtr\+\_\+1} & First principal curvatures \\
\hline
{\em cvtr\+\_\+1\+\_\+allocated} & Allocated size of first curvature array \\
\hline
{\em cvtr\+\_\+1\+\_\+size} & Occupied size of first curvature array \\
\hline
{\em cvtr\+\_\+2} & Second principal curvatures \\
\hline
{\em cvtr\+\_\+2\+\_\+allocated} & Allocated size of second curvature array \\
\hline
{\em cvtr\+\_\+2\+\_\+size} & Occupied size of second curvature array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Bound\+Box@{i\+Geom\+\_\+get\+Ent\+Bound\+Box}}
\index{i\+Geom\+\_\+get\+Ent\+Bound\+Box@{i\+Geom\+\_\+get\+Ent\+Bound\+Box}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Bound\+Box(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double $\ast$min\+\_\+x, double $\ast$min\+\_\+y, double $\ast$min\+\_\+z, double $\ast$max\+\_\+x, double $\ast$max\+\_\+y, double $\ast$max\+\_\+z, int $\ast$err)}{iGeom_getEntBoundBox(iGeom_Instance, iBase_EntityHandle entity_handle, double *min_x, double *min_y, double *min_z, double *max_x, double *max_y, double *max_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Bound\+Box (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double $\ast$}]{min\+\_\+x, }
\item[{double $\ast$}]{min\+\_\+y, }
\item[{double $\ast$}]{min\+\_\+z, }
\item[{double $\ast$}]{max\+\_\+x, }
\item[{double $\ast$}]{max\+\_\+y, }
\item[{double $\ast$}]{max\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a826d59e82b978a4a552274c3e799790b}{}\label{i_geom_8h_a826d59e82b978a4a552274c3e799790b}


Get the bounding box of the specified entity Get the bounding box of the specified entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em min\+\_\+x} & Minimum coordinate of bounding box \\
\hline
{\em min\+\_\+y} & Minimum coordinate of bounding box \\
\hline
{\em min\+\_\+z} & Minimum coordinate of bounding box \\
\hline
{\em max\+\_\+x} & Maximum coordinate of bounding box \\
\hline
{\em max\+\_\+y} & Maximum coordinate of bounding box \\
\hline
{\em max\+\_\+z} & Maximum coordinate of bounding box \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Closest\+Pt@{i\+Geom\+\_\+get\+Ent\+Closest\+Pt}}
\index{i\+Geom\+\_\+get\+Ent\+Closest\+Pt@{i\+Geom\+\_\+get\+Ent\+Closest\+Pt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Closest\+Pt(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double near\+\_\+x, double near\+\_\+y, double near\+\_\+z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, int $\ast$err)}{iGeom_getEntClosestPt(iGeom_Instance instance, iBase_EntityHandle entity_handle, double near_x, double near_y, double near_z, double *on_x, double *on_y, double *on_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Closest\+Pt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{near\+\_\+x, }
\item[{double}]{near\+\_\+y, }
\item[{double}]{near\+\_\+z, }
\item[{double $\ast$}]{on\+\_\+x, }
\item[{double $\ast$}]{on\+\_\+y, }
\item[{double $\ast$}]{on\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7510001cd9212a4e80c58467dd5e6a8d}{}\label{i_geom_8h_a7510001cd9212a4e80c58467dd5e6a8d}


Get closest point to an entity Get closest point to a specified position on an entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em near\+\_\+x} & Coordinates of starting point \\
\hline
{\em near\+\_\+y} & Coordinates of starting point \\
\hline
{\em near\+\_\+z} & Coordinates of starting point \\
\hline
{\em on\+\_\+x} & Closest point on entity \\
\hline
{\em on\+\_\+y} & Closest point on entity \\
\hline
{\em on\+\_\+z} & Closest point on entity \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Entities@{i\+Geom\+\_\+get\+Entities}}
\index{i\+Geom\+\_\+get\+Entities@{i\+Geom\+\_\+get\+Entities}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Entities(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle set\+\_\+handle, int entity\+\_\+type, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allococated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getEntities(iGeom_Instance instance, iBase_EntitySetHandle set_handle, int entity_type, iBase_EntityHandle **entity_handles, int *entity_handles_allococated, int *entity_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Entities (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{set\+\_\+handle, }
\item[{int}]{entity\+\_\+type, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allococated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a1cd563e02b32f56e21bde64299a0492c}{}\label{i_geom_8h_a1cd563e02b32f56e21bde64299a0492c}


Get entities of specific type and/or topology in set or instance. 

Get entities of specific type and/or topology in set or instance. All entities of a given type or topology are requested by specifying i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES or i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Base\+\_\+\+Entity\+Topology enumeration, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em entity\+\_\+type} & Type of entities being requested \\
\hline
{\em entity\+\_\+topology} & Topology of entities being requested \\
\hline
{\em $\ast$entity\+\_\+handles} & Pointer to array of entity handles returned from function \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$pt\+\_\+x, double $\ast$pt\+\_\+y, double $\ast$pt\+\_\+z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)}{iGeom_getEntNrmlPlXYZ(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *pt_x, double *pt_y, double *pt_z, double *nrml_i, double *nrml_j, double *nrml_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Nrml\+Pl\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{pt\+\_\+x, }
\item[{double $\ast$}]{pt\+\_\+y, }
\item[{double $\ast$}]{pt\+\_\+z, }
\item[{double $\ast$}]{nrml\+\_\+i, }
\item[{double $\ast$}]{nrml\+\_\+j, }
\item[{double $\ast$}]{nrml\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8326905f53bee45c81e759282ae57791}{}\label{i_geom_8h_a8326905f53bee45c81e759282ae57791}


Get the normal vector A\+ND closest point on an entity at given position Get the normal vector A\+ND closest point on an entity at a given position. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Starting coordinates \\
\hline
{\em y} & Starting coordinates \\
\hline
{\em z} & Starting coordinates \\
\hline
{\em pt\+\_\+x} & Closest point \\
\hline
{\em pt\+\_\+y} & Closest point \\
\hline
{\em pt\+\_\+z} & Closest point \\
\hline
{\em nrml\+\_\+i} & Normal at closest point \\
\hline
{\em nrml\+\_\+j} & Normal at closest point \\
\hline
{\em nrml\+\_\+k} & Normal at closest point \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Nrml\+Sense@{i\+Geom\+\_\+get\+Ent\+Nrml\+Sense}}
\index{i\+Geom\+\_\+get\+Ent\+Nrml\+Sense@{i\+Geom\+\_\+get\+Ent\+Nrml\+Sense}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Nrml\+Sense(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle face, i\+Base\+\_\+\+Entity\+Handle region, int $\ast$sense\+\_\+out, int $\ast$err)}{iGeom_getEntNrmlSense(iGeom_Instance, iBase_EntityHandle face, iBase_EntityHandle region, int *sense_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Nrml\+Sense (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{region, }
\item[{int $\ast$}]{sense\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac33dcbb6c5f2deee0560cfd729fc40f3}{}\label{i_geom_8h_ac33dcbb6c5f2deee0560cfd729fc40f3}


Get the sense of a face with respect to a region Get the sense of a face with respect to a region. Sense returned is -\/1, 0, or 1, representing \char`\"{}reversed\char`\"{}, \char`\"{}both\char`\"{}, or \char`\"{}forward\char`\"{}. \char`\"{}both\char`\"{} sense indicates that face bounds the region once with each sense. 


\begin{DoxyParams}{Parameters}
{\em face} & Face being queried \\
\hline
{\em region} & Region being queried \\
\hline
{\em sense\+\_\+out} & Sense of face with respect to region \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Nrml\+UV@{i\+Geom\+\_\+get\+Ent\+Nrml\+UV}}
\index{i\+Geom\+\_\+get\+Ent\+Nrml\+UV@{i\+Geom\+\_\+get\+Ent\+Nrml\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Nrml\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double v, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)}{iGeom_getEntNrmlUV(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double v, double *nrml_i, double *nrml_j, double *nrml_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Nrml\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double}]{v, }
\item[{double $\ast$}]{nrml\+\_\+i, }
\item[{double $\ast$}]{nrml\+\_\+j, }
\item[{double $\ast$}]{nrml\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ae2fc2aa8c509922d230d027bbf88e2b9}{}\label{i_geom_8h_ae2fc2aa8c509922d230d027bbf88e2b9}


Return the normal at a specified parametric position Return the normal at a specified parametric position. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u} & Parametric position being queried \\
\hline
{\em v} & Parametric position being queried \\
\hline
{\em nrml\+\_\+i} & Normal at specified position \\
\hline
{\em nrml\+\_\+j} & Normal at specified position \\
\hline
{\em nrml\+\_\+k} & Normal at specified position \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Nrml\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, int $\ast$err)}{iGeom_getEntNrmlXYZ(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *nrml_i, double *nrml_j, double *nrml_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Nrml\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{nrml\+\_\+i, }
\item[{double $\ast$}]{nrml\+\_\+j, }
\item[{double $\ast$}]{nrml\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a17bf7ab2a20eba43ef779ac28bed6522}{}\label{i_geom_8h_a17bf7ab2a20eba43ef779ac28bed6522}


Get the normal vector on an entity at the given position Get the normal vector on an entity at the given position. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Coordinates of starting point \\
\hline
{\em y} & Coordinates of starting point \\
\hline
{\em z} & Coordinates of starting point \\
\hline
{\em nrml\+\_\+i} & Normal vector at starting point \\
\hline
{\em nrml\+\_\+j} & Normal vector at starting point \\
\hline
{\em nrml\+\_\+k} & Normal vector at starting point \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Set\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Data}}
\index{i\+Geom\+\_\+get\+Ent\+Set\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Set\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$$\ast$tag\+\_\+value, int $\ast$tag\+\_\+value\+\_\+allocated, int $\ast$tag\+\_\+value\+\_\+size, int $\ast$err)}{iGeom_getEntSetData(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, iBase_TagHandle tag_handle, char **tag_value, int *tag_value_allocated, int *tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$$\ast$}]{tag\+\_\+value, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af4964d23422c1242d82824ebcf4db9e8}{}\label{i_geom_8h_af4964d23422c1242d82824ebcf4db9e8}


Get the value of a tag of arbitrary type on an entity set. 

Get the value of a tag of arbitrary type on an entity set. Tag data is passed back as char$\ast$ type, but really represents arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$tag\+\_\+value} & Pointer to tag data array being queried \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+allocated} & Pointer to tag data array allocated size \\
\hline
{\em $\ast$tag\+\_\+value\+\_\+size} & Pointer to tag data array occupied size \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data}}
\index{i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getEntSetDblData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, double *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4e9def652e9d22051b54914b3612cd56}{}\label{i_geom_8h_a4e9def652e9d22051b54914b3612cd56}


Get the value of a tag of double type on an entity set. 

Get the value of a tag of double type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data}}
\index{i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getEntSetEHData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, iBase_EntityHandle *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a6e9d84db3b24e17e297f48f71f02a779}{}\label{i_geom_8h_a6e9d84db3b24e17e297f48f71f02a779}


Get the value of a tag of entity handle type on an entity set. 

Get the value of a tag of entity handle type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data}}
\index{i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data@{i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getEntSetIntData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, int *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a39e24e464e00976959636378b45a83ca}{}\label{i_geom_8h_a39e24e464e00976959636378b45a83ca}


Get the value of a tag of integer type on an entity set. 

Get the value of a tag of integer type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Sets@{i\+Geom\+\_\+get\+Ent\+Sets}}
\index{i\+Geom\+\_\+get\+Ent\+Sets@{i\+Geom\+\_\+get\+Ent\+Sets}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Sets(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$contained\+\_\+set\+\_\+handles, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$contained\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getEntSets(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, int num_hops, iBase_EntitySetHandle **contained_set_handles, int *contained_set_handles_allocated, int *contained_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Sets (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{contained\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{contained\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{contained\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a09943820467db183cff879e66a11553c}{}\label{i_geom_8h_a09943820467db183cff879e66a11553c}


Get the entity sets contained in a set or interface. 

Get the entity sets contained in a set or interface. If a set is input which is not the root set, num\+\_\+hops indicates the maximum number of contained sets from entity\+\_\+set\+\_\+handle to one of the contained sets, inclusive of the contained set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to contained set, inclusive of the contained set \\
\hline
{\em $\ast$contained\+\_\+set\+\_\+handles} & Pointer to array of set handles returned from function \\
\hline
{\em contained\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated length of contained\+\_\+set\+\_\+handles array \\
\hline
{\em contained\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied length of contained\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+TgntU@{i\+Geom\+\_\+get\+Ent\+TgntU}}
\index{i\+Geom\+\_\+get\+Ent\+TgntU@{i\+Geom\+\_\+get\+Ent\+TgntU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Tgnt\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, int $\ast$err)}{iGeom_getEntTgntU(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double *tgnt_i, double *tgnt_j, double *tgnt_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+TgntU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double $\ast$}]{tgnt\+\_\+i, }
\item[{double $\ast$}]{tgnt\+\_\+j, }
\item[{double $\ast$}]{tgnt\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4dd7584d76fca7339150c7a22dace063}{}\label{i_geom_8h_a4dd7584d76fca7339150c7a22dace063}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$tgnt\+\_\+i, double $\ast$tgnt\+\_\+j, double $\ast$tgnt\+\_\+k, int $\ast$err)}{iGeom_getEntTgntXYZ(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *tgnt_i, double *tgnt_j, double *tgnt_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Tgnt\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{tgnt\+\_\+i, }
\item[{double $\ast$}]{tgnt\+\_\+j, }
\item[{double $\ast$}]{tgnt\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a496337ad617a6bb60ba4ac7ebc9c0a87}{}\label{i_geom_8h_a496337ad617a6bb60ba4ac7ebc9c0a87}


Get the tangent vector on an entity at given position Get the tangent vector on an entity at a given position. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Starting coordinates \\
\hline
{\em y} & Starting coordinates \\
\hline
{\em z} & Starting coordinates \\
\hline
{\em tgnt\+\_\+i} & Tangent at closest point \\
\hline
{\em tgnt\+\_\+j} & Tangent at closest point \\
\hline
{\em tgnt\+\_\+k} & Tangent at closest point \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Tolerance@{i\+Geom\+\_\+get\+Ent\+Tolerance}}
\index{i\+Geom\+\_\+get\+Ent\+Tolerance@{i\+Geom\+\_\+get\+Ent\+Tolerance}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Tolerance(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double $\ast$tolerance, int $\ast$err)}{iGeom_getEntTolerance(iGeom_Instance, iBase_EntityHandle entity_handle, double *tolerance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Tolerance (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double $\ast$}]{tolerance, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ad63f1408d7cd8de28bcf0041b379276e}{}\label{i_geom_8h_ad63f1408d7cd8de28bcf0041b379276e}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Type@{i\+Geom\+\_\+get\+Ent\+Type}}
\index{i\+Geom\+\_\+get\+Ent\+Type@{i\+Geom\+\_\+get\+Ent\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Type(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$type, int $\ast$err)}{iGeom_getEntType(iGeom_Instance instance, iBase_EntityHandle entity_handle, int *type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac339424fe3304b05c2cd57c886880664}{}\label{i_geom_8h_ac339424fe3304b05c2cd57c886880664}


Get the entity type for the specified entity. 

Get the entity type for the specified entity. Types returned are values in the i\+Base\+\_\+\+Entity\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & entity handle being queried \\
\hline
{\em $\ast$type} & Pointer to location at which to store the returned type \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+U\+Range@{i\+Geom\+\_\+get\+Ent\+U\+Range}}
\index{i\+Geom\+\_\+get\+Ent\+U\+Range@{i\+Geom\+\_\+get\+Ent\+U\+Range}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+U\+Range(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double $\ast$u\+\_\+min, double $\ast$u\+\_\+max, int $\ast$err)}{iGeom_getEntURange(iGeom_Instance, iBase_EntityHandle entity_handle, double *u_min, double *u_max, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+U\+Range (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double $\ast$}]{u\+\_\+min, }
\item[{double $\ast$}]{u\+\_\+max, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9cd1cd2870eb934927323660c7ee64f1}{}\label{i_geom_8h_a9cd1cd2870eb934927323660c7ee64f1}


Get parametric range of entity Get parametric range of entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u\+\_\+min} & Minimum parametric coordinate for entity \\
\hline
{\em u\+\_\+max} & Maximum parametric coordinate for entity \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Uto\+UV@{i\+Geom\+\_\+get\+Ent\+Uto\+UV}}
\index{i\+Geom\+\_\+get\+Ent\+Uto\+UV@{i\+Geom\+\_\+get\+Ent\+Uto\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Uto\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle edge\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, double in\+\_\+u, double $\ast$u, double $\ast$v, int $\ast$err)}{iGeom_getEntUtoUV(iGeom_Instance, iBase_EntityHandle edge_handle, iBase_EntityHandle face_handle, double in_u, double *u, double *v, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Uto\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{double}]{in\+\_\+u, }
\item[{double $\ast$}]{u, }
\item[{double $\ast$}]{v, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7f5eef6c746f4f4880681a381e8eef6c}{}\label{i_geom_8h_a7f5eef6c746f4f4880681a381e8eef6c}


Return the face parametric coordinates for a parametric position on a bounding edge Return the face parametric coordinates for a parametric position on a bounding edge. 


\begin{DoxyParams}{Parameters}
{\em edge\+\_\+handle} & Edge being queried \\
\hline
{\em face\+\_\+handle} & Face being queried \\
\hline
{\em in\+\_\+u} & Parametric position on edge \\
\hline
{\em u} & Corresponding parametric position on face \\
\hline
{\em v} & Corresponding parametric position on face \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+Uto\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)}{iGeom_getEntUtoXYZ(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double *x, double *y, double *z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+Uto\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double $\ast$}]{x, }
\item[{double $\ast$}]{y, }
\item[{double $\ast$}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ae04a7477f800d926ea39da9596081dc8}{}\label{i_geom_8h_ae04a7477f800d926ea39da9596081dc8}


Return coordinate position at specified parametric position on entity Return coordinate position at specified parametric position on entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u} & Parametric coordinate being queried \\
\hline
{\em x} & Spatial coordinate at parametric position being queried \\
\hline
{\em y} & Spatial coordinate at parametric position being queried \\
\hline
{\em z} & Spatial coordinate at parametric position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+U\+V\+Range@{i\+Geom\+\_\+get\+Ent\+U\+V\+Range}}
\index{i\+Geom\+\_\+get\+Ent\+U\+V\+Range@{i\+Geom\+\_\+get\+Ent\+U\+V\+Range}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+U\+V\+Range(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double $\ast$u\+\_\+min, double $\ast$v\+\_\+min, double $\ast$u\+\_\+max, double $\ast$v\+\_\+max, int $\ast$err)}{iGeom_getEntUVRange(iGeom_Instance, iBase_EntityHandle entity_handle, double *u_min, double *v_min, double *u_max, double *v_max, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+U\+V\+Range (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double $\ast$}]{u\+\_\+min, }
\item[{double $\ast$}]{v\+\_\+min, }
\item[{double $\ast$}]{u\+\_\+max, }
\item[{double $\ast$}]{v\+\_\+max, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4bd3337d7bfea040b518c31797f19842}{}\label{i_geom_8h_a4bd3337d7bfea040b518c31797f19842}


Get parametric range of entity Get parametric range of entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u\+\_\+min} & Minimum parametric coordinate for entity \\
\hline
{\em v\+\_\+min} & Minimum parametric coordinate for entity \\
\hline
{\em u\+\_\+max} & Maximum parametric coordinate for entity \\
\hline
{\em v\+\_\+max} & Maximum parametric coordinate for entity \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ@{i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double v, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)}{iGeom_getEntUVtoXYZ(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double v, double *x, double *y, double *z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+U\+Vto\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double}]{v, }
\item[{double $\ast$}]{x, }
\item[{double $\ast$}]{y, }
\item[{double $\ast$}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8f3df358020b7155ca51a254c17468d0}{}\label{i_geom_8h_a8f3df358020b7155ca51a254c17468d0}


Return coordinate position at specified parametric position on entity Return coordinate position at specified parametric position on entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em u} & Parametric coordinate being queried \\
\hline
{\em v} & Parametric coordinate being queried \\
\hline
{\em x} & Spatial coordinate at parametric position being queried \\
\hline
{\em y} & Spatial coordinate at parametric position being queried \\
\hline
{\em z} & Spatial coordinate at parametric position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU@{i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU}}
\index{i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU@{i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$u, int $\ast$err)}{iGeom_getEntXYZtoU(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *u, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+X\+Y\+ZtoU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{u, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a952c1c56035bfc9d67a456de12369559}{}\label{i_geom_8h_a952c1c56035bfc9d67a456de12369559}


Return parametric position at specified spatial position on entity Return parametric position at specified spatial position on entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Spatial coordinate being queried \\
\hline
{\em y} & Spatial coordinate being queried \\
\hline
{\em z} & Spatial coordinate being queried \\
\hline
{\em u} & Parametric coordinate at spatial position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV@{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV}}
\index{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV@{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$u, double $\ast$v, int $\ast$err)}{iGeom_getEntXYZtoUV(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *u, double *v, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{u, }
\item[{double $\ast$}]{v, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ae6ffe88fc59dfc7f740e40bfc679529a}{}\label{i_geom_8h_ae6ffe88fc59dfc7f740e40bfc679529a}


Return parametric position at specified spatial position on entity Return parametric position at specified spatial position on entity. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Spatial coordinate being queried \\
\hline
{\em y} & Spatial coordinate being queried \\
\hline
{\em z} & Spatial coordinate being queried \\
\hline
{\em u} & Parametric coordinate at spatial position being queried \\
\hline
{\em v} & Parametric coordinate at spatial position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint@{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint}}
\index{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint@{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double x, double y, double z, double $\ast$u, double $\ast$v, int $\ast$err)}{iGeom_getEntXYZtoUVHint(iGeom_Instance, iBase_EntityHandle entity_handle, double x, double y, double z, double *u, double *v, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Ent\+X\+Y\+Zto\+U\+V\+Hint (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{u, }
\item[{double $\ast$}]{v, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a379a2ec85f3e0961f8630a7c95819189}{}\label{i_geom_8h_a379a2ec85f3e0961f8630a7c95819189}


Return parametric position at specified spatial position on entity, based on parametric position hint Return parametric position at specified spatial position on entity, based on parametric position hint. For this function, u and v are input with parameters from which to start search. Typically this will reduce the search time for new parametric coordinates. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em x} & Spatial coordinate being queried \\
\hline
{\em y} & Spatial coordinate being queried \\
\hline
{\em z} & Spatial coordinate being queried \\
\hline
{\em u} & Parametric coordinate at spatial position being queried \\
\hline
{\em v} & Parametric coordinate at spatial position being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Error\+Type@{i\+Geom\+\_\+get\+Error\+Type}}
\index{i\+Geom\+\_\+get\+Error\+Type@{i\+Geom\+\_\+get\+Error\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Error\+Type(i\+Geom\+\_\+\+Instance instance, int $\ast$error\+\_\+type, int $\ast$err)}{iGeom_getErrorType(iGeom_Instance instance, int *error_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Error\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{error\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9b69f9cce1b427c056f936efc6c2a188}{}\label{i_geom_8h_a9b69f9cce1b427c056f936efc6c2a188}


Get the error type returned from the last i\+Geom function. 

Get the error type returned from the last i\+Geom function. Value returned is a member of the i\+Base\+\_\+\+Error\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em $\ast$error\+\_\+type} & Error type returned from last i\+Geom function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Face\+Type@{i\+Geom\+\_\+get\+Face\+Type}}
\index{i\+Geom\+\_\+get\+Face\+Type@{i\+Geom\+\_\+get\+Face\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Face\+Type(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, char $\ast$face\+\_\+type, int $\ast$err, int $\ast$face\+\_\+type\+\_\+length)}{iGeom_getFaceType(iGeom_Instance, iBase_EntityHandle face_handle, char *face_type, int *err, int *face_type_length)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Face\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{char $\ast$}]{face\+\_\+type, }
\item[{int $\ast$}]{err, }
\item[{int $\ast$}]{face\+\_\+type\+\_\+length}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abe32ef722f5323cd8a2ab5d00dbfaac8}{}\label{i_geom_8h_abe32ef722f5323cd8a2ab5d00dbfaac8}


Get the geometric type of an entity Get the geometric type of an entity. Specific types depend on implementation. 


\begin{DoxyParams}{Parameters}
{\em face\+\_\+handle} & Face being queried \\
\hline
{\em face\+\_\+type} & Face type \\
\hline
{\em face\+\_\+type\+\_\+length} & Length of face type string \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV@{i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV}}
\index{i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV@{i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double const $\ast$uv, int uv\+\_\+size, double $\ast$$\ast$cvtr\+\_\+1, int $\ast$cvtr\+\_\+1\+\_\+allocated, int $\ast$cvtr\+\_\+1\+\_\+size, double $\ast$$\ast$cvtr\+\_\+2, int $\ast$cvtr\+\_\+2\+\_\+allocated, int $\ast$cvtr\+\_\+2\+\_\+size, int $\ast$err)}{iGeom_getFcArrCvtrUV(iGeom_Instance, iBase_EntityHandle const *face_handles, int face_handles_size, int storage_order, double const *uv, int uv_size, double **cvtr_1, int *cvtr_1_allocated, int *cvtr_1_size, double **cvtr_2, int *cvtr_2_allocated, int *cvtr_2_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Fc\+Arr\+Cvtr\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{uv, }
\item[{int}]{uv\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr\+\_\+1, }
\item[{int $\ast$}]{cvtr\+\_\+1\+\_\+allocated, }
\item[{int $\ast$}]{cvtr\+\_\+1\+\_\+size, }
\item[{double $\ast$$\ast$}]{cvtr\+\_\+2, }
\item[{int $\ast$}]{cvtr\+\_\+2\+\_\+allocated, }
\item[{int $\ast$}]{cvtr\+\_\+2\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aad26e514e604bef87e2f87c5ae61a7ff}{}\label{i_geom_8h_aad26e514e604bef87e2f87c5ae61a7ff}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Fc\+Cvtr\+UV@{i\+Geom\+\_\+get\+Fc\+Cvtr\+UV}}
\index{i\+Geom\+\_\+get\+Fc\+Cvtr\+UV@{i\+Geom\+\_\+get\+Fc\+Cvtr\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Fc\+Cvtr\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, double u, double v, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)}{iGeom_getFcCvtrUV(iGeom_Instance, iBase_EntityHandle entity_handle, double u, double v, double *cvtr1_i, double *cvtr1_j, double *cvtr1_k, double *cvtr2_i, double *cvtr2_j, double *cvtr2_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Fc\+Cvtr\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{double}]{u, }
\item[{double}]{v, }
\item[{double $\ast$}]{cvtr1\+\_\+i, }
\item[{double $\ast$}]{cvtr1\+\_\+j, }
\item[{double $\ast$}]{cvtr1\+\_\+k, }
\item[{double $\ast$}]{cvtr2\+\_\+i, }
\item[{double $\ast$}]{cvtr2\+\_\+j, }
\item[{double $\ast$}]{cvtr2\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a82e59cf84e8a88197992d6100ea8cb95}{}\label{i_geom_8h_a82e59cf84e8a88197992d6100ea8cb95}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ@{i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, double x, double y, double z, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)}{iGeom_getFcCvtrXYZ(iGeom_Instance, iBase_EntityHandle face_handle, double x, double y, double z, double *cvtr1_i, double *cvtr1_j, double *cvtr1_k, double *cvtr2_i, double *cvtr2_j, double *cvtr2_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Fc\+Cvtr\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{cvtr1\+\_\+i, }
\item[{double $\ast$}]{cvtr1\+\_\+j, }
\item[{double $\ast$}]{cvtr1\+\_\+k, }
\item[{double $\ast$}]{cvtr2\+\_\+i, }
\item[{double $\ast$}]{cvtr2\+\_\+j, }
\item[{double $\ast$}]{cvtr2\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa83f1ce2ad6dc2115dbaf99c104834d0}{}\label{i_geom_8h_aa83f1ce2ad6dc2115dbaf99c104834d0}


Get the two principle curvature vectors for a face at a point Get the two principle curvature vectors for a face at a point. Magnitudes of vectors are curvature, directions are directions of principal curvatures. 


\begin{DoxyParams}{Parameters}
{\em face\+\_\+handle} & Face being queried \\
\hline
{\em x} & Position being queried \\
\hline
{\em y} & Position being queried \\
\hline
{\em z} & Position being queried \\
\hline
{\em cvtr1\+\_\+i} & Maximum curvature vector \\
\hline
{\em cvtr1\+\_\+j} & Maximum curvature vector \\
\hline
{\em cvtr1\+\_\+k} & Maximum curvature vector \\
\hline
{\em cvtr2\+\_\+i} & Minimum curvature vector \\
\hline
{\em cvtr2\+\_\+j} & Minimum curvature vector \\
\hline
{\em cvtr2\+\_\+k} & Minimum curvature vector \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ}}
\index{i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ@{i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Fc\+Eval\+X\+Y\+Z(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, double x, double y, double z, double $\ast$on\+\_\+x, double $\ast$on\+\_\+y, double $\ast$on\+\_\+z, double $\ast$nrml\+\_\+i, double $\ast$nrml\+\_\+j, double $\ast$nrml\+\_\+k, double $\ast$cvtr1\+\_\+i, double $\ast$cvtr1\+\_\+j, double $\ast$cvtr1\+\_\+k, double $\ast$cvtr2\+\_\+i, double $\ast$cvtr2\+\_\+j, double $\ast$cvtr2\+\_\+k, int $\ast$err)}{iGeom_getFcEvalXYZ(iGeom_Instance, iBase_EntityHandle face_handle, double x, double y, double z, double *on_x, double *on_y, double *on_z, double *nrml_i, double *nrml_j, double *nrml_k, double *cvtr1_i, double *cvtr1_j, double *cvtr1_k, double *cvtr2_i, double *cvtr2_j, double *cvtr2_k, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Fc\+Eval\+X\+YZ (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double $\ast$}]{on\+\_\+x, }
\item[{double $\ast$}]{on\+\_\+y, }
\item[{double $\ast$}]{on\+\_\+z, }
\item[{double $\ast$}]{nrml\+\_\+i, }
\item[{double $\ast$}]{nrml\+\_\+j, }
\item[{double $\ast$}]{nrml\+\_\+k, }
\item[{double $\ast$}]{cvtr1\+\_\+i, }
\item[{double $\ast$}]{cvtr1\+\_\+j, }
\item[{double $\ast$}]{cvtr1\+\_\+k, }
\item[{double $\ast$}]{cvtr2\+\_\+i, }
\item[{double $\ast$}]{cvtr2\+\_\+j, }
\item[{double $\ast$}]{cvtr2\+\_\+k, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a395664d89eb83ddead571af4685bfffe}{}\label{i_geom_8h_a395664d89eb83ddead571af4685bfffe}


Get closest point, tangent, and curvature of face Get closest point, tangent, and curvature of face. If any of input coordinate pointers are N\+U\+LL, that value is not returned. 


\begin{DoxyParams}{Parameters}
{\em face\+\_\+handle} & Face being queried \\
\hline
{\em x} & Point at which entity is being queried \\
\hline
{\em y} & Point at which entity is being queried \\
\hline
{\em z} & Point at which entity is being queried \\
\hline
{\em on\+\_\+x} & Closest point at point being queried \\
\hline
{\em on\+\_\+y} & Closest point at point being queried \\
\hline
{\em on\+\_\+z} & Closest point at point being queried \\
\hline
{\em nrml\+\_\+i} & Normal at point being queried \\
\hline
{\em nrml\+\_\+j} & Normal at point being queried \\
\hline
{\em nrml\+\_\+k} & Normal at point being queried \\
\hline
{\em cvtr1\+\_\+i} & First principal curvature at point being queried \\
\hline
{\em cvtr1\+\_\+j} & First principal curvature at point being queried \\
\hline
{\em cvtr1\+\_\+k} & First principal curvature at point being queried \\
\hline
{\em cvtr2\+\_\+i} & Second principal curvature at point being queried \\
\hline
{\em cvtr2\+\_\+j} & Second principal curvature at point being queried \\
\hline
{\em cvtr2\+\_\+k} & Second principal curvature at point being queried \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Int\+Arr\+Data@{i\+Geom\+\_\+get\+Int\+Arr\+Data}}
\index{i\+Geom\+\_\+get\+Int\+Arr\+Data@{i\+Geom\+\_\+get\+Int\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Int\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$$\ast$tag\+\_\+values, int $\ast$tag\+\_\+values\+\_\+allocated, int $\ast$tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_getIntArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, int **tag_values, int *tag_values_allocated, int *tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Int\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$$\ast$}]{tag\+\_\+values, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+allocated, }
\item[{int $\ast$}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac744d09db82b2762286ee484728cf082}{}\label{i_geom_8h_ac744d09db82b2762286ee484728cf082}


Get tag values of integer type for an array of entities. 

Get tag values of integer type for an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$tag\+\_\+values} & Pointer to tag data array being returned from function \\
\hline
{\em tag\+\_\+values\+\_\+allocated} & Pointer to allocated size of tag data array \\
\hline
{\em tag\+\_\+values\+\_\+size} & Pointer to occupied size of tag data array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Int\+Data@{i\+Geom\+\_\+get\+Int\+Data}}
\index{i\+Geom\+\_\+get\+Int\+Data@{i\+Geom\+\_\+get\+Int\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Int\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$out\+\_\+data, int $\ast$err)}{iGeom_getIntData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, int *out_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{out\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7c91d075e12506fc0ff00ad812a78242}{}\label{i_geom_8h_a7c91d075e12506fc0ff00ad812a78242}


Get the value of a tag of integer type on an entity. 

Get the value of a tag of integer type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em $\ast$out\+\_\+data} & Pointer to tag value returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter@{i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter}}
\index{i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter@{i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Arr\+Iterator, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$has\+\_\+data, int $\ast$err)}{iGeom_getNextEntArrIter(iGeom_Instance, iGeom_EntityArrIterator, iBase_EntityHandle **entity_handles, int *entity_handles_allocated, int *entity_handles_size, int *has_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Next\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Arr\+Iterator}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{has\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa574aa5f0bcea2996ffbd721e242a36b}{}\label{i_geom_8h_aa574aa5f0bcea2996ffbd721e242a36b}


Get entities contained in array iterator and increment iterator. 

Get the entities contained in an array iterator, and increment the iterator. Also return whether the next value of the iterator has any entities (if non-\/zero, next iterator value is the end of the iteration). 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator being queried \\
\hline
{\em $\ast$entity\+\_\+handles} & Pointer to array of entity handles contained in current value of iterator \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+handles array \\
\hline
{\em has\+\_\+data} & Pointer to flag; if returned non-\/zero, next iterator has a non-\/zero number of entities \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Next\+Ent\+Iter@{i\+Geom\+\_\+get\+Next\+Ent\+Iter}}
\index{i\+Geom\+\_\+get\+Next\+Ent\+Iter@{i\+Geom\+\_\+get\+Next\+Ent\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Next\+Ent\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Iterator, i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handle, int $\ast$has\+\_\+data, int $\ast$err)}{iGeom_getNextEntIter(iGeom_Instance, iGeom_EntityIterator, iBase_EntityHandle *entity_handle, int *has_data, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Next\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Iterator}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handle, }
\item[{int $\ast$}]{has\+\_\+data, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a03ca40825cbc07436cfc8041be82d135}{}\label{i_geom_8h_a03ca40825cbc07436cfc8041be82d135}


Get entity corresponding to an iterator and increment iterator. 

Get the entity corresponding to an array iterator, and increment the iterator. Also return whether the next value of the iterator has an entity (if non-\/zero, next iterator value is the end of the iteration). 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator being queried \\
\hline
{\em entity\+\_\+handle} & Pointer to an entity handle corresponding to the current value of iterator \\
\hline
{\em has\+\_\+data} & Pointer to flag; if returned non-\/zero, next iterator has an entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Num\+Chld@{i\+Geom\+\_\+get\+Num\+Chld}}
\index{i\+Geom\+\_\+get\+Num\+Chld@{i\+Geom\+\_\+get\+Num\+Chld}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Num\+Chld(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int num\+\_\+hops, int $\ast$num\+\_\+child, int $\ast$err)}{iGeom_getNumChld(iGeom_Instance instance, iBase_EntitySetHandle entity_set, int num_hops, int *num_child, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Num\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+child, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ad1211d552c990e5da37da5345e3b9d85}{}\label{i_geom_8h_ad1211d552c990e5da37da5345e3b9d85}


Get the number of child sets linked from a specified set. 

Get the number of child sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any child in the count. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to child set, inclusive of the child set \\
\hline
{\em num\+\_\+child} & Pointer to number of children returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Num\+Ent\+Sets@{i\+Geom\+\_\+get\+Num\+Ent\+Sets}}
\index{i\+Geom\+\_\+get\+Num\+Ent\+Sets@{i\+Geom\+\_\+get\+Num\+Ent\+Sets}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Num\+Ent\+Sets(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int num\+\_\+hops, int $\ast$num\+\_\+sets, int $\ast$err)}{iGeom_getNumEntSets(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, int num_hops, int *num_sets, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Num\+Ent\+Sets (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+sets, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a846e6bd490fd8eb64c425a81d909051a}{}\label{i_geom_8h_a846e6bd490fd8eb64c425a81d909051a}


Get the number of entity sets contained in a set or interface. 

Get the number of entity sets contained in a set or interface. If a set is input which is not the root set, num\+\_\+hops indicates the maximum number of contained sets from entity\+\_\+set\+\_\+handle to one of the contained sets, inclusive of the contained set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to contained set, inclusive of the contained set \\
\hline
{\em num\+\_\+sets} & Pointer to the number of sets returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Num\+Of\+Type@{i\+Geom\+\_\+get\+Num\+Of\+Type}}
\index{i\+Geom\+\_\+get\+Num\+Of\+Type@{i\+Geom\+\_\+get\+Num\+Of\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Num\+Of\+Type(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle set\+\_\+handle, int entity\+\_\+type, int $\ast$num\+\_\+out, int $\ast$err)}{iGeom_getNumOfType(iGeom_Instance instance, iBase_EntitySetHandle set_handle, int entity_type, int *num_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Num\+Of\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{set\+\_\+handle, }
\item[{int}]{entity\+\_\+type, }
\item[{int $\ast$}]{num\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa5d08056eec1d9825d6e56988fd52a42}{}\label{i_geom_8h_aa5d08056eec1d9825d6e56988fd52a42}


Get the number of entities with the specified type in the instance or set. 

Get the number of entities with the specified type in the instance or set. If entity set handle is zero, return information for instance, otherwise for set. Value of entity type must be from the i\+Base\+\_\+\+Entity\+Type enumeration. If i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES is specified, total number of entities (excluding entity sets) is returned. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being queried \\
\hline
{\em entity\+\_\+type} & Type of entity requested \\
\hline
{\em num\+\_\+type} & Pointer to number of entities, returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Num\+Prnt@{i\+Geom\+\_\+get\+Num\+Prnt}}
\index{i\+Geom\+\_\+get\+Num\+Prnt@{i\+Geom\+\_\+get\+Num\+Prnt}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Num\+Prnt(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int num\+\_\+hops, int $\ast$num\+\_\+parent, int $\ast$err)}{iGeom_getNumPrnt(iGeom_Instance instance, iBase_EntitySetHandle entity_set, int num_hops, int *num_parent, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Num\+Prnt (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int}]{num\+\_\+hops, }
\item[{int $\ast$}]{num\+\_\+parent, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8db5cd217e4d2f2197d2a8740277415c}{}\label{i_geom_8h_a8db5cd217e4d2f2197d2a8740277415c}


Get the number of parent sets linked from a specified set. 

Get the number of parent sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any parent in the count. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to parent set, inclusive of the parent set \\
\hline
{\em num\+\_\+parent} & Pointer to number of parents returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Parametric@{i\+Geom\+\_\+get\+Parametric}}
\index{i\+Geom\+\_\+get\+Parametric@{i\+Geom\+\_\+get\+Parametric}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Parametric(i\+Geom\+\_\+\+Instance, int $\ast$is\+\_\+parametric, int $\ast$err)}{iGeom_getParametric(iGeom_Instance, int *is_parametric, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Parametric (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{int $\ast$}]{is\+\_\+parametric, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a1f36b26c5e63ff33c2c4371e88f322a8}{}\label{i_geom_8h_a1f36b26c5e63ff33c2c4371e88f322a8}


Return whether interface has information about parameterization Return whether an interface has information about parameterization (!=0) or not (0) 


\begin{DoxyParams}{Parameters}
{\em is\+\_\+parametric} & If non-\/zero, interface has information about parameterization \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf@{i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf}}
\index{i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf@{i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf(i\+Geom\+\_\+\+Instance, int storage\+\_\+order, double const $\ast$coords, int coords\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$entity\+\_\+handles, int $\ast$entity\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getPntArrClsf(iGeom_Instance, int storage_order, double const *coords, int coords_size, iBase_EntityHandle **entity_handles, int *entity_handles_allocated, int *entity_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Pnt\+Arr\+Clsf (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{int}]{storage\+\_\+order, }
\item[{double const $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{entity\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a25786f172fff3a9355b200efb974b71c}{}\label{i_geom_8h_a25786f172fff3a9355b200efb974b71c}


Get the entities on which points are located Get the entities on which points are located. Storage orders should be members of the i\+Base\+\_\+\+Storage\+Order enumeration; if input is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em storage\+\_\+order} & Storage order of coordinates in coords \\
\hline
{\em coords} & Points being queried \\
\hline
{\em coords\+\_\+size} & Number of entries in coords array \\
\hline
{\em entity\+\_\+handles} & Entities on which points are located \\
\hline
{\em entity\+\_\+handles\+\_\+allocated} & Allocated size of entity\+\_\+handles array \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Occupied size of entity\+\_\+handles array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct@{i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct}}
\index{i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct@{i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct(i\+Geom\+\_\+\+Instance, int storage\+\_\+order, const double $\ast$coords, int coords\+\_\+size, const double $\ast$directions, int directions\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$intersect\+\_\+entity\+\_\+handles, int $\ast$intersect\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$intersect\+\_\+entity\+\_\+hangles\+\_\+size, int $\ast$$\ast$offset, int $\ast$offset\+\_\+allocated, int $\ast$offset\+\_\+size, double $\ast$$\ast$intersect\+\_\+coords, int $\ast$intersect\+\_\+coords\+\_\+allocated, int $\ast$intersect\+\_\+coords\+\_\+size, double $\ast$$\ast$param\+\_\+coords, int $\ast$param\+\_\+coords\+\_\+allocated, int $\ast$param\+\_\+coords\+\_\+size, int $\ast$err)}{iGeom_getPntArrRayIntsct(iGeom_Instance, int storage_order, const double *coords, int coords_size, const double *directions, int directions_size, iBase_EntityHandle **intersect_entity_handles, int *intersect_entity_handles_allocated, int *intersect_entity_hangles_size, int **offset, int *offset_allocated, int *offset_size, double **intersect_coords, int *intersect_coords_allocated, int *intersect_coords_size, double **param_coords, int *param_coords_allocated, int *param_coords_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Pnt\+Arr\+Ray\+Intsct (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{int}]{storage\+\_\+order, }
\item[{const double $\ast$}]{coords, }
\item[{int}]{coords\+\_\+size, }
\item[{const double $\ast$}]{directions, }
\item[{int}]{directions\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{intersect\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{intersect\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{intersect\+\_\+entity\+\_\+hangles\+\_\+size, }
\item[{int $\ast$$\ast$}]{offset, }
\item[{int $\ast$}]{offset\+\_\+allocated, }
\item[{int $\ast$}]{offset\+\_\+size, }
\item[{double $\ast$$\ast$}]{intersect\+\_\+coords, }
\item[{int $\ast$}]{intersect\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{intersect\+\_\+coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{param\+\_\+coords, }
\item[{int $\ast$}]{param\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{param\+\_\+coords\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abaa49e85d29813347ebda7ab8e7e1180}{}\label{i_geom_8h_abaa49e85d29813347ebda7ab8e7e1180}


Intersect an array of rays with the model Intersect an array of rays with the model. Storage orders passed back are members of the i\+Base\+\_\+\+Storage\+Order enumeration; if input/output is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em storage\+\_\+order} & Storage order of input coordinates \\
\hline
{\em coords} & Points from which rays are fired \\
\hline
{\em coords\+\_\+size} & Number of points from which rays are fired \\
\hline
{\em directions} & Directions in which rays are fired \\
\hline
{\em directions\+\_\+size} & Number of coordinates in directions array \\
\hline
{\em intersect\+\_\+entity\+\_\+handles} & Entities intersected by ray \\
\hline
{\em intersect\+\_\+entity\+\_\+handles\+\_\+allocated} & Allocated size of intersections array \\
\hline
{\em intersect\+\_\+entity\+\_\+hangles\+\_\+size} & Occupied size of intersections array \\
\hline
{\em offset} & Offset\mbox{[}i\mbox{]} is offset into intersect\+\_\+entity\+\_\+handles of ith ray \\
\hline
{\em offset\+\_\+allocated} & Allocated size of offset array \\
\hline
{\em offset\+\_\+size} & Occupied size of offset array \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates passed back \\
\hline
{\em intersect\+\_\+coords} & Coordinates of intersections \\
\hline
{\em intersect\+\_\+coords\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em intersect\+\_\+coords\+\_\+size} & Occupied size of coordinates array \\
\hline
{\em param\+\_\+coords} & Distances along ray of intersections \\
\hline
{\em param\+\_\+coords\+\_\+allocated} & Allocated size of param\+\_\+coords array \\
\hline
{\em param\+\_\+coords\+\_\+size} & Occupied size of param\+\_\+coords array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Pnt\+Clsf@{i\+Geom\+\_\+get\+Pnt\+Clsf}}
\index{i\+Geom\+\_\+get\+Pnt\+Clsf@{i\+Geom\+\_\+get\+Pnt\+Clsf}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Pnt\+Clsf(i\+Geom\+\_\+\+Instance, double x, double y, double z, i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handle, int $\ast$err)}{iGeom_getPntClsf(iGeom_Instance, double x, double y, double z, iBase_EntityHandle *entity_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Pnt\+Clsf (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a1431bba42628a16fc414036236393995}{}\label{i_geom_8h_a1431bba42628a16fc414036236393995}


Get the entity on which a point is located Get the entity on which a point is located. 


\begin{DoxyParams}{Parameters}
{\em x} & Point being queried \\
\hline
{\em y} & Point being queried \\
\hline
{\em z} & Point being queried \\
\hline
{\em entity\+\_\+handle} & Entity on which point is located \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct@{i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct}}
\index{i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct@{i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct(i\+Geom\+\_\+\+Instance, double x, double y, double z, double dir\+\_\+x, double dir\+\_\+y, double dir\+\_\+z, i\+Base\+\_\+\+Entity\+Handle $\ast$$\ast$intersect\+\_\+entity\+\_\+handles, int $\ast$intersect\+\_\+entity\+\_\+handles\+\_\+allocated, int $\ast$intersect\+\_\+entity\+\_\+hangles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$intersect\+\_\+coords, int $\ast$intersect\+\_\+coords\+\_\+allocated, int $\ast$intersect\+\_\+coords\+\_\+size, double $\ast$$\ast$param\+\_\+coords, int $\ast$param\+\_\+coords\+\_\+allocated, int $\ast$param\+\_\+coords\+\_\+size, int $\ast$err)}{iGeom_getPntRayIntsct(iGeom_Instance, double x, double y, double z, double dir_x, double dir_y, double dir_z, iBase_EntityHandle **intersect_entity_handles, int *intersect_entity_handles_allocated, int *intersect_entity_hangles_size, int storage_order, double **intersect_coords, int *intersect_coords_allocated, int *intersect_coords_size, double **param_coords, int *param_coords_allocated, int *param_coords_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Pnt\+Ray\+Intsct (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{double}]{dir\+\_\+x, }
\item[{double}]{dir\+\_\+y, }
\item[{double}]{dir\+\_\+z, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$$\ast$}]{intersect\+\_\+entity\+\_\+handles, }
\item[{int $\ast$}]{intersect\+\_\+entity\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{intersect\+\_\+entity\+\_\+hangles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{intersect\+\_\+coords, }
\item[{int $\ast$}]{intersect\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{intersect\+\_\+coords\+\_\+size, }
\item[{double $\ast$$\ast$}]{param\+\_\+coords, }
\item[{int $\ast$}]{param\+\_\+coords\+\_\+allocated, }
\item[{int $\ast$}]{param\+\_\+coords\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a594adf2fcf2be835b2cd464eb9f74e8b}{}\label{i_geom_8h_a594adf2fcf2be835b2cd464eb9f74e8b}


Intersect a ray with the model Intersect a ray with the model. Storage orders passed back are members of the i\+Base\+\_\+\+Storage\+Order enumeration; if output is i\+Base\+\_\+\+U\+N\+K\+N\+O\+WN, order is in native order with respect to implementation. 


\begin{DoxyParams}{Parameters}
{\em x} & Point from which ray is fired \\
\hline
{\em y} & Point from which ray is fired \\
\hline
{\em z} & Point from which ray is fired \\
\hline
{\em dir\+\_\+x} & Direction in which ray is fired \\
\hline
{\em dir\+\_\+y} & Direction in which ray is fired \\
\hline
{\em dir\+\_\+z} & Direction in which ray is fired \\
\hline
{\em intersect\+\_\+entity\+\_\+handles} & Entities intersected by ray \\
\hline
{\em intersect\+\_\+entity\+\_\+handles\+\_\+allocated} & Allocated size of intersections array \\
\hline
{\em intersect\+\_\+entity\+\_\+hangles\+\_\+size} & Occupied size of intersections array \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates passed back \\
\hline
{\em intersect\+\_\+coords} & Coordinates of intersections \\
\hline
{\em intersect\+\_\+coords\+\_\+allocated} & Allocated size of coordinates array \\
\hline
{\em intersect\+\_\+coords\+\_\+size} & Occupied size of coordinates array \\
\hline
{\em param\+\_\+coords} & Distances along ray of intersections \\
\hline
{\em param\+\_\+coords\+\_\+allocated} & Allocated size of param\+\_\+coords array \\
\hline
{\em param\+\_\+coords\+\_\+size} & Occupied size of param\+\_\+coords array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Prnts@{i\+Geom\+\_\+get\+Prnts}}
\index{i\+Geom\+\_\+get\+Prnts@{i\+Geom\+\_\+get\+Prnts}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Prnts(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle from\+\_\+entity\+\_\+set, int num\+\_\+hops, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$$\ast$entity\+\_\+set\+\_\+handles, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated, int $\ast$entity\+\_\+set\+\_\+handles\+\_\+size, int $\ast$err)}{iGeom_getPrnts(iGeom_Instance instance, iBase_EntitySetHandle from_entity_set, int num_hops, iBase_EntitySetHandle **entity_set_handles, int *entity_set_handles_allocated, int *entity_set_handles_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Prnts (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{from\+\_\+entity\+\_\+set, }
\item[{int}]{num\+\_\+hops, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$$\ast$}]{entity\+\_\+set\+\_\+handles, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+allocated, }
\item[{int $\ast$}]{entity\+\_\+set\+\_\+handles\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a22d57535f64053db711c949dfc5dd673}{}\label{i_geom_8h_a22d57535f64053db711c949dfc5dd673}


Get the parent sets linked from a specified set. 

Get the parent sets linked from a specified set. If num\+\_\+hops is non-\/zero, this represents the maximum hops from entity\+\_\+set to any parent. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em from\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em num\+\_\+hops} & Maximum hops from entity\+\_\+set\+\_\+handle to parent set, inclusive of the parent set \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles} & Pointer to array of parent sets returned from function \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+allocated} & Pointer to allocated size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$entity\+\_\+set\+\_\+handles\+\_\+size} & Pointer to occupied size of entity\+\_\+set\+\_\+handles array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Root\+Set@{i\+Geom\+\_\+get\+Root\+Set}}
\index{i\+Geom\+\_\+get\+Root\+Set@{i\+Geom\+\_\+get\+Root\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Root\+Set(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$root\+\_\+set, int $\ast$err)}{iGeom_getRootSet(iGeom_Instance, iBase_EntitySetHandle *root_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Root\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{root\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a89bef37833d2bc31c5b5a0a68cc866c4}{}\label{i_geom_8h_a89bef37833d2bc31c5b5a0a68cc866c4}


Get handle of the root set for this instance. 

Get handle of the root set for this instance. All geom in this instance can be accessed from this set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em root\+\_\+set} & Pointer to set handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tag\+Handle@{i\+Geom\+\_\+get\+Tag\+Handle}}
\index{i\+Geom\+\_\+get\+Tag\+Handle@{i\+Geom\+\_\+get\+Tag\+Handle}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tag\+Handle(i\+Geom\+\_\+\+Instance instance, const char $\ast$tag\+\_\+name, i\+Base\+\_\+\+Tag\+Handle $\ast$tag\+\_\+handle, int $\ast$err, int tag\+\_\+name\+\_\+len)}{iGeom_getTagHandle(iGeom_Instance instance, const char *tag_name, iBase_TagHandle *tag_handle, int *err, int tag_name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tag\+Handle (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const char $\ast$}]{tag\+\_\+name, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle} $\ast$}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err, }
\item[{int}]{tag\+\_\+name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a62390d1c3fe226e4b3dc8905c831d606}{}\label{i_geom_8h_a62390d1c3fe226e4b3dc8905c831d606}


Get a the handle of an existing tag with the specified name. 

Get a the handle of an existing tag with the specified name 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+name} & Name of tag being queried \\
\hline
{\em tag\+\_\+handle} & Pointer to tag handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em tag\+\_\+name\+\_\+len} & Length of tag name string \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tag\+Name@{i\+Geom\+\_\+get\+Tag\+Name}}
\index{i\+Geom\+\_\+get\+Tag\+Name@{i\+Geom\+\_\+get\+Tag\+Name}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tag\+Name(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, char $\ast$name, int $\ast$err, int name\+\_\+len)}{iGeom_getTagName(iGeom_Instance instance, iBase_TagHandle tag_handle, char *name, int *err, int name_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tag\+Name (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{char $\ast$}]{name, }
\item[{int $\ast$}]{err, }
\item[{int}]{name\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a53f54202145284a6cd137117183bf68e}{}\label{i_geom_8h_a53f54202145284a6cd137117183bf68e}


Get the name for a given tag handle. 

Get the name for a given tag handle 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+handle} & Tag handle being queried \\
\hline
{\em name} & Pointer to character string to store name returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of character string input to function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tag\+Size\+Bytes@{i\+Geom\+\_\+get\+Tag\+Size\+Bytes}}
\index{i\+Geom\+\_\+get\+Tag\+Size\+Bytes@{i\+Geom\+\_\+get\+Tag\+Size\+Bytes}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tag\+Size\+Bytes(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)}{iGeom_getTagSizeBytes(iGeom_Instance instance, iBase_TagHandle tag_handle, int *tag_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tag\+Size\+Bytes (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9c7ee245bd1124433c4f6f40612d92b7}{}\label{i_geom_8h_a9c7ee245bd1124433c4f6f40612d92b7}


Get size of a tag in units of bytes. 

Get size of a tag in units of bytes 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag being queried \\
\hline
{\em tag\+\_\+size} & Pointer to tag size returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tag\+Size\+Values@{i\+Geom\+\_\+get\+Tag\+Size\+Values}}
\index{i\+Geom\+\_\+get\+Tag\+Size\+Values@{i\+Geom\+\_\+get\+Tag\+Size\+Values}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tag\+Size\+Values(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+size, int $\ast$err)}{iGeom_getTagSizeValues(iGeom_Instance instance, iBase_TagHandle tag_handle, int *tag_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tag\+Size\+Values (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af909a0968a1386b98611056ea9a66f7f}{}\label{i_geom_8h_af909a0968a1386b98611056ea9a66f7f}


Get size of a tag in units of numbers of tag data type. 

Get size of a tag in units of numbers of tag data type 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+handle} & Handle of tag being queried \\
\hline
{\em tag\+\_\+size} & Pointer to tag size returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tag\+Type@{i\+Geom\+\_\+get\+Tag\+Type}}
\index{i\+Geom\+\_\+get\+Tag\+Type@{i\+Geom\+\_\+get\+Tag\+Type}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tag\+Type(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$tag\+\_\+type, int $\ast$err)}{iGeom_getTagType(iGeom_Instance instance, iBase_TagHandle tag_handle, int *tag_type, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tag\+Type (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{tag\+\_\+type, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a838dadccb5360f3949a86d43c56c4fcd}{}\label{i_geom_8h_a838dadccb5360f3949a86d43c56c4fcd}


Get the data type of the specified tag handle. 

Get the data type of the specified tag handle. Tag type is a value in the i\+Base\+\_\+\+Tag\+Type enumeration. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em tag\+\_\+handle} & Handle for the tag being queried \\
\hline
{\em tag\+\_\+type} & Pointer to tag type returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Tolerance@{i\+Geom\+\_\+get\+Tolerance}}
\index{i\+Geom\+\_\+get\+Tolerance@{i\+Geom\+\_\+get\+Tolerance}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Tolerance(i\+Geom\+\_\+\+Instance, int $\ast$type, double $\ast$tolerance, int $\ast$err)}{iGeom_getTolerance(iGeom_Instance, int *type, double *tolerance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Tolerance (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{int $\ast$}]{type, }
\item[{double $\ast$}]{tolerance, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aaada5f298da6559da46710da32778dad}{}\label{i_geom_8h_aaada5f298da6559da46710da32778dad}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Topo\+Level@{i\+Geom\+\_\+get\+Topo\+Level}}
\index{i\+Geom\+\_\+get\+Topo\+Level@{i\+Geom\+\_\+get\+Topo\+Level}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Topo\+Level(i\+Geom\+\_\+\+Instance instance, int $\ast$topo\+\_\+level\+\_\+out, int $\ast$err)}{iGeom_getTopoLevel(iGeom_Instance instance, int *topo_level_out, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Topo\+Level (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{int $\ast$}]{topo\+\_\+level\+\_\+out, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a89a37345e783eab1d54b288a986cee08}{}\label{i_geom_8h_a89a37345e783eab1d54b288a986cee08}


D\+ON\textquotesingle{}T K\+N\+OW W\+H\+AT T\+H\+IS F\+U\+N\+C\+T\+I\+ON IS. 


\begin{DoxyParams}{Parameters}
{\em topo\+\_\+level\+\_\+out} & \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+Arr\+Coords@{i\+Geom\+\_\+get\+Vtx\+Arr\+Coords}}
\index{i\+Geom\+\_\+get\+Vtx\+Arr\+Coords@{i\+Geom\+\_\+get\+Vtx\+Arr\+Coords}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+Arr\+Coords(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$coordinates, int $\ast$coordinates\+\_\+allocated, int $\ast$coordinates\+\_\+size, int $\ast$err)}{iGeom_getVtxArrCoords(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int storage_order, double **coordinates, int *coordinates_allocated, int *coordinates_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+Arr\+Coords (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{coordinates, }
\item[{int $\ast$}]{coordinates\+\_\+allocated, }
\item[{int $\ast$}]{coordinates\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4b1b83d605611807cd5db7e320b76e1e}{}\label{i_geom_8h_a4b1b83d605611807cd5db7e320b76e1e}


Get coordinates of specified vertices. 

Get coordinates of specified vertices. If storage order is passed in with a value other than i\+Base\+\_\+\+U\+N\+D\+E\+T\+E\+R\+M\+I\+N\+ED, coordinates are returned in the specified storage order, otherwise storage order is that native to the implementation. Storage order of returned coordinates is also returned. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em vertex\+\_\+handles} & Array of geom vertex handles whose coordinates are being requested \\
\hline
{\em vertex\+\_\+handles\+\_\+size} & Number of vertices in vertex\+\_\+handles array \\
\hline
{\em storage\+\_\+order} & Storage order requested for coordinate data \\
\hline
{\em $\ast$coords} & Pointer to array of coordinates returned from function \\
\hline
{\em $\ast$coords\+\_\+allocated} & Pointer to allocated size of coords array \\
\hline
{\em $\ast$coords\+\_\+size} & Pointer to occupied size of coords array \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+Arr\+ToU@{i\+Geom\+\_\+get\+Vtx\+Arr\+ToU}}
\index{i\+Geom\+\_\+get\+Vtx\+Arr\+ToU@{i\+Geom\+\_\+get\+Vtx\+Arr\+ToU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$vertex\+\_\+handles, int vertex\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$edge\+\_\+handles, int edge\+\_\+handles\+\_\+size, double $\ast$$\ast$u, int $\ast$u\+\_\+allocated, int $\ast$u\+\_\+size, int $\ast$err)}{iGeom_getVtxArrToU(iGeom_Instance, iBase_EntityHandle const *vertex_handles, int vertex_handles_size, iBase_EntityHandle const *edge_handles, int edge_handles_size, double **u, int *u_allocated, int *u_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+Arr\+ToU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{vertex\+\_\+handles, }
\item[{int}]{vertex\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{edge\+\_\+handles, }
\item[{int}]{edge\+\_\+handles\+\_\+size, }
\item[{double $\ast$$\ast$}]{u, }
\item[{int $\ast$}]{u\+\_\+allocated, }
\item[{int $\ast$}]{u\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aadbbf3ae57c55f5662a4cb90d25229df}{}\label{i_geom_8h_aadbbf3ae57c55f5662a4cb90d25229df}


Return parametric coordinates on edges of vertex positions Return parametric coordinates on edges of vertex positions. 


\begin{DoxyParams}{Parameters}
{\em vertex\+\_\+handles} & Vertices being queried \\
\hline
{\em vertex\+\_\+handles\+\_\+size} & Number of vertices being queried \\
\hline
{\em edge\+\_\+handles} & Edges being queried \\
\hline
{\em edge\+\_\+handles\+\_\+size} & Number of edges being queried \\
\hline
{\em u} & Corresponding parametric positions on faces \\
\hline
{\em u\+\_\+allocated} & Allocated size of positions array \\
\hline
{\em u\+\_\+size} & Occupied size of positions array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV@{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV}}
\index{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV@{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+Arr\+To\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$vertex\+\_\+handles, int vertex\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int storage\+\_\+order, double $\ast$$\ast$uv, int $\ast$uv\+\_\+allocated, int $\ast$uv\+\_\+size, int $\ast$err)}{iGeom_getVtxArrToUV(iGeom_Instance, iBase_EntityHandle const *vertex_handles, int vertex_handles_size, iBase_EntityHandle const *face_handles, int face_handles_size, int storage_order, double **uv, int *uv_allocated, int *uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+Arr\+To\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{vertex\+\_\+handles, }
\item[{int}]{vertex\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int}]{storage\+\_\+order, }
\item[{double $\ast$$\ast$}]{uv, }
\item[{int $\ast$}]{uv\+\_\+allocated, }
\item[{int $\ast$}]{uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a25ae9c486d3abef323435d64df7c03df}{}\label{i_geom_8h_a25ae9c486d3abef323435d64df7c03df}


Return parametric coordinates on faces of vertex positions Return parametric coordinates on faces of vertex positions. 


\begin{DoxyParams}{Parameters}
{\em vertex\+\_\+handles} & Vertices being queried \\
\hline
{\em vertex\+\_\+handles\+\_\+size} & Number of vertices being queried \\
\hline
{\em face\+\_\+handles} & Faces being queried \\
\hline
{\em face\+\_\+handles\+\_\+size} & Number of faces being queried \\
\hline
{\em storage\+\_\+order} & Storage order of coordinates returned \\
\hline
{\em uv} & Corresponding parametric positions on faces \\
\hline
{\em uv\+\_\+allocated} & Allocated size of positions array \\
\hline
{\em uv\+\_\+size} & Occupied size of positions array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+Coord@{i\+Geom\+\_\+get\+Vtx\+Coord}}
\index{i\+Geom\+\_\+get\+Vtx\+Coord@{i\+Geom\+\_\+get\+Vtx\+Coord}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+Coord(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle vertex\+\_\+handle, double $\ast$x, double $\ast$y, double $\ast$z, int $\ast$err)}{iGeom_getVtxCoord(iGeom_Instance, iBase_EntityHandle vertex_handle, double *x, double *y, double *z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+Coord (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex\+\_\+handle, }
\item[{double $\ast$}]{x, }
\item[{double $\ast$}]{y, }
\item[{double $\ast$}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a564afd920585388f5d4d28e811b158b6}{}\label{i_geom_8h_a564afd920585388f5d4d28e811b158b6}


Get coordinates of specified vertex. 

Get coordinates of specified vertex. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em vertex\+\_\+handle} & Geom vertex being queried \\
\hline
{\em $\ast$x} & Pointer to x coordinate returned from function \\
\hline
{\em $\ast$y} & Pointer to y coordinate returned from function \\
\hline
{\em $\ast$z} & Pointer to z coordinate returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+ToU@{i\+Geom\+\_\+get\+Vtx\+ToU}}
\index{i\+Geom\+\_\+get\+Vtx\+ToU@{i\+Geom\+\_\+get\+Vtx\+ToU}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+To\+U(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle vertex\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle edge\+\_\+handle, double $\ast$u, int $\ast$err)}{iGeom_getVtxToU(iGeom_Instance, iBase_EntityHandle vertex_handle, iBase_EntityHandle edge_handle, double *u, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+ToU (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{edge\+\_\+handle, }
\item[{double $\ast$}]{u, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac499accb8514d8eec221e06a66a767bc}{}\label{i_geom_8h_ac499accb8514d8eec221e06a66a767bc}


Return parametric coordinates on edge of vertex position Return parametric coordinates on edge of vertex position. 


\begin{DoxyParams}{Parameters}
{\em vertex\+\_\+handle} & Vertex being queried \\
\hline
{\em edge\+\_\+handle} & Edge being queried \\
\hline
{\em u} & Corresponding parametric position on face \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+get\+Vtx\+To\+UV@{i\+Geom\+\_\+get\+Vtx\+To\+UV}}
\index{i\+Geom\+\_\+get\+Vtx\+To\+UV@{i\+Geom\+\_\+get\+Vtx\+To\+UV}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+get\+Vtx\+To\+U\+V(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle vertex\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, double $\ast$u, double $\ast$v, int $\ast$err)}{iGeom_getVtxToUV(iGeom_Instance, iBase_EntityHandle vertex_handle, iBase_EntityHandle face_handle, double *u, double *v, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+get\+Vtx\+To\+UV (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{vertex\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{double $\ast$}]{u, }
\item[{double $\ast$}]{v, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7450d4a57c81453c69c5773864c32e64}{}\label{i_geom_8h_a7450d4a57c81453c69c5773864c32e64}


Return parametric coordinates on face of vertex position Return parametric coordinates on face of vertex position. 


\begin{DoxyParams}{Parameters}
{\em vertex\+\_\+handle} & Vertex being queried \\
\hline
{\em face\+\_\+handle} & Face being queried \\
\hline
{\em u} & Corresponding parametric position on face \\
\hline
{\em v} & Corresponding parametric position on face \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+imprint\+Ents@{i\+Geom\+\_\+imprint\+Ents}}
\index{i\+Geom\+\_\+imprint\+Ents@{i\+Geom\+\_\+imprint\+Ents}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+imprint\+Ents(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, int $\ast$err)}{iGeom_imprintEnts(iGeom_Instance, iBase_EntityHandle const *geom_entities, int geom_entities_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+imprint\+Ents (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{geom\+\_\+entities, }
\item[{int}]{geom\+\_\+entities\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa5e42f81ee4e782cae33c02f192ef45b}{}\label{i_geom_8h_aa5e42f81ee4e782cae33c02f192ef45b}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+init\+Ent\+Arr\+Iter@{i\+Geom\+\_\+init\+Ent\+Arr\+Iter}}
\index{i\+Geom\+\_\+init\+Ent\+Arr\+Iter@{i\+Geom\+\_\+init\+Ent\+Arr\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+init\+Ent\+Arr\+Iter(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int entity\+\_\+dimension, int requested\+\_\+array\+\_\+size, i\+Geom\+\_\+\+Entity\+Arr\+Iterator $\ast$ent\+Arr\+\_\+iterator, int $\ast$err)}{iGeom_initEntArrIter(iGeom_Instance, iBase_EntitySetHandle entity_set_handle, int entity_dimension, int requested_array_size, iGeom_EntityArrIterator *entArr_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+init\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int}]{entity\+\_\+dimension, }
\item[{int}]{requested\+\_\+array\+\_\+size, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Arr\+Iterator} $\ast$}]{ent\+Arr\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_adb6872f5c34b3d90858aac6db72bee50}{}\label{i_geom_8h_adb6872f5c34b3d90858aac6db72bee50}


Initialize an array iterator over specified entity type, topology, and size. 

Initialize an array iterator over specified entity type, topology, and size, for a specified set or instance. Iterator returned can be used as input to functions returning entities for the iterator. If all entities of a specified type and/or topology are to be iterated, specify i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES or i\+Geom\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Geom\+\_\+\+Entity\+Topology enumerations, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being iterated \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of entity to iterate \\
\hline
{\em requested\+\_\+entity\+\_\+topology} & Topology of entity to iterate \\
\hline
{\em requested\+\_\+array\+\_\+size} & Size of chunks of handles returned for each value of the iterator \\
\hline
{\em ent\+Arr\+\_\+iterator} & Pointer to iterator returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+init\+Ent\+Iter@{i\+Geom\+\_\+init\+Ent\+Iter}}
\index{i\+Geom\+\_\+init\+Ent\+Iter@{i\+Geom\+\_\+init\+Ent\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+init\+Ent\+Iter(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int entity\+\_\+dimension, i\+Geom\+\_\+\+Entity\+Iterator $\ast$entity\+\_\+iterator, int $\ast$err)}{iGeom_initEntIter(iGeom_Instance, iBase_EntitySetHandle entity_set_handle, int entity_dimension, iGeom_EntityIterator *entity_iterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+init\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int}]{entity\+\_\+dimension, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Iterator} $\ast$}]{entity\+\_\+iterator, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a95d57db1f6df20f5f939bf67d334992e}{}\label{i_geom_8h_a95d57db1f6df20f5f939bf67d334992e}


Initialize an iterator over specified entity type, topology, and size. 

Initialize an iterator over specified entity type, topology, and size, for a specified set or instance. Iterator returned can be used as input to functions returning the entity for the iterator. If all entities of a specified type and/or topology are to be iterated, specify i\+Base\+\_\+\+A\+L\+L\+\_\+\+T\+Y\+P\+ES or i\+Geom\+\_\+\+A\+L\+L\+\_\+\+T\+O\+P\+O\+L\+O\+G\+I\+ES, respectively. Specified type or topology must be a value in the i\+Base\+\_\+\+Entity\+Type or i\+Geom\+\_\+\+Entity\+Topology enumerations, respectively. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being iterated \\
\hline
{\em requested\+\_\+entity\+\_\+type} & Type of entity to iterate \\
\hline
{\em requested\+\_\+entity\+\_\+topology} & Topology of entity to iterate \\
\hline
{\em entity\+\_\+iterator} & Pointer to iterator returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+intersect@{i\+Geom\+\_\+intersect}}
\index{i\+Geom\+\_\+intersect@{i\+Geom\+\_\+intersect}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+intersect(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iGeom_intersect(iGeom_Instance instance, iBase_EntitySetHandle entity_set_1, iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+intersect (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a6c2e51853284c67e302b421ac4e1f863}{}\label{i_geom_8h_a6c2e51853284c67e302b421ac4e1f863}


Intersect contents of one entity set with another. 

Intersect contents of one entity set with another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set being intersected with another \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being intersected with another \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+intersect\+Ents@{i\+Geom\+\_\+intersect\+Ents}}
\index{i\+Geom\+\_\+intersect\+Ents@{i\+Geom\+\_\+intersect\+Ents}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+intersect\+Ents(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity2, i\+Base\+\_\+\+Entity\+Handle entity1, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_intersectEnts(iGeom_Instance, iBase_EntityHandle entity2, iBase_EntityHandle entity1, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+intersect\+Ents (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ab53628e5a3b2eaad65b0264a8c8e7ff7}{}\label{i_geom_8h_ab53628e5a3b2eaad65b0264a8c8e7ff7}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Arr\+Adj@{i\+Geom\+\_\+is\+Arr\+Adj}}
\index{i\+Geom\+\_\+is\+Arr\+Adj@{i\+Geom\+\_\+is\+Arr\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Arr\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles\+\_\+1, int entity\+\_\+handles\+\_\+1\+\_\+size, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles\+\_\+2, int entity\+\_\+handles\+\_\+2\+\_\+size, int $\ast$$\ast$is\+\_\+adjacent\+\_\+info, int $\ast$is\+\_\+adjacent\+\_\+info\+\_\+allocated, int $\ast$is\+\_\+adjacent\+\_\+info\+\_\+size, int $\ast$err)}{iGeom_isArrAdj(iGeom_Instance instance, iBase_EntityHandle const *entity_handles_1, int entity_handles_1_size, iBase_EntityHandle const *entity_handles_2, int entity_handles_2_size, int **is_adjacent_info, int *is_adjacent_info_allocated, int *is_adjacent_info_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Arr\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles\+\_\+1, }
\item[{int}]{entity\+\_\+handles\+\_\+1\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles\+\_\+2, }
\item[{int}]{entity\+\_\+handles\+\_\+2\+\_\+size, }
\item[{int $\ast$$\ast$}]{is\+\_\+adjacent\+\_\+info, }
\item[{int $\ast$}]{is\+\_\+adjacent\+\_\+info\+\_\+allocated, }
\item[{int $\ast$}]{is\+\_\+adjacent\+\_\+info\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aba8dd7fab5b74ea52e38ef5f296a9ec6}{}\label{i_geom_8h_aba8dd7fab5b74ea52e38ef5f296a9ec6}


Return whether entity pairs are adjacent Return whether entity pairs are adjacent, i.\+e. if entity\+\_\+handles\+\_\+1\mbox{[}i\mbox{]} is adjacent to entity\+\_\+handles\+\_\+2\mbox{[}i\mbox{]}. This function requires entity\+\_\+handles\+\_\+1\+\_\+size and entity\+\_\+handles\+\_\+2\+\_\+size to be equal. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles\+\_\+1} & First array of entities \\
\hline
{\em entity\+\_\+handles\+\_\+1\+\_\+size} & Number of entities in first array \\
\hline
{\em entity\+\_\+handles\+\_\+2} & Second array of entities \\
\hline
{\em entity\+\_\+handles\+\_\+2\+\_\+size} & Number of entities in second array \\
\hline
{\em is\+\_\+adjacent\+\_\+info} & Array of flags returned from function \\
\hline
{\em is\+\_\+adjacent\+\_\+info\+\_\+allocated} & Allocated size of flags array \\
\hline
{\em is\+\_\+adjacent\+\_\+info\+\_\+size} & Occupied size of flags array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Arr\+Parametric@{i\+Geom\+\_\+is\+Arr\+Parametric}}
\index{i\+Geom\+\_\+is\+Arr\+Parametric@{i\+Geom\+\_\+is\+Arr\+Parametric}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Arr\+Parametric(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$is\+\_\+parametric, int $\ast$is\+\_\+parametric\+\_\+allocated, int $\ast$is\+\_\+parametric\+\_\+size, int $\ast$err)}{iGeom_isArrParametric(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int **is_parametric, int *is_parametric_allocated, int *is_parametric_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Arr\+Parametric (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{is\+\_\+parametric, }
\item[{int $\ast$}]{is\+\_\+parametric\+\_\+allocated, }
\item[{int $\ast$}]{is\+\_\+parametric\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_afb6bb6cd1b9305c164e5e4568aef27fb}{}\label{i_geom_8h_afb6bb6cd1b9305c164e5e4568aef27fb}


Return whether entities have parameterizations Return whether entities have parameterizations (!= 0) or not (=0) 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities being queried \\
\hline
{\em is\+\_\+parametric} & entity\+\_\+handles\mbox{[}i\mbox{]} has a parameterization (!= 0) or not (=0) \\
\hline
{\em is\+\_\+parametric\+\_\+allocated} & Allocated size of is\+\_\+parametric array \\
\hline
{\em is\+\_\+parametric\+\_\+size} & Occupied size of is\+\_\+parametric array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Arr\+Periodic@{i\+Geom\+\_\+is\+Arr\+Periodic}}
\index{i\+Geom\+\_\+is\+Arr\+Periodic@{i\+Geom\+\_\+is\+Arr\+Periodic}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Arr\+Periodic(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, int $\ast$$\ast$in\+\_\+uv, int $\ast$in\+\_\+uv\+\_\+allocated, int $\ast$in\+\_\+uv\+\_\+size, int $\ast$err)}{iGeom_isArrPeriodic(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, int **in_uv, int *in_uv_allocated, int *in_uv_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Arr\+Periodic (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{in\+\_\+uv, }
\item[{int $\ast$}]{in\+\_\+uv\+\_\+allocated, }
\item[{int $\ast$}]{in\+\_\+uv\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a49313c2bc29a099f069b54d8af215858}{}\label{i_geom_8h_a49313c2bc29a099f069b54d8af215858}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Child\+Of@{i\+Geom\+\_\+is\+Child\+Of}}
\index{i\+Geom\+\_\+is\+Child\+Of@{i\+Geom\+\_\+is\+Child\+Of}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Child\+Of(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$is\+\_\+child, int $\ast$err)}{iGeom_isChildOf(iGeom_Instance instance, iBase_EntitySetHandle parent_entity_set, iBase_EntitySetHandle child_entity_set, int *is_child, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Child\+Of (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+child, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aef980675b00e378854d4ef9ecf12b113}{}\label{i_geom_8h_aef980675b00e378854d4ef9ecf12b113}


Return whether two sets are related by parent/child links. 

Return whether two sets are related ($\ast$is\+\_\+child=1) or not ($\ast$is\+\_\+child=0) by parent/child links 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em is\+\_\+child} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Adj@{i\+Geom\+\_\+is\+Ent\+Adj}}
\index{i\+Geom\+\_\+is\+Ent\+Adj@{i\+Geom\+\_\+is\+Ent\+Adj}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Adj(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle1, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle2, int $\ast$are\+\_\+adjacent, int $\ast$err)}{iGeom_isEntAdj(iGeom_Instance instance, iBase_EntityHandle entity_handle1, iBase_EntityHandle entity_handle2, int *are_adjacent, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Adj (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle2, }
\item[{int $\ast$}]{are\+\_\+adjacent, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af31f32348b3752d0fa477ba5159cf32a}{}\label{i_geom_8h_af31f32348b3752d0fa477ba5159cf32a}


Return whether two entities are adjacent Return whether two entities are adjacent. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle1} & First entity queried \\
\hline
{\em entity\+\_\+handle2} & Second entity queried \\
\hline
{\em are\+\_\+adjacent} & If returned non-\/zero, entities are adjacent, otherwise they are not \\
\hline
{\em err} & \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Arr\+Contained@{i\+Geom\+\_\+is\+Ent\+Arr\+Contained}}
\index{i\+Geom\+\_\+is\+Ent\+Arr\+Contained@{i\+Geom\+\_\+is\+Ent\+Arr\+Contained}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Arr\+Contained(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+set, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int num\+\_\+entity\+\_\+handles, int $\ast$$\ast$is\+\_\+contained, int $\ast$is\+\_\+contained\+\_\+allocated, int $\ast$is\+\_\+contained\+\_\+size, int $\ast$err)}{iGeom_isEntArrContained(iGeom_Instance instance, iBase_EntitySetHandle containing_set, const iBase_EntityHandle *entity_handles, int num_entity_handles, int **is_contained, int *is_contained_allocated, int *is_contained_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Arr\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+set, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{num\+\_\+entity\+\_\+handles, }
\item[{int $\ast$$\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{is\+\_\+contained\+\_\+allocated, }
\item[{int $\ast$}]{is\+\_\+contained\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a24f08e0b41f4ad876418c75d0f93e6de}{}\label{i_geom_8h_a24f08e0b41f4ad876418c75d0f93e6de}


Return whether entities are contained in a set. 

Return whether each entity is contained in the set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Mesh instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em entity\+\_\+handles} & List of entities for which to check containment. \\
\hline
{\em is\+\_\+contained} & One value for each input entity, 1 if contained in set, zero otherwise. \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Contained@{i\+Geom\+\_\+is\+Ent\+Contained}}
\index{i\+Geom\+\_\+is\+Ent\+Contained@{i\+Geom\+\_\+is\+Ent\+Contained}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Contained(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Handle contained\+\_\+entity, int $\ast$is\+\_\+contained, int $\ast$err)}{iGeom_isEntContained(iGeom_Instance instance, iBase_EntitySetHandle containing_entity_set, iBase_EntityHandle contained_entity, int *is_contained, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{contained\+\_\+entity, }
\item[{int $\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a2809c03d33f14c01ef1bab5b43553fc4}{}\label{i_geom_8h_a2809c03d33f14c01ef1bab5b43553fc4}


Return whether an entity is contained in another set. 

Return whether an entity is contained ($\ast$is\+\_\+contained=1) or not contained ($\ast$is\+\_\+contained=0) in another set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em contained\+\_\+entity} & Entity potentially contained in containing\+\_\+entity\+\_\+set \\
\hline
{\em is\+\_\+contained} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Parametric@{i\+Geom\+\_\+is\+Ent\+Parametric}}
\index{i\+Geom\+\_\+is\+Ent\+Parametric@{i\+Geom\+\_\+is\+Ent\+Parametric}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Parametric(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$parametric, int $\ast$err)}{iGeom_isEntParametric(iGeom_Instance, iBase_EntityHandle entity_handle, int *parametric, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Parametric (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{parametric, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a53c8448024589d99945fd52c6088e485}{}\label{i_geom_8h_a53c8448024589d99945fd52c6088e485}


Return whether an entity has a parameterization Return whether an entity has a parameterization (!= 0) or not (=0) 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handle} & Entity being queried \\
\hline
{\em is\+\_\+parametric} & Entity has a parameterization (!= 0) or not (=0) \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Periodic@{i\+Geom\+\_\+is\+Ent\+Periodic}}
\index{i\+Geom\+\_\+is\+Ent\+Periodic@{i\+Geom\+\_\+is\+Ent\+Periodic}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Periodic(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, int $\ast$in\+\_\+u, int $\ast$in\+\_\+v, int $\ast$err)}{iGeom_isEntPeriodic(iGeom_Instance, iBase_EntityHandle entity_handle, int *in_u, int *in_v, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Periodic (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{int $\ast$}]{in\+\_\+u, }
\item[{int $\ast$}]{in\+\_\+v, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a547d0a3d2ca9c4747703ee2c045b12c2}{}\label{i_geom_8h_a547d0a3d2ca9c4747703ee2c045b12c2}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Ent\+Set\+Contained@{i\+Geom\+\_\+is\+Ent\+Set\+Contained}}
\index{i\+Geom\+\_\+is\+Ent\+Set\+Contained@{i\+Geom\+\_\+is\+Ent\+Set\+Contained}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Ent\+Set\+Contained(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle containing\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle contained\+\_\+entity\+\_\+set, int $\ast$is\+\_\+contained, int $\ast$err)}{iGeom_isEntSetContained(iGeom_Instance instance, iBase_EntitySetHandle containing_entity_set, iBase_EntitySetHandle contained_entity_set, int *is_contained, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Ent\+Set\+Contained (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{containing\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{contained\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+contained, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9003d572c32edd3a76225412930ae308}{}\label{i_geom_8h_a9003d572c32edd3a76225412930ae308}


Return whether an entity set is contained in another set. 

Return whether a set is contained ($\ast$is\+\_\+contained=1) or not contained ($\ast$is\+\_\+contained=0) in another set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em containing\+\_\+entity\+\_\+set} & Entity set being queried \\
\hline
{\em contained\+\_\+entity\+\_\+set} & Entity set potentially contained in containing\+\_\+entity\+\_\+set \\
\hline
{\em is\+\_\+contained} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate@{i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate}}
\index{i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate@{i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$face\+\_\+handles, int face\+\_\+handles\+\_\+size, int $\ast$$\ast$degenerate, int $\ast$degenerate\+\_\+allocated, int $\ast$degenerate\+\_\+size, int $\ast$err)}{iGeom_isFcArrDegenerate(iGeom_Instance, iBase_EntityHandle const *face_handles, int face_handles_size, int **degenerate, int *degenerate_allocated, int *degenerate_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Fc\+Arr\+Degenerate (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{face\+\_\+handles, }
\item[{int}]{face\+\_\+handles\+\_\+size, }
\item[{int $\ast$$\ast$}]{degenerate, }
\item[{int $\ast$}]{degenerate\+\_\+allocated, }
\item[{int $\ast$}]{degenerate\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a3c148ad9e6bf1447e7910b5a7bab3c04}{}\label{i_geom_8h_a3c148ad9e6bf1447e7910b5a7bab3c04}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+Fc\+Degenerate@{i\+Geom\+\_\+is\+Fc\+Degenerate}}
\index{i\+Geom\+\_\+is\+Fc\+Degenerate@{i\+Geom\+\_\+is\+Fc\+Degenerate}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+Fc\+Degenerate(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle face\+\_\+handle, int $\ast$is\+\_\+degenerate, int $\ast$err)}{iGeom_isFcDegenerate(iGeom_Instance, iBase_EntityHandle face_handle, int *is_degenerate, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+Fc\+Degenerate (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{face\+\_\+handle, }
\item[{int $\ast$}]{is\+\_\+degenerate, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a21276f0da3df35353b42c60b0b53be72}{}\label{i_geom_8h_a21276f0da3df35353b42c60b0b53be72}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+is\+List@{i\+Geom\+\_\+is\+List}}
\index{i\+Geom\+\_\+is\+List@{i\+Geom\+\_\+is\+List}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+is\+List(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$is\+\_\+list, int $\ast$err)}{iGeom_isList(iGeom_Instance instance, iBase_EntitySetHandle entity_set, int *is_list, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+is\+List (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{is\+\_\+list, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8606f71754c183a408f9118cf317bc25}{}\label{i_geom_8h_a8606f71754c183a408f9118cf317bc25}


Return whether a specified set is ordered or unordered. 

Return whether a specified set is ordered ($\ast$is\+\_\+list=1) or unordered ($\ast$is\+\_\+list=0) 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set being queried \\
\hline
{\em is\+\_\+list} & Pointer to flag returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+load@{i\+Geom\+\_\+load}}
\index{i\+Geom\+\_\+load@{i\+Geom\+\_\+load}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+load(i\+Geom\+\_\+\+Instance, char const $\ast$name, char const $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)}{iGeom_load(iGeom_Instance, char const *name, char const *options, int *err, int name_len, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+load (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{char const $\ast$}]{name, }
\item[{char const $\ast$}]{options, }
\item[{int $\ast$}]{err, }
\item[{int}]{name\+\_\+len, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a5c9095cda17db5d2fef2078f4f52d165}{}\label{i_geom_8h_a5c9095cda17db5d2fef2078f4f52d165}


Load a geom from a file. 

Load a geom from a file. If entity set is specified, loaded geom is added to that set; specify zero if that is not desired. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Set to which loaded geom will be added, zero if not desired \\
\hline
{\em name} & File name from which geom is to be loaded \\
\hline
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of the file name character string \\
\hline
{\em options\+\_\+len} & Length of the options character string \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+measure@{i\+Geom\+\_\+measure}}
\index{i\+Geom\+\_\+measure@{i\+Geom\+\_\+measure}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+measure(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, double $\ast$$\ast$measures, int $\ast$measures\+\_\+allocated, int $\ast$measures\+\_\+size, int $\ast$err)}{iGeom_measure(iGeom_Instance, iBase_EntityHandle const *entity_handles, int entity_handles_size, double **measures, int *measures_allocated, int *measures_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+measure (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{double $\ast$$\ast$}]{measures, }
\item[{int $\ast$}]{measures\+\_\+allocated, }
\item[{int $\ast$}]{measures\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abc0483369e2d2a74cdddd969916331ee}{}\label{i_geom_8h_abc0483369e2d2a74cdddd969916331ee}


Return the measure (length, area, volume) of entities Return the measure (length, area, volume) of entities. 


\begin{DoxyParams}{Parameters}
{\em entity\+\_\+handles} & Array of entities being queried \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity array \\
\hline
{\em measures} & Measures of entities being queried \\
\hline
{\em measures\+\_\+allocated} & Allocated size of measures array \\
\hline
{\em measures\+\_\+size} & Occupied size of measures array \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+merge\+Ents@{i\+Geom\+\_\+merge\+Ents}}
\index{i\+Geom\+\_\+merge\+Ents@{i\+Geom\+\_\+merge\+Ents}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+merge\+Ents(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, double tolerance, int $\ast$err)}{iGeom_mergeEnts(iGeom_Instance, iBase_EntityHandle const *geom_entities, int geom_entities_size, double tolerance, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+merge\+Ents (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{geom\+\_\+entities, }
\item[{int}]{geom\+\_\+entities\+\_\+size, }
\item[{double}]{tolerance, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ad7bc0eae7967f3222326d684a284ac28}{}\label{i_geom_8h_ad7bc0eae7967f3222326d684a284ac28}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+move\+Ent@{i\+Geom\+\_\+move\+Ent}}
\index{i\+Geom\+\_\+move\+Ent@{i\+Geom\+\_\+move\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+move\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double x, double y, double z, int $\ast$err)}{iGeom_moveEnt(iGeom_Instance, iBase_EntityHandle geom_entity, double x, double y, double z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+move\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af350856e8cd2d163ee3de4424df17136}{}\label{i_geom_8h_af350856e8cd2d163ee3de4424df17136}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+new\+Geom@{i\+Geom\+\_\+new\+Geom}}
\index{i\+Geom\+\_\+new\+Geom@{i\+Geom\+\_\+new\+Geom}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+new\+Geom(char const $\ast$options, i\+Geom\+\_\+\+Instance $\ast$instance\+\_\+out, int $\ast$err, int options\+\_\+len)}{iGeom_newGeom(char const *options, iGeom_Instance *instance_out, int *err, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+new\+Geom (
\begin{DoxyParamCaption}
\item[{char const $\ast$}]{options, }
\item[{{\bf i\+Geom\+\_\+\+Instance} $\ast$}]{instance\+\_\+out, }
\item[{int $\ast$}]{err, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4e97b6376358c4092534589c94edab5f}{}\label{i_geom_8h_a4e97b6376358c4092534589c94edab5f}


Construct a new i\+Geom instance. 

Construct a new i\+Geom instance, using implementation-\/specific options 
\begin{DoxyParams}{Parameters}
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em instance} & Pointer to i\+Geom instance handle returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em options\+\_\+len} & Length of the character string pointed to by options \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+reflect\+Ent@{i\+Geom\+\_\+reflect\+Ent}}
\index{i\+Geom\+\_\+reflect\+Ent@{i\+Geom\+\_\+reflect\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+reflect\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double plane\+\_\+normal\+\_\+x, double plane\+\_\+normal\+\_\+y, double plane\+\_\+normal\+\_\+z, int $\ast$err)}{iGeom_reflectEnt(iGeom_Instance, iBase_EntityHandle geom_entity, double plane_normal_x, double plane_normal_y, double plane_normal_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+reflect\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{plane\+\_\+normal\+\_\+x, }
\item[{double}]{plane\+\_\+normal\+\_\+y, }
\item[{double}]{plane\+\_\+normal\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ae4ce65d222cdf9ab06bfe9e791fedc66}{}\label{i_geom_8h_ae4ce65d222cdf9ab06bfe9e791fedc66}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+reset\+Ent\+Arr\+Iter@{i\+Geom\+\_\+reset\+Ent\+Arr\+Iter}}
\index{i\+Geom\+\_\+reset\+Ent\+Arr\+Iter@{i\+Geom\+\_\+reset\+Ent\+Arr\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+reset\+Ent\+Arr\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Arr\+Iterator, int $\ast$err)}{iGeom_resetEntArrIter(iGeom_Instance, iGeom_EntityArrIterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+reset\+Ent\+Arr\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Arr\+Iterator}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a98bfcb8c45737e0456caca00591f9e52}{}\label{i_geom_8h_a98bfcb8c45737e0456caca00591f9e52}


Reset the array iterator. 

Reset the array iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em ent\+Arr\+\_\+iterator} & Iterator to reset \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+reset\+Ent\+Iter@{i\+Geom\+\_\+reset\+Ent\+Iter}}
\index{i\+Geom\+\_\+reset\+Ent\+Iter@{i\+Geom\+\_\+reset\+Ent\+Iter}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+reset\+Ent\+Iter(i\+Geom\+\_\+\+Instance, i\+Geom\+\_\+\+Entity\+Iterator, int $\ast$err)}{iGeom_resetEntIter(iGeom_Instance, iGeom_EntityIterator, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+reset\+Ent\+Iter (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Geom\+\_\+\+Entity\+Iterator}}]{, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af08614c041248ce944c27fa13dd1bdae}{}\label{i_geom_8h_af08614c041248ce944c27fa13dd1bdae}


Reset the iterator. 

Reset the iterator 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+iterator} & Iterator to reset \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Arr\+Tag@{i\+Geom\+\_\+rmv\+Arr\+Tag}}
\index{i\+Geom\+\_\+rmv\+Arr\+Tag@{i\+Geom\+\_\+rmv\+Arr\+Tag}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Arr\+Tag(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iGeom_rmvArrTag(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Arr\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8f5dbf11e9d377c7eb3dbae2927a590b}{}\label{i_geom_8h_a8f5dbf11e9d377c7eb3dbae2927a590b}


Remove a tag value from an array of entities. 

Remove a tag value from an array of entities 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity from which tag is being removed \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity array \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set@{i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set}}
\index{i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set@{i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iGeom_rmvEntArrFromSet(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Ent\+Arr\+From\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ac76fb2ff2c27e994551f8c5cbeb3af7a}{}\label{i_geom_8h_ac76fb2ff2c27e994551f8c5cbeb3af7a}


Remove an array of entities from a set. 

Remove an array of entities from a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Array of entities being remove \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in entity\+\_\+handles array \\
\hline
{\em entity\+\_\+set} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Ent\+From\+Set@{i\+Geom\+\_\+rmv\+Ent\+From\+Set}}
\index{i\+Geom\+\_\+rmv\+Ent\+From\+Set@{i\+Geom\+\_\+rmv\+Ent\+From\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Ent\+From\+Set(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, int $\ast$err)}{iGeom_rmvEntFromSet(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_EntitySetHandle entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Ent\+From\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a535a2ab95d4a2f7c39b426a38ca908c7}{}\label{i_geom_8h_a535a2ab95d4a2f7c39b426a38ca908c7}


Remove an entity from a set. 

Remove an entity from a set


\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & The entity being removed \\
\hline
{\em entity\+\_\+set} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Ent\+Set@{i\+Geom\+\_\+rmv\+Ent\+Set}}
\index{i\+Geom\+\_\+rmv\+Ent\+Set@{i\+Geom\+\_\+rmv\+Ent\+Set}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Ent\+Set(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+to\+\_\+remove, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, int $\ast$err)}{iGeom_rmvEntSet(iGeom_Instance instance, iBase_EntitySetHandle entity_set_to_remove, iBase_EntitySetHandle entity_set_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Ent\+Set (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+to\+\_\+remove, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af223ff0f80f76b9a3e27098f01f06180}{}\label{i_geom_8h_af223ff0f80f76b9a3e27098f01f06180}


Remove an entity set from a set. 

Remove an entity set from a set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+to\+\_\+remove} & The entity set being removed \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Pointer to the set being removed from \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Ent\+Set\+Tag@{i\+Geom\+\_\+rmv\+Ent\+Set\+Tag}}
\index{i\+Geom\+\_\+rmv\+Ent\+Set\+Tag@{i\+Geom\+\_\+rmv\+Ent\+Set\+Tag}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Ent\+Set\+Tag(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iGeom_rmvEntSetTag(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Ent\+Set\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_af21c90406724bda3ceb950e16b0eb8f9}{}\label{i_geom_8h_af21c90406724bda3ceb950e16b0eb8f9}


Remove a tag value from an entity set. 

Remove a tag value from an entity set 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set from which tag is being removed \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Prnt\+Chld@{i\+Geom\+\_\+rmv\+Prnt\+Chld}}
\index{i\+Geom\+\_\+rmv\+Prnt\+Chld@{i\+Geom\+\_\+rmv\+Prnt\+Chld}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Prnt\+Chld(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle parent\+\_\+entity\+\_\+set, i\+Base\+\_\+\+Entity\+Set\+Handle child\+\_\+entity\+\_\+set, int $\ast$err)}{iGeom_rmvPrntChld(iGeom_Instance instance, iBase_EntitySetHandle parent_entity_set, iBase_EntitySetHandle child_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Prnt\+Chld (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{parent\+\_\+entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{child\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aa790d6d187bb9199aa9bd05662ded3dd}{}\label{i_geom_8h_aa790d6d187bb9199aa9bd05662ded3dd}


Remove parent/child links between two sets. 

Remove parent/child links between two sets. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em parent\+\_\+entity\+\_\+set} & Pointer to parent set \\
\hline
{\em child\+\_\+entity\+\_\+set} & Pointer to child set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rmv\+Tag@{i\+Geom\+\_\+rmv\+Tag}}
\index{i\+Geom\+\_\+rmv\+Tag@{i\+Geom\+\_\+rmv\+Tag}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rmv\+Tag(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int $\ast$err)}{iGeom_rmvTag(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rmv\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a6f24a2024048ba51296765ba1129d947}{}\label{i_geom_8h_a6f24a2024048ba51296765ba1129d947}


Remove a tag value from an entity. 

Remove a tag value from an entity 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity from which tag is being removed \\
\hline
{\em tag\+\_\+handle} & Tag handle of tag being removed \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+rotate\+Ent@{i\+Geom\+\_\+rotate\+Ent}}
\index{i\+Geom\+\_\+rotate\+Ent@{i\+Geom\+\_\+rotate\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+rotate\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double angle, double axis\+\_\+normal\+\_\+x, double axis\+\_\+normal\+\_\+y, double axis\+\_\+normal\+\_\+z, int $\ast$err)}{iGeom_rotateEnt(iGeom_Instance, iBase_EntityHandle geom_entity, double angle, double axis_normal_x, double axis_normal_y, double axis_normal_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+rotate\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{angle, }
\item[{double}]{axis\+\_\+normal\+\_\+x, }
\item[{double}]{axis\+\_\+normal\+\_\+y, }
\item[{double}]{axis\+\_\+normal\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ae75e252f951667f300ecf52d083788f9}{}\label{i_geom_8h_ae75e252f951667f300ecf52d083788f9}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+save@{i\+Geom\+\_\+save}}
\index{i\+Geom\+\_\+save@{i\+Geom\+\_\+save}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+save(i\+Geom\+\_\+\+Instance, char const $\ast$name, char const $\ast$options, int $\ast$err, int name\+\_\+len, int options\+\_\+len)}{iGeom_save(iGeom_Instance, char const *name, char const *options, int *err, int name_len, int options_len)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+save (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{char const $\ast$}]{name, }
\item[{char const $\ast$}]{options, }
\item[{int $\ast$}]{err, }
\item[{int}]{name\+\_\+len, }
\item[{int}]{options\+\_\+len}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aeba95fd535821fb99b52a9dca8b9a7ab}{}\label{i_geom_8h_aeba95fd535821fb99b52a9dca8b9a7ab}


Save a geom to a file. 

Save a geom to a file. If entity set is specified, save only the geom contained in that set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set being saved \\
\hline
{\em name} & File name to which geom is to be saved \\
\hline
{\em options} & Pointer to implementation-\/specific options string \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
{\em name\+\_\+len} & Length of the file name character string \\
\hline
{\em options\+\_\+len} & Length of the options character string \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+scale\+Ent@{i\+Geom\+\_\+scale\+Ent}}
\index{i\+Geom\+\_\+scale\+Ent@{i\+Geom\+\_\+scale\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+scale\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double scale\+\_\+x, double scale\+\_\+y, double scale\+\_\+z, int $\ast$err)}{iGeom_scaleEnt(iGeom_Instance, iBase_EntityHandle geom_entity, double scale_x, double scale_y, double scale_z, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+scale\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{scale\+\_\+x, }
\item[{double}]{scale\+\_\+y, }
\item[{double}]{scale\+\_\+z, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a9743afe399a52a26898e0272b68d1b17}{}\label{i_geom_8h_a9743afe399a52a26898e0272b68d1b17}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+section\+Ent@{i\+Geom\+\_\+section\+Ent}}
\index{i\+Geom\+\_\+section\+Ent@{i\+Geom\+\_\+section\+Ent}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+section\+Ent(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double plane\+\_\+normal\+\_\+x, double plane\+\_\+normal\+\_\+y, double plane\+\_\+normal\+\_\+z, double offset, int reverse, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity2, int $\ast$err)}{iGeom_sectionEnt(iGeom_Instance, iBase_EntityHandle geom_entity, double plane_normal_x, double plane_normal_y, double plane_normal_z, double offset, int reverse, iBase_EntityHandle *geom_entity2, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+section\+Ent (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{plane\+\_\+normal\+\_\+x, }
\item[{double}]{plane\+\_\+normal\+\_\+y, }
\item[{double}]{plane\+\_\+normal\+\_\+z, }
\item[{double}]{offset, }
\item[{int}]{reverse, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity2, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_ab660da001afa1fd24cdaabd66859a569}{}\label{i_geom_8h_ab660da001afa1fd24cdaabd66859a569}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Arr\+Data@{i\+Geom\+\_\+set\+Arr\+Data}}
\index{i\+Geom\+\_\+set\+Arr\+Data@{i\+Geom\+\_\+set\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_setArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, const char *tag_values, int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+values, }
\item[{int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aaee91f35ef33a1f24ff1933694dfc189}{}\label{i_geom_8h_aaee91f35ef33a1f24ff1933694dfc189}


Set tag values of arbitrary type on an array of entities. 

Set tag values of arbitrary type on an array of entities. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entity \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Data@{i\+Geom\+\_\+set\+Data}}
\index{i\+Geom\+\_\+set\+Data@{i\+Geom\+\_\+set\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+value, int tag\+\_\+value\+\_\+size, int $\ast$err)}{iGeom_setData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, const char *tag_value, int tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+value, }
\item[{int}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a36e3079e9dfeee2687d2fde863eec8af}{}\label{i_geom_8h_a36e3079e9dfeee2687d2fde863eec8af}


Set a tag value of arbitrary type on an entity. 

Set a tag value of arbitrary type on an entity. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Pointer to tag data being set on entity \\
\hline
{\em tag\+\_\+value\+\_\+size} & Size in bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Dbl\+Arr\+Data@{i\+Geom\+\_\+set\+Dbl\+Arr\+Data}}
\index{i\+Geom\+\_\+set\+Dbl\+Arr\+Data@{i\+Geom\+\_\+set\+Dbl\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Dbl\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const double $\ast$tag\+\_\+values, const int tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_setDblArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, const double *tag_values, const int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Dbl\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const double $\ast$}]{tag\+\_\+values, }
\item[{const int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_aebb343ecd1156c359c276eae890bfe56}{}\label{i_geom_8h_aebb343ecd1156c359c276eae890bfe56}


Set tag values of double type on an array of entities. 

Set tag values of double type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of doubles of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Dbl\+Data@{i\+Geom\+\_\+set\+Dbl\+Data}}
\index{i\+Geom\+\_\+set\+Dbl\+Data@{i\+Geom\+\_\+set\+Dbl\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Dbl\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double tag\+\_\+value, int $\ast$err)}{iGeom_setDblData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, double tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a59aaa169b52e602833cf6f804b54167e}{}\label{i_geom_8h_a59aaa169b52e602833cf6f804b54167e}


Set a tag value of double type on an entity. 

Set a tag value of double type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+E\+H\+Arr\+Data@{i\+Geom\+\_\+set\+E\+H\+Arr\+Data}}
\index{i\+Geom\+\_\+set\+E\+H\+Arr\+Data@{i\+Geom\+\_\+set\+E\+H\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+E\+H\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const i\+Base\+\_\+\+Entity\+Handle $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_setEHArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, const iBase_EntityHandle *tag_values, int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+E\+H\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{tag\+\_\+values, }
\item[{int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a2f46bc65e017978f8eca1814fe3bbfb8}{}\label{i_geom_8h_a2f46bc65e017978f8eca1814fe3bbfb8}


Set tag values of entity handle type on an array of entities. 

Set tag values of entity handle type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of entity handles of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+E\+H\+Data@{i\+Geom\+\_\+set\+E\+H\+Data}}
\index{i\+Geom\+\_\+set\+E\+H\+Data@{i\+Geom\+\_\+set\+E\+H\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+E\+H\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle tag\+\_\+value, int $\ast$err)}{iGeom_setEHData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, iBase_EntityHandle tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a1e3f0abcdd325ef34ed148081f107b9b}{}\label{i_geom_8h_a1e3f0abcdd325ef34ed148081f107b9b}


Set a tag value of entity handle type on an entity. 

Set a tag value of entity handle type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Ent\+Set\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Data}}
\index{i\+Geom\+\_\+set\+Ent\+Set\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Ent\+Set\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const char $\ast$tag\+\_\+value, int tag\+\_\+value\+\_\+size, int $\ast$err)}{iGeom_setEntSetData(iGeom_Instance instance, iBase_EntitySetHandle entity_set_handle, iBase_TagHandle tag_handle, const char *tag_value, int tag_value_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Ent\+Set\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const char $\ast$}]{tag\+\_\+value, }
\item[{int}]{tag\+\_\+value\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a8be6aaff1f6a5cd80535d68d977f4ac3}{}\label{i_geom_8h_a8be6aaff1f6a5cd80535d68d977f4ac3}


Set a tag value of arbitrary type on an entity set. 

Set a tag value of arbitrary type on an entity set. Tag data is passed as char$\ast$ type, but really represents pointer to arbitrary data. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+handle} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Pointer to tag data being set on entity set \\
\hline
{\em tag\+\_\+value\+\_\+size} & Size in bytes of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data}}
\index{i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, double tag\+\_\+value, int $\ast$err)}{iGeom_setEntSetDblData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, double tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Ent\+Set\+Dbl\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{double}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_abf9d824d0130fc0639069c7e854f3642}{}\label{i_geom_8h_abf9d824d0130fc0639069c7e854f3642}


Set a tag value of double type on an entity set. 

Set a tag value of double type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data}}
\index{i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, i\+Base\+\_\+\+Entity\+Handle tag\+\_\+value, int $\ast$err)}{iGeom_setEntSetEHData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, iBase_EntityHandle tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Ent\+Set\+E\+H\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7fb506af597e996e1602723527b0a72e}{}\label{i_geom_8h_a7fb506af597e996e1602723527b0a72e}


Set a tag value of entity handle type on an entity set. 

Set a tag value of entity handle type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data}}
\index{i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data@{i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int tag\+\_\+value, int $\ast$err)}{iGeom_setEntSetIntData(iGeom_Instance instance, iBase_EntitySetHandle entity_set, iBase_TagHandle tag_handle, int tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Ent\+Set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a4a2a30a2e566371836dd9d0a32bfc3ea}{}\label{i_geom_8h_a4a2a30a2e566371836dd9d0a32bfc3ea}


Set a tag value of integer type on an entity set. 

Set a tag value of integer type on an entity set. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set} & Entity set on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity set \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity set \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Int\+Arr\+Data@{i\+Geom\+\_\+set\+Int\+Arr\+Data}}
\index{i\+Geom\+\_\+set\+Int\+Arr\+Data@{i\+Geom\+\_\+set\+Int\+Arr\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Int\+Arr\+Data(i\+Geom\+\_\+\+Instance instance, const i\+Base\+\_\+\+Entity\+Handle $\ast$entity\+\_\+handles, int entity\+\_\+handles\+\_\+size, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, const int $\ast$tag\+\_\+values, int tag\+\_\+values\+\_\+size, int $\ast$err)}{iGeom_setIntArrData(iGeom_Instance instance, const iBase_EntityHandle *entity_handles, int entity_handles_size, iBase_TagHandle tag_handle, const int *tag_values, int tag_values_size, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Int\+Arr\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{const {\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{entity\+\_\+handles, }
\item[{int}]{entity\+\_\+handles\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{const int $\ast$}]{tag\+\_\+values, }
\item[{int}]{tag\+\_\+values\+\_\+size, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a78deb26c15dacc4bc2129232ffc73123}{}\label{i_geom_8h_a78deb26c15dacc4bc2129232ffc73123}


Set tag values of integer type on an array of entities. 

Set tag values of integer type on an array of entities. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handles} & Entity array on which tag is being set \\
\hline
{\em entity\+\_\+handles\+\_\+size} & Number of entities in array \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+values} & Pointer to tag data being set on entities \\
\hline
{\em tag\+\_\+values\+\_\+size} & Size in total number of integers of tag data \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+set\+Int\+Data@{i\+Geom\+\_\+set\+Int\+Data}}
\index{i\+Geom\+\_\+set\+Int\+Data@{i\+Geom\+\_\+set\+Int\+Data}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+set\+Int\+Data(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Handle entity\+\_\+handle, i\+Base\+\_\+\+Tag\+Handle tag\+\_\+handle, int tag\+\_\+value, int $\ast$err)}{iGeom_setIntData(iGeom_Instance instance, iBase_EntityHandle entity_handle, iBase_TagHandle tag_handle, int tag_value, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+set\+Int\+Data (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{entity\+\_\+handle, }
\item[{{\bf i\+Base\+\_\+\+Tag\+Handle}}]{tag\+\_\+handle, }
\item[{int}]{tag\+\_\+value, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a7f580d046ee543ed958a7049e352dad8}{}\label{i_geom_8h_a7f580d046ee543ed958a7049e352dad8}


Set a tag value of integer type on an entity. 

Set a tag value of integer type on an entity. 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+handle} & Entity on which tag is being set \\
\hline
{\em tag\+\_\+handle} & Tag being set on an entity \\
\hline
{\em tag\+\_\+value} & Tag value being set on entity \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+subtract@{i\+Geom\+\_\+subtract}}
\index{i\+Geom\+\_\+subtract@{i\+Geom\+\_\+subtract}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+subtract(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iGeom_subtract(iGeom_Instance instance, iBase_EntitySetHandle entity_set_1, iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+subtract (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a748d2630bbc285fa6d878c615dedce6e}{}\label{i_geom_8h_a748d2630bbc285fa6d878c615dedce6e}


Subtract contents of one entity set from another. 

Subtract contents of one entity set from another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set from which other set is being subtracted \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being subtracted from other set \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+subtract\+Ents@{i\+Geom\+\_\+subtract\+Ents}}
\index{i\+Geom\+\_\+subtract\+Ents@{i\+Geom\+\_\+subtract\+Ents}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+subtract\+Ents(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle blank, i\+Base\+\_\+\+Entity\+Handle tool, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_subtractEnts(iGeom_Instance, iBase_EntityHandle blank, iBase_EntityHandle tool, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+subtract\+Ents (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{blank, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{tool, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a140eb55491f86b0a35c2b006b9b463e8}{}\label{i_geom_8h_a140eb55491f86b0a35c2b006b9b463e8}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+sweep\+Ent\+About\+Axis@{i\+Geom\+\_\+sweep\+Ent\+About\+Axis}}
\index{i\+Geom\+\_\+sweep\+Ent\+About\+Axis@{i\+Geom\+\_\+sweep\+Ent\+About\+Axis}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+sweep\+Ent\+About\+Axis(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle geom\+\_\+entity, double angle, double axis\+\_\+normal\+\_\+x, double axis\+\_\+normal\+\_\+y, double axis\+\_\+normal\+\_\+z, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity2, int $\ast$err)}{iGeom_sweepEntAboutAxis(iGeom_Instance, iBase_EntityHandle geom_entity, double angle, double axis_normal_x, double axis_normal_y, double axis_normal_z, iBase_EntityHandle *geom_entity2, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+sweep\+Ent\+About\+Axis (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle}}]{geom\+\_\+entity, }
\item[{double}]{angle, }
\item[{double}]{axis\+\_\+normal\+\_\+x, }
\item[{double}]{axis\+\_\+normal\+\_\+y, }
\item[{double}]{axis\+\_\+normal\+\_\+z, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity2, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a2014ad2bf529f0536c52459e6f5ff634}{}\label{i_geom_8h_a2014ad2bf529f0536c52459e6f5ff634}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+unite@{i\+Geom\+\_\+unite}}
\index{i\+Geom\+\_\+unite@{i\+Geom\+\_\+unite}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+unite(i\+Geom\+\_\+\+Instance instance, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+1, i\+Base\+\_\+\+Entity\+Set\+Handle entity\+\_\+set\+\_\+2, i\+Base\+\_\+\+Entity\+Set\+Handle $\ast$result\+\_\+entity\+\_\+set, int $\ast$err)}{iGeom_unite(iGeom_Instance instance, iBase_EntitySetHandle entity_set_1, iBase_EntitySetHandle entity_set_2, iBase_EntitySetHandle *result_entity_set, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+unite (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{instance, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+1, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle}}]{entity\+\_\+set\+\_\+2, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Set\+Handle} $\ast$}]{result\+\_\+entity\+\_\+set, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a0fa341941b5adc507e5bbdf75e03224a}{}\label{i_geom_8h_a0fa341941b5adc507e5bbdf75e03224a}


Unite contents of one entity set with another. 

Unite contents of one entity set with another 
\begin{DoxyParams}{Parameters}
{\em instance} & i\+Geom instance handle \\
\hline
{\em entity\+\_\+set\+\_\+1} & Entity set being united with another \\
\hline
{\em entity\+\_\+set\+\_\+2} & Entity set being united with another \\
\hline
{\em result\+\_\+entity\+\_\+set} & Pointer to entity set returned from function \\
\hline
{\em $\ast$err} & Pointer to error type returned from function \\
\hline
\end{DoxyParams}
\index{i\+Geom.\+h@{i\+Geom.\+h}!i\+Geom\+\_\+unite\+Ents@{i\+Geom\+\_\+unite\+Ents}}
\index{i\+Geom\+\_\+unite\+Ents@{i\+Geom\+\_\+unite\+Ents}!i\+Geom.\+h@{i\+Geom.\+h}}
\subsubsection[{\texorpdfstring{i\+Geom\+\_\+unite\+Ents(i\+Geom\+\_\+\+Instance, i\+Base\+\_\+\+Entity\+Handle const $\ast$geom\+\_\+entities, int geom\+\_\+entities\+\_\+size, i\+Base\+\_\+\+Entity\+Handle $\ast$geom\+\_\+entity, int $\ast$err)}{iGeom_uniteEnts(iGeom_Instance, iBase_EntityHandle const *geom_entities, int geom_entities_size, iBase_EntityHandle *geom_entity, int *err)}}]{\setlength{\rightskip}{0pt plus 5cm}void i\+Geom\+\_\+unite\+Ents (
\begin{DoxyParamCaption}
\item[{{\bf i\+Geom\+\_\+\+Instance}}]{, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} const $\ast$}]{geom\+\_\+entities, }
\item[{int}]{geom\+\_\+entities\+\_\+size, }
\item[{{\bf i\+Base\+\_\+\+Entity\+Handle} $\ast$}]{geom\+\_\+entity, }
\item[{int $\ast$}]{err}
\end{DoxyParamCaption}
)}\hypertarget{i_geom_8h_a6eb2310c9849e52a9c97ed9c85211800}{}\label{i_geom_8h_a6eb2310c9849e52a9c97ed9c85211800}
