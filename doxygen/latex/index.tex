The I\+T\+A\+PS Geometry Interface i\+Geom provides a common interface for accessing geometry and data associated with a mesh. Applications written to use this interface can use a variety of implementations, choosing the one that best meets its needs. They can also use tools written to this interface.\hypertarget{index_ITAPS}{}\section{Data Model}\label{index_ITAPS}
The I\+T\+A\+PS interfaces use a data model composed of four basic data types\+:~\newline
{\itshape Entity\+:} basic topological entities in a model, e.\+g. vertices, edges, faces, regions. ~\newline
{\itshape Entity} {\itshape Set\+:} arbitrary grouping of other entities and sets. Entity sets also support parent/child relations with other sets which are distinct from entities contained in those sets. Parent/child links can be used to embed graph relationships between sets, e.\+g. to represent topological relationships between the sets. ~\newline
{\itshape Interface\+:} the object with which model is associated and on which functions in i\+Geom are called. ~\newline
{\itshape Tag\+:} application data associated with objects of any of the other data types. Each tag has a designated name, size, and data type.\hypertarget{index_JTAPS}{}\section{Entity Type}\label{index_JTAPS}
Each entity has a specific Entity Type. The Entity Type is one of V\+E\+R\+T\+EX, E\+D\+GE, F\+A\+CE, and R\+E\+G\+I\+ON, and is synonymous with the topological dimension of the entity. Entity Type is an enumerated type in the i\+Base\+\_\+\+Entity\+Type enumeration.\hypertarget{index_KTAPS}{}\section{Entity-\/, Array-\/, and Iterator-\/\+Based Access}\label{index_KTAPS}
The i\+Geom interface provides functions for accessing entities individually, as arrays of entities, or using iterators. These access methods have different memory versus execution time tradeoffs, depending on the implementation.\hypertarget{index_LTAPS}{}\section{Lists Passed Through Interface}\label{index_LTAPS}
Many of the functions in i\+Geom have arguments corresponding to lists of objects. In-\/type arguments for lists consist of a pointer to an array and a list size. Lists returned from functions are passed in three arguments, a pointer to the array representing the list, and pointers to the allocated and occupied lengths of the array. These three arguments are inout-\/type arguments, because they can be allocated by the application and passed into the interface to hold the results of the function. Lists which are pre-\/allocated must be large enough to hold the results of the function; if this is not the case, an error is generated. Otherwise, the occupied size is changed to the size output from the function. If a list argument is unallocated (the list pointer points to a N\+U\+LL value) or if the incoming value of the allocated size is zero, the list storage will be allocated by the implementation. IN A\+LL C\+A\+S\+ES, M\+E\+M\+O\+RY A\+L\+L\+O\+C\+A\+T\+ED BY I\+T\+A\+PS I\+N\+T\+E\+R\+F\+A\+CE I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+O\+NS IS D\+O\+NE U\+S\+I\+NG T\+HE C M\+A\+L\+L\+OC F\+U\+N\+C\+T\+I\+ON, A\+ND C\+AN BE D\+E-\/\+A\+L\+L\+O\+C\+A\+T\+ED U\+S\+I\+NG T\+HE C F\+R\+EE F\+U\+N\+C\+T\+I\+ON. 